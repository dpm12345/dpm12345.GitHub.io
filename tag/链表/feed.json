{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"链表\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.github.io",
    "items": [
        {
            "id": "http://dpm12345.github.io/posts/b6465ced/",
            "url": "http://dpm12345.github.io/posts/b6465ced/",
            "title": "两数相加",
            "date_published": "2022-03-18T15:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv\">两数相加</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"\" /></p>\n<h2 id=\"不带头节点\"><a class=\"anchor\" href=\"#不带头节点\">#</a> 不带头节点</h2>\n<pre><code class=\"language-c++\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        ListNode* ans = nullptr;               // 开始节点\n        ListNode* tail = nullptr;              // 尾节点\n        int add = 0;                           // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        &#123;\n            int m = l1? l1 -&gt;val : 0;\n            int n = l2? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;       // 个位数\n            add = (m + n + add)/10;            // 进位\n            if(!ans)                           \n            &#123;                                  \n                ans = tail = new ListNode(num);\n            &#125;\n            else\n            &#123;\n                tail -&gt; next = new ListNode(num);\n                tail = tail -&gt; next;\n            &#125;\n\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        &#125;\n        if(add)                                // 如果还有进位，那么应该再创建一个节点\n            tail -&gt;next = new ListNode(add);\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"带头结点-省去了无节点情况的考虑代码\"><a class=\"anchor\" href=\"#带头结点-省去了无节点情况的考虑代码\">#</a> 带头结点 (省去了无节点情况的考虑代码)</h2>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        ListNode* ans = new ListNode(-1);       //ans-&gt;next 为答案\n        ListNode* cnode = ans;                  // 遍历节点指针\n        int add = 0;                            // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        &#123;\n            int m = l1 ? l1 -&gt;val : 0;\n            int n = l2 ? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;        // 个位数\n            add = (m + n + add)/10;             // 进位\n            cnode -&gt; next = new ListNode(num);  // 链接\n            cnode = cnode -&gt; next;              // 转移\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        &#125;\n        if(add)\n            cnode -&gt;next = new ListNode(add);\n        return ans-&gt;next;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/45daaf11/",
            "url": "http://dpm12345.github.io/posts/45daaf11/",
            "title": "环形链表",
            "date_published": "2021-12-31T11:54:40.000Z",
            "content_html": "<h1 id=\"环形链表\"><a class=\"anchor\" href=\"#环形链表\">#</a> 环形链表</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv\">环形链表</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<h2 id=\"利用哈希表\"><a class=\"anchor\" href=\"#利用哈希表\">#</a> 利用哈希表</h2>\n<p>** 方法详情：** 由于如果一个链表是环形链表，那么在不断地跳入下一个结点坐标时，其地址必然与前面 d 的某个地址相同，也就是说，我们可以把每个结点的地址存入哈希表中，当出现要存入结点地址已经在哈希表中存过之后，那么该链表必然是环形链表，否则不是。据此，时间方面，我们可知只需最长只需遍历链表结点一遍；空间方面，我们创建了一个哈希表，最多存入链表的总个数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool hasCycle(ListNode *head) &#123;\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        &#123;\n            if(a.count(head))\n            return true;\n            a.insert(&#123;head,0&#125;);\n            head=head-&gt;next;\n        &#125;\n        return false;\n        \n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"利用双指针快慢指针\"><a class=\"anchor\" href=\"#利用双指针快慢指针\">#</a> 利用双指针（快慢指针）</h2>\n<p>题目中的进阶要求我们使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的内存，该方案是可以实现的，具体涉及到双指针方法详情：我们可以创建两个指针，快指针 fast，每次走两步，慢指针 slow，每次走一步。那么就很容易得到如果该环形链表为环形链表，快指针必定会在环形结点的某一个结点与慢指针相遇 (或者说是追上慢指针)，那么只需判断最后两个指针是否指向同一个结点即可</p>\n<p>** 证明：** 在该方法中，使用了分别走一步和两步的指针。如果该链表是环形链表，当慢指针进入环形部分中，此时快指针也在某处，设他们相差<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个结点，而他们的速度之差为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mspace width=\"1em\"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width=\"1em\"/><mn>1</mn><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">n\\quad mod\\quad1==0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 也就是说，必定存在某一时刻能够使两指针指向同一个地址据此，时间方面，在慢指针进入环形结点后，快慢指针初始相距最长为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo stretchy=\"false\">(</mo><mi>L</mi><mo>&lt;</mo><mo>=</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L(L&lt;=N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>, 而在此之前遍历次数也只和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 有关，如果没有环形链表，那么遍历次数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span></span></span></span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">⌋</span></span></span></span></p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool hasCycle(ListNode *head) &#123;\n        ListNode*fast=head,*slow=head;\n        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)\n        &#123;\n            fast=fast-&gt;next-&gt;next;\n            slow=slow-&gt;next;\n            if(fast==slow)\n                return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"环形链表-ii求出环形链表开始结点位置\"><a class=\"anchor\" href=\"#环形链表-ii求出环形链表开始结点位置\">#</a> 环形链表 II（求出环形链表开始结点位置）</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv\">环形链表 II</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<p>该题与上面题目比较像，但在确定环的同时也要返回环开始结点</p>\n<h2 id=\"哈希表\"><a class=\"anchor\" href=\"#哈希表\">#</a> 哈希表</h2>\n<p>在上一个问题中，我们是找到重复就返回 true，那么同理在这里我们可以使用相同的代码，仅仅把返回值的 true 和 false 分别改成对应节点和 NULL 即可</p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        &#123;\n            if(a.count(head))\n               return head;\n            a.insert(&#123;head,1&#125;);\n            head=head-&gt;next;\n        &#125;\n        return NULL;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"双指针快慢指针\"><a class=\"anchor\" href=\"#双指针快慢指针\">#</a> 双指针（快慢指针）</h2>\n<p>为了降低内存我们同样也可以使用快慢指针，将空间复杂度降到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，这里涉及到一个证明</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E8%AF%81%E6%98%8E.jpg\" alt=\"\" /></p>\n<p>所以我们可以在双指针基础上，在他们相遇时新建两个指针 (或者直接用现成的 <code>head</code>  和 <code>slow/fast</code>  指针，不断往后面走，相遇时得到该位置</p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        ListNode *slow=head,*fast=head;\n        while(fast&amp;&amp;fast-&gt;next)\n        &#123;\n            slow=slow-&gt;next;\n            fast=fast-&gt;next-&gt;next;\n            if(slow==fast)\n            &#123;\n                ListNode* start=head,*meet=slow;\n                while(start!=meet)\n                &#123;\n                    start=start-&gt;next;\n                    meet=meet-&gt;next;\n                &#125;\n                return meet;\n            &#125;\n        &#125;\n        return NULL;\n        \n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表",
                "双指针（快慢指针）"
            ]
        }
    ]
}