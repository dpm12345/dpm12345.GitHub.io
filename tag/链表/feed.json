{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"链表\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/b6465ced/",
            "url": "http://dpm12345.cn/posts/b6465ced/",
            "title": "两数相加",
            "date_published": "2022-03-18T15:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv\">两数相加</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<h2 id=\"不带头节点\"><a href=\"#不带头节点\" class=\"headerlink\" title=\"不带头节点\"></a>不带头节点</h2><pre><code class=\"cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* ans = nullptr;               // 开始节点\n        ListNode* tail = nullptr;              // 尾节点\n        int add = 0;                           // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        {\n            int m = l1? l1 -&gt;val : 0;\n            int n = l2? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;       // 个位数\n            add = (m + n + add)/10;            // 进位\n            if(!ans)                           \n            {                                  \n                ans = tail = new ListNode(num);\n            }\n            else\n            {\n                tail -&gt; next = new ListNode(num);\n                tail = tail -&gt; next;\n            }\n\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        }\n        if(add)                                // 如果还有进位，那么应该再创建一个节点\n            tail -&gt;next = new ListNode(add);\n        return ans;\n    }\n};\n</code></pre>\n<h2 id=\"带头结点-省去了无节点情况的考虑代码\"><a href=\"#带头结点-省去了无节点情况的考虑代码\" class=\"headerlink\" title=\"带头结点 (省去了无节点情况的考虑代码)\"></a>带头结点 (省去了无节点情况的考虑代码)</h2><pre><code class=\"cpp\">class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* ans = new ListNode(-1);       //ans-&gt;next 为答案\n        ListNode* cnode = ans;                  // 遍历节点指针\n        int add = 0;                            // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        {\n            int m = l1 ? l1 -&gt;val : 0;\n            int n = l2 ? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;        // 个位数\n            add = (m + n + add)/10;             // 进位\n            cnode -&gt; next = new ListNode(num);  // 链接\n            cnode = cnode -&gt; next;              // 转移\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        }\n        if(add)\n            cnode -&gt;next = new ListNode(add);\n        return ans-&gt;next;\n    }\n};\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/45daaf11/",
            "url": "http://dpm12345.cn/posts/45daaf11/",
            "title": "环形链表",
            "date_published": "2021-12-31T11:54:40.000Z",
            "content_html": "<h1 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv\">环形链表</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<h2 id=\"利用哈希表\"><a href=\"#利用哈希表\" class=\"headerlink\" title=\"利用哈希表\"></a>利用哈希表</h2><p><strong>方法详情：</strong>由于如果一个链表是环形链表，那么在不断地跳入下一个结点坐标时，其地址必然与前面d的某个地址相同，也就是说，我们可以把每个结点的地址存入哈希表中，当出现要存入结点地址已经在哈希表中存过之后，那么该链表必然是环形链表，否则不是。据此，时间方面，我们可知只需最长只需遍历链表结点一遍；空间方面，我们创建了一个哈希表，最多存入链表的总个数$n$</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(n)$</li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        {\n            if(a.count(head))\n            return true;\n            a.insert({head,0});\n            head=head-&gt;next;\n        }\n        return false;\n        \n    }\n};\n</code></pre>\n<h2 id=\"利用双指针（快慢指针）\"><a href=\"#利用双指针（快慢指针）\" class=\"headerlink\" title=\"利用双指针（快慢指针）\"></a>利用双指针（快慢指针）</h2><p>题目中的进阶要求我们使用$O(1)$的内存，该方案是可以实现的，具体涉及到双指针方法详情：我们可以创建两个指针，快指针fast，每次走两步，慢指针slow，每次走一步。那么就很容易得到如果该环形链表为环形链表，快指针必定会在环形结点的某一个结点与慢指针相遇(或者说是追上慢指针)，那么只需判断最后两个指针是否指向同一个结点即可</p>\n<p><strong>证明：</strong>在该方法中，使用了分别走一步和两步的指针。如果该链表是环形链表，当慢指针进入环形部分中，此时快指针也在某处，设他们相差$n$个结点，而他们的速度之差为$1$，$n\\quad mod\\quad1==0$ 也就是说，必定存在某一时刻能够使两指针指向同一个地址据此，时间方面，在慢指针进入环形结点后，快慢指针初始相距最长为$L(L&lt;=N)$, 而在此之前遍历次数也只和$N$有关，如果没有环形链表，那么遍历次数为$\\lfloor$$\\frac{n}{2}$$\\rfloor$</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(1)$</li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode*fast=head,*slow=head;\n        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)\n        {\n            fast=fast-&gt;next-&gt;next;\n            slow=slow-&gt;next;\n            if(fast==slow)\n                return true;\n        }\n        return false;\n    }\n};\n</code></pre>\n<h1 id=\"环形链表-II（求出环形链表开始结点位置）\"><a href=\"#环形链表-II（求出环形链表开始结点位置）\" class=\"headerlink\" title=\"环形链表 II（求出环形链表开始结点位置）\"></a>环形链表 II（求出环形链表开始结点位置）</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv\">环形链表 II</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<p>该题与上面题目比较像，但在确定环的同时也要返回环开始结点</p>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><p>在上一个问题中，我们是找到重复就返回true，那么同理在这里我们可以使用相同的代码，仅仅把返回值的true和false分别改成对应节点和NULL即可</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(n)$</li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        {\n            if(a.count(head))\n               return head;\n            a.insert({head,1});\n            head=head-&gt;next;\n        }\n        return NULL;\n    }\n};\n</code></pre>\n<h2 id=\"双指针（快慢指针）\"><a href=\"#双指针（快慢指针）\" class=\"headerlink\" title=\"双指针（快慢指针）\"></a>双指针（快慢指针）</h2><p>为了降低内存我们同样也可以使用快慢指针，将空间复杂度降到$O(1)$，这里涉及到一个证明</p>\n<p><img data-src=\"/../../../post_images/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E8%AF%81%E6%98%8E.jpg\"></p>\n<p>所以我们可以在双指针基础上，在他们相遇时新建两个指针 (或者直接用现成的<code>head</code>和<code>slow/fast</code>指针，不断往后面走，相遇时得到该位置</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(1)$</li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        while(fast&amp;&amp;fast-&gt;next)\n        {\n            slow=slow-&gt;next;\n            fast=fast-&gt;next-&gt;next;\n            if(slow==fast)\n            {\n                ListNode* start=head,*meet=slow;\n                while(start!=meet)\n                {\n                    start=start-&gt;next;\n                    meet=meet-&gt;next;\n                }\n                return meet;\n            }\n        }\n        return NULL;\n        \n    }\n};\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表",
                "双指针（快慢指针）"
            ]
        }
    ]
}