{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"队列\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/3140d327/",
            "url": "http://dpm12345.cn/posts/3140d327/",
            "title": "队列实现",
            "date_published": "2022-01-04T02:07:26.000Z",
            "content_html": "<h1 id=\"队列的实现\"><a href=\"#队列的实现\" class=\"headerlink\" title=\"队列的实现\"></a>队列的实现</h1><p>该实现使用的是C++的函数模板</p>\n<h2 id=\"队列的特点\"><a href=\"#队列的特点\" class=\"headerlink\" title=\"队列的特点\"></a>队列的特点</h2><p>与栈有些许类似，将数据放入队列中时，放入的位置是队尾，但弹出$pop()$ 操作时，是将队头元素删去，并且队列可以通过$[$ $]$来访问数据，故可知实现的函数功能有以下:</p>\n<ul>\n<li><p>void push(T val); // 入队</p>\n</li>\n<li><p>void pop(); // 出队</p>\n</li>\n<li><p>T back(); // 返回队尾元素</p>\n</li>\n<li><p>T front(); // 返回队首元素</p>\n</li>\n<li><p>void operator=(const Queue<t>&amp; q); // 重载 = 运算符</t></p>\n</li>\n<li><p>void print(); // 打印队列</p>\n</li>\n<li><p>bool empty(); // 判断是否为空</p>\n</li>\n<li><p>int size(); // 返回队列大小</p>\n</li>\n</ul>\n<h2 id=\"实现之前的思考\"><a href=\"#实现之前的思考\" class=\"headerlink\" title=\"实现之前的思考\"></a>实现之前的思考</h2><p>由上面的实现功能列表，可以清楚此时队列中的元素增删分别是在尾部和头部来进行的 如果存储数据的是数组，增加数据时还好，可以直接添加，如果是删去元素，那么为了确保队列前面都有人存在(不为循环队列), 必须分别将各个元素慢慢地向前挪，效率较慢。注意到队列的增删操作与链表的尾插和头删相同，而链表的尾插和头删比较简单，因此 此实现采用链表来存储数据</p>\n<h2 id=\"结点构造\"><a href=\"#结点构造\" class=\"headerlink\" title=\"结点构造\"></a>结点构造</h2><p>由于采用的是链表来存储数据，所以直接按照链表格式创建结点即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nstruct node{\n    T data;\n    node&lt;T&gt;* next;\n};\n</code></pre>\n<h2 id=\"Queue-类\"><a href=\"#Queue-类\" class=\"headerlink\" title=\"Queue 类\"></a>Queue 类</h2><h3 id=\"函数成员\"><a href=\"#函数成员\" class=\"headerlink\" title=\"函数成员\"></a>函数成员</h3><p>在队列的实现中，我们要进行头删，尾插，并且可以通过$[$ $]$来访问数据，故需要的数据分别为头结点地址、尾结点地址(方便进行尾插)、链表的元素个数</p>\n<p>而函数成员即为实现功能所列</p>\n<p>所以整体结构为：</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nclass Queue{\nprivate:\n    node&lt;T&gt;* head;         // 头结点\n    node&lt;T&gt;* tail;         // 尾结点\n    int num;\npublic:\n    Queue();                              // 无参构造函数\n    Queue(T val);                         // 有参构造函数\n    ~Queue();                             // 析构函数\n    Queue(const Queue&lt;T&gt;&amp; q);             // 复制构造函数\n    void push(T val);                     // 入队\n    void pop();                           // 出队\n    T back();                             // 返回队尾元素\n    T front();                            // 返回队首元素\n    void operator =(const Queue&lt;T&gt;&amp; q);   // 重载 = 运算符\n    void print();                         // 打印队列\n    bool empty();                         // 判断是否为空\n    int size();                           // 返回队列大小\n\n};\n</code></pre>\n<h3 id=\"成员函数实现\"><a href=\"#成员函数实现\" class=\"headerlink\" title=\"成员函数实现\"></a>成员函数实现</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>在上面，拟定为两种构造函数形式，无参和有参，两种方式做的工作一样，目的是对数据进行初始化。</p>\n<p>如果是无参，$head$和$tail$都应指向空，而$num=0$, 如果是有参，那么新建一个结点后，$head$ 和$tail$ 都指向它，$num=1$</p>\n<p>由于涉及指针，故需要深复制，重写复制构造函数</p>\n<p>以下为实现代码：</p>\n<pre><code class=\"c++\">// 无参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue()\n{\n    head = tail = nullptr;\n    num = 0;\n}\n\n// 有参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    head = tail = newnode;\n    num = 1;\n}\n\n// 复制构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(const Queue&lt;T&gt;&amp; q)\n{\n    node&lt;T&gt;*newp = q.head;\n    while (newp!= nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n\n}\n</code></pre>\n<h4 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h4><p>由于存储数据申请了空间，那么析构函数应当执行释放内存操作</p>\n<p>代码如下：</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nQueue&lt;T&gt;::~Queue()\n{\n    while (head != nullptr)\n    {\n        node&lt;T&gt;* temp = head;\n        head = head-&gt;next;\n        delete temp;\n    }\n    tail = nullptr;\n    num = 0;\n}\n</code></pre>\n<h4 id=\"push-T-val\"><a href=\"#push-T-val\" class=\"headerlink\" title=\"push(T val)\"></a>push(T val)</h4><p>由于$push_back()$即为链表中的尾插，那么只需创建新的结点，存储数值，之后使当前$tail$的$next$指向该结点，最后$tail$指向该结点即可。需要注意的是，如果队列中无元素，那么直接将$head$和$tail$指向该结点即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::push(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    if (head == nullptr)        // 无元素，或者可以写成 tail==nullptr 或 num==0\n    {\n        head = tail = newnode;\n        num = 1;\n    }\n    else\n    {\n        tail-&gt;next = newnode;\n        tail = tail-&gt;next;\n        num++;\n    }\n}\n</code></pre>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop()\"></a>pop()</h4><p>所做的操作为头删</p>\n<p>在删之前，我们必须考虑队列为空的情况，因此可以使用$assert()$进行判断报错</p>\n<p>当队列中有元素时，删去头结点，那么可以先创建一个结点指针指向头结点，在删去头结点后再令<code>head=head-&gt;next</code>，<code>num--</code></p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::pop()\n{\n    assert(head);\n    node&lt;T&gt;*temp = head;\n    head = head-&gt;next;\n    delete temp;     // 删去 head 也可以，只不过上面的 head 赋值需换到下面写成 head=temp-&gt;next;\n    num--;\n}\n</code></pre>\n<h4 id=\"back\"><a href=\"#back\" class=\"headerlink\" title=\"back()\"></a>back()</h4><p>返回队尾元素，直接使用$tail$指针即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nT Queue&lt;T&gt;::back()\n{\n    return tail-&gt;data;\n}\n</code></pre>\n<h4 id=\"front\"><a href=\"#front\" class=\"headerlink\" title=\"front()\"></a>front()</h4><p>返回队首元素，直接使用$head$指针即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nT Queue&lt;T&gt;::front()\n{\n    return head-&gt;data;\n}\n</code></pre>\n<h4 id=\"operator-x3D-const-Queue-amp-q\"><a href=\"#operator-x3D-const-Queue-amp-q\" class=\"headerlink\" title=\"operator=(const Queue&amp;q)\"></a>operator=(const Queue<t>&amp;q)</t></h4><p>与复制构造函数类似，但这里需要判断原Queue对象是否已经有队列元素</p>\n<pre><code class=\"c++\">// 重载 = 运算符\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::operator =(const Queue&lt;T&gt;&amp; q)\n{\n    if (head)             // 如果存在队列\n    {\n        this-&gt;~Queue();\n    }\n    node&lt;T&gt;*newp = q.head;\n    while (newp != nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n}\n</code></pre>\n<h4 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print()\"></a>print()</h4><p>即遍历链表，打印队列</p>\n<p>较为简单，直接上代码:</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::print()\n{\n    node&lt;T&gt;* temp = head;\n    while (temp != nullptr)\n    {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \"  \";\n        temp = temp-&gt;next;\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre>\n<h4 id=\"empty\"><a href=\"#empty\" class=\"headerlink\" title=\"empty()\"></a>empty()</h4><p>判断是否为空，即可判断$n==0?$</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nbool Queue&lt;T&gt;::empty()\n{\n    return num == 0;\n}\n</code></pre>\n<h4 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size()\"></a>size()</h4><p>返回队列大小，即为$num$的值</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nint Queue&lt;T&gt;::size()\n{\n    return num;\n}\n</code></pre>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><pre><code class=\"c++\">//#ifndef  _QUEUE_H\n//#define  _QUEUE_H\n\n#include&lt;assert.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nstruct node{\n    T data;\n    node&lt;T&gt;* next;\n};\n\n\ntemplate&lt;class T&gt;\nclass Queue{\nprivate:\n    node&lt;T&gt;* head;         // 头结点\n    node&lt;T&gt;* tail;         // 尾结点\n    int num;\npublic:\n    Queue();                              // 无参构造函数\n    Queue(T val);                         // 有参构造函数\n    ~Queue();                             // 析构函数\n    Queue(const Queue&lt;T&gt;&amp; q);             // 复制构造函数\n    void push(T val);                     // 入队\n    void pop();                           // 出队\n    T back();                             // 返回队尾元素\n    T front();                            // 返回队首元素\n    void operator =(const Queue&lt;T&gt;&amp; q);   // 重载 = 运算符\n    void print();                         // 打印队列\n    bool empty();                         // 判断是否为空\n    int size();                           // 返回队列大小\n\n};\n\n// 无参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue()\n{\n    head = tail = nullptr;\n    num = 0;\n}\n\n// 有参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    head = tail = newnode;\n    num = 1;\n}\n\n// 析构函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::~Queue()\n{\n    while (head != nullptr)\n    {\n        node&lt;T&gt;* temp = head;\n        head = head-&gt;next;\n        delete temp;\n    }\n    tail = nullptr;\n    num = 0;\n}\n\n// 复制构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(const Queue&lt;T&gt;&amp; q)\n{\n    node&lt;T&gt;*newp = q.head;\n    while (newp!= nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n\n}\n\n// 入队 (尾插)\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::push(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    if (head == nullptr)\n    {\n        head = tail = newnode;\n        num = 1;\n    }\n    else\n    {\n        tail-&gt;next = newnode;\n        tail = tail-&gt;next;\n        num++;\n    }\n}\n\n// 出队 (头删)\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::pop()\n{\n    assert(head);\n    node&lt;T&gt;*temp = head;\n    head = head-&gt;next;\n    delete temp;\n    num--;\n}\n\n// 返回队尾元素\ntemplate&lt;class T&gt;\nT Queue&lt;T&gt;::back()\n{\n    return tail-&gt;data;\n}\n\n// 返回队首元素\ntemplate&lt;class T&gt;\nT Queue&lt;T&gt;::front()\n{\n    return head-&gt;data;\n}\n\n// 重载 = 运算符\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::operator =(const Queue&lt;T&gt;&amp; q)\n{\n    if (head)\n    {\n        this-&gt;~Queue();\n    }\n    node&lt;T&gt;*newp = q.head;\n    while (newp != nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n}\n\n// 打印队列\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::print()\n{\n    node&lt;T&gt;* temp = head;\n    while (temp != nullptr)\n    {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \"  \";\n        temp = temp-&gt;next;\n    }\n    cout &lt;&lt; endl;\n}\n\n// 判断队列是否为空\ntemplate&lt;class T&gt;\nbool Queue&lt;T&gt;::empty()\n{\n    return num == 0;\n}\n\n// 返回队列大小\ntemplate&lt;class T&gt;\nint Queue&lt;T&gt;::size()\n{\n    return num;\n}\n//#endif\n</code></pre>\n",
            "tags": [
                "数据结构",
                "队列"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/5beb97b2/",
            "url": "http://dpm12345.cn/posts/5beb97b2/",
            "title": "无重叠区间",
            "date_published": "2021-12-06T11:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy8=\">无重叠区间</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.png\"></p>\n<p>思路：在这道题中，我们可以把题目要求所解问题换一种说法，找删去最少区间使剩下成为无重叠区间，即包含区间最多数。</p>\n<p>我们注意到，当其为无重叠区间时，前一个区间的末端必然小于等于后一个区间首端，那么我们便可以将这一组的无重叠区间的端点看作为一组不严格单调递增的序列。这样便与求 “最长上升序列” 的序列的问题相同了。</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>我们维护一个数组$dp[i]$，其中$dp[i]$以该位置为末尾区间的，所能得到的数量最多的无重叠区间的值。那么很容易得到，先分别枚举末尾区间位置，再从0开始遍历，寻找最长，转移方程即为： $dp[i]=max(dp[j]+1,dp[i])$（当$intervals[j][1]&lt;intervals[i][0]$时)</p>\n<p>以下为代码:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        sort(intervals.begin(),intervals.end());\n        int n=intervals.size();\n        vector&lt;int&gt;dp(n,1);\n        for(int i=0;i&lt;intervals.size();i++)\n        {\n            for(int j=0;j&lt;i;j++)\n            {\n                if(intervals[j][1]&lt;=intervals[i][0])\n                {\n                    dp[i]=max(dp[j]+1,dp[i]);\n                }\n            }\n        }\n        return n-*max_element(dp.begin(),dp.end());\n\n    }\n};\n</code></pre>\n<p>提交后很不幸，超时了，时间复杂度为$O(n^2)$, 为此我们需要将时间优化。</p>\n<h1 id=\"贪心方案\"><a href=\"#贪心方案\" class=\"headerlink\" title=\"贪心方案\"></a>贪心方案</h1><p>上面的动态规划方案中，枚举末尾，再从0开始遍历，寻找最长，这是无法避免的，为此难以优化，这样，我们可以使用贪心方案，将时间复杂度降低 </p>\n<p>实现思想: 我们要想得到最多数量的无重叠区间，那么我们需要尽可能地将区间长度较小地放入这一无重叠区间内，因此我们可以设想，如果我们将各个区间地右端点按升序排序，设一个变量<code>right</code>为目前无重叠区间的右端点，如果下一个区间的左端大于<code>right</code>，区间加一，<code>right</code>更新，这样以此类推， 最终可以得到答案 </p>\n<p>证明：由于我们是将右端点降序排序，那么当两段区间相同时，实际上无论选择哪段结果都是一样的，因为不管该区间的左端点为多少，后面的区间只要左区间不大于<code>right</code>，那么该区间必会被删。而当之后区间的左端点大于<code>right</code>时，那么此时所选取的区间的右端点必然是满足条件的最小值，也因此能够得到最多数量的无重叠区间 </p>\n<p>以下为实现代码:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        if (intervals.empty()) {\n            return 0;\n        }\n        \n        sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) {\n            return u[1] &lt; v[1];\n        });\n\n        int n = intervals.size();\n        int right = intervals[0][1];\n        int ans = 1;\n        for (int i = 1; i &lt; n; ++i) {\n            if (intervals[i][0] &gt;= right) {\n                ++ans;\n                right = intervals[i][1];\n            }\n        }\n        return n - ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/6f1a75f/",
            "url": "http://dpm12345.cn/posts/6f1a75f/",
            "title": "跳跃游戏 VI",
            "date_published": "2021-12-05T06:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLXZpLw==\">跳跃游戏 VI</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/1696%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI.jpg\"></p>\n<h1 id=\"初期想法\"><a href=\"#初期想法\" class=\"headerlink\" title=\"初期想法\"></a>初期想法</h1><p>看到题目，很容易想到使用动态规划算法，$dp[i]$表示跳到位置$i$能取到的最大的值,其中$dp[i]=min{dp[i-1],dp[i-2]……,dp[i-k]}+nums[i]$, 那么很容易写出代码 如图</p>\n<p><img data-src=\"/../../../post_images/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI_%E5%88%9D%E5%A7%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png\"></p>\n<p>但是已提交便发现，超时了，也就是说纯纯动态规划不能完成题目要求。</p>\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>思考初期想法的代码，哪里造成了代码超时呢？</p>\n<p>不难发现，在确定$i$位置前的$[i-k,i-1]$范围内的最小值时，每一个都比较了一次，而当$i$加一时，除去上次的$i-k$，和新增的$i-1$，其他位置又比较了一次，如果最大值，即比较过后仍然比较，其原因是缺少记录最大值的渠道。那么是否可以在循环时加上一个变量MAX记录$[i-k,i-1]$的最大值，当$i+1$时，将MAX与$dp[i]$比较呢？</p>\n<p>其结果是只能解决一部分，因为假设$MAX=dp[i-k]$，当$i+1$时，MAX的值明显不在之后的$[i-k,i-1]$范围之内了，因此要将原来范围内的次大值与$dp[i]$比较，这样我们又多了个任务，求次大值，所以单纯增加一个变量并不能解决问题。</p>\n<p>下面为解决方案：</p>\n<h1 id=\"优化（单调队列）\"><a href=\"#优化（单调队列）\" class=\"headerlink\" title=\"优化（单调队列）\"></a>优化（单调队列）</h1><p>经过上面的分析，我们需要存储$[i-k,i-1]$内的最大值，同时要在最大值被删去时能快速得到之后的最大值那么，队列无非是我们的选择</p>\n<p>方法：为方便，我们将元素下标存入队列中队列内的元素按降序排序，即队首为最大元素的下标，队列第二个元素即为次大值循环时，首先先确保队首元素满足在下标$[i-k,i-1]$范围内，如不满足则删除队首，然后再进行$dp[i]$的计算$dp[i]=dp[q.front()]+nums[i]$，最后向队列中存入元素$dp[i]$（若$dp[i]&gt;dp[q.back()]$, 便可将队尾元素删除，直到$dp[i]&lt;=dp[q.back]$或队列为空），这样便为后面取最大值做准备。</p>\n<p>因此，代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        vector&lt;int&gt;dp(n);\n        dp[0]=nums[0];\n        deque&lt;int&gt;q;\n        q.push_back(0);\n        for(int i=1;i&lt;n;i++)\n        {\n            while(q.size()&amp;&amp;i-q.front()&gt;k)\n            {\n                q.pop_front();\n            }\n            dp[i]=dp[q.front()]+nums[i];\n            while(q.size()&amp;&amp;dp[i]&gt;dp[q.back()])\n            {\n                q.pop_back();\n            }\n            q.push_back(i);\n        }\n        return dp[n-1];\n    }\n};\n</code></pre>\n<h1 id=\"优化（优先级队列）\"><a href=\"#优化（优先级队列）\" class=\"headerlink\" title=\"优化（优先级队列）\"></a>优化（优先级队列）</h1><p>与单调队列思想相同，只是优先级队列不用进行排序</p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) {\n        int n = nums.size();\n        vector&lt;int&gt; dp(n);\n        dp[0] = nums[0];\n        priority_queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.emplace(nums[0], 0);\n        for (int i = 1; i &lt; n; ++i) {\n            while (i - q.top().second &gt; k) {\n                q.pop();\n            }\n            dp[i] = q.top().first + nums[i];\n            q.emplace(dp[i], i);\n        }\n        return dp[n - 1];\n    }\n};\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        }
    ]
}