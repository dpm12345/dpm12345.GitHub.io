{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"vector\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.github.io",
    "items": [
        {
            "id": "http://dpm12345.github.io/posts/5c639822/",
            "url": "http://dpm12345.github.io/posts/5c639822/",
            "title": "最小栈",
            "date_published": "2022-01-24T14:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluLXN0YWNrLw==\"> 最小栈</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%9C%80%E5%B0%8F%E6%A0%88.png\" alt=\"最小栈详情\" /></p>\n<p>要完成题目所要的功能，首先至少需要一个栈存储压入数据</p>\n<p>而对于该栈的使用方法有所不同</p>\n<h2 id=\"用一个栈存储数据使用-vector-数组存最小值\"><a class=\"anchor\" href=\"#用一个栈存储数据使用-vector-数组存最小值\">#</a> 用一个栈存储数据，使用 vector 数组存最小值</h2>\n<p>在该方法中，入栈时，用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">vector</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 存储最小值，当栈为空即可直接将要压入栈的值作为最小值，放入数组末尾，而如果栈不为空，那么根据压入值与最小值的比较，将较小值放入<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">vector</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 数组末尾，这样做的好处是在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">pop()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span> 操作时，不需判断<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">pop()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span> 的值是否为最小值，可直接<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mi mathvariant=\"normal\">_</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">pop\\_back()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">vector</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 数组末尾值</p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class MinStack &#123;\nprivate:\n    stack&lt;int&gt;a;\n    vector&lt;int&gt;m;\npublic:\n    MinStack() &#123;\n\n    &#125;\n    \n    void push(int val) &#123;\n        if(a.empty())\n        &#123;\n            a.push(val);\n            m.push_back(val);\n        &#125;\n        else\n        &#123;\n            a.push(val);\n            if(val&lt;m.back())\n            &#123;\n                m.push_back(val);\n            &#125;\n            else\n            &#123;\n                m.push_back(m.back());\n            &#125;\n        &#125;\n    &#125;\n    \n    void pop() &#123;\n        a.pop();\n        m.pop_back();\n    &#125;\n    \n    int top() &#123;\n        return a.top();\n      \n    &#125;\n    \n    int getMin() &#123;\n       return m.back();\n    &#125;\n&#125;;\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj-&gt;push(val);\n * obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * int param_4 = obj-&gt;getMin();\n */\n</code></pre>\n<h2 id=\"栈不用于存储数据同时不需要额外空间存储\"><a class=\"anchor\" href=\"#栈不用于存储数据同时不需要额外空间存储\">#</a> 栈不用于存储数据，同时不需要额外空间存储</h2>\n<p>在该方法中，栈中存储的数值为压入栈值与当前最小值的差值</p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class MinStack &#123;\npublic:\n    stack&lt;long long&gt; st;   // 使用 long long 防止数据溢出\n    long long minv;\n\n    MinStack() &#123;\n        minv = -1;\n    &#125;\n\n    void push(int val) &#123;\n        if (!st.size()) &#123;\n            st.push(0);\n            minv = val;\n        &#125;\n        else &#123;// 这次的值减去已有的最小值\n            long long diff = val - minv;\n            st.push(diff);\n            minv = diff &lt; 0 ? val : minv;\n        &#125;\n    &#125;\n\n    void pop() &#123;\n        if (st.size()) &#123;\n            long long diff = st.top();\n            st.pop();\n            if (diff &lt; 0)\n                minv -= diff;\n        &#125;\n    &#125;\n\n    int top() &#123;\n        long long diff = st.top();\n        if (diff &lt; 0)\n            return minv;\n        else \n            return minv + diff;\n    &#125;\n    \n    int getMin() &#123;\n        return minv;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "vector",
                "栈"
            ]
        }
    ]
}