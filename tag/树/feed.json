{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"树\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/e85d694a/",
            "url": "http://dpm12345.cn/posts/e85d694a/",
            "title": "二叉树",
            "date_published": "2022-02-20T12:07:26.000Z",
            "content_html": "<h1 id=\"树的相关定义\"><a href=\"#树的相关定义\" class=\"headerlink\" title=\"树的相关定义\"></a>树的相关定义</h1><p>![](../../../post_images/树.jpeg “树”)</p>\n<ul>\n<li>组成：树由若干个节点构成，根节点在最上方，如图 1 为根节点</li>\n<li>度：节点下方延申的部分称为子树，其个数被称为度，如图 2，3，4，5 为 1 的度，个数为 4叶子节点和分支节点：度为$0$ 的节点被称为</li>\n<li>叶子节点或终端节点，不为$0$ 被称为非终端节点或分支节点，如 13 为叶子节点，3 为分支节点</li>\n<li>父节点：若一个节点含有子节点，那么称为该子节点的父节点，如 6 为 13 的父节点</li>\n<li>兄弟节点：具有相同父节点的节点互称为兄弟节点，如 2，3，4，5</li>\n<li>树的度：一棵树中，最大的节点的度称为树的度</li>\n<li>节点点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；树的高度或深度：树中节点的最大层次，如图为 4</li>\n<li>节点的祖先：从根到该节点所经分支上的所有节点；如上图：1 是所有节点的祖先</li>\n<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是 1 的子孙</li>\n</ul>\n<h1 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h1><p>只有两个子树</p>\n<p>基本组成形式为 节点 + 左子树 + 右子树 </p>\n<p>如图:</p>\n<p><img data-src=\"/../../../post_images/%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg\" title=\"二叉树\"></p>\n<h1 id=\"特殊的二叉树\"><a href=\"#特殊的二叉树\" class=\"headerlink\" title=\"特殊的二叉树\"></a>特殊的二叉树</h1><p>**满二叉树:**一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为$K$，且结点总数是$2^k-1$，则它就是满二叉树。</p>\n<p>**完全二叉树:**完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为$K$的，有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$K$的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。要注意的是满二叉树是一种特殊的完全二叉树。</p>\n<p>![](../../../post_images/满二叉树.png “满二叉树”)</p>\n<h1 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h1><ul>\n<li>若规定根节点的层数为$1$，则一棵非空二叉树的第$i$层上最多有$2^{i-1}$个结点.</li>\n<li>若规定根节点的层数为$1$，则深度为h的二叉树的最大结点数是$2^h-1$.</li>\n<li>对任何一棵二叉树，如果度为$0$其叶结点个数为$n_0$, 度为2的分支结点个数为$n_2$, 则有$n_0＝n_2+1$</li>\n<li>若规定根节点的层数为$1$，具有$n$个结点的满二叉树的深度，$h=LogN$</li>\n</ul>\n<h1 id=\"二叉树的实现形式\"><a href=\"#二叉树的实现形式\" class=\"headerlink\" title=\"二叉树的实现形式\"></a>二叉树的实现形式</h1><h2 id=\"顺序形式\"><a href=\"#顺序形式\" class=\"headerlink\" title=\"顺序形式\"></a>顺序形式</h2><p>采用数组的方式，一个存放一个节点，可能会存在空，大小需要变化</p>\n<p>采用该种方式构建的完全二叉树</p>\n<p>性质</p>\n<ul>\n<li>左子树根节点 $leftchild=parent*2+1$</li>\n<li>右子树根节点 $leftchild=parent*2+1$</li>\n<li>根节点 $parent=(child-1)/2$</li>\n</ul>\n<h2 id=\"链式形式\"><a href=\"#链式形式\" class=\"headerlink\" title=\"链式形式\"></a>链式形式</h2><p>可以定义出每一个节点，用地址进行链接</p>\n<h3 id=\"二叉树的链式实现及相关遍历\"><a href=\"#二叉树的链式实现及相关遍历\" class=\"headerlink\" title=\"二叉树的链式实现及相关遍历\"></a>二叉树的链式实现及相关遍历</h3><h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>代码如下</p>\n<pre><code class=\"c++\">//tree.h\n#ifndef TREE_H\n#define TREE_H\n\n// 每个结点的定义\ntemplate&lt;class T&gt;\nclass RNode{\npublic:\n    T data;\n    class RNode&lt;T&gt; * lNode;\n    class RNode&lt;T&gt; * rNode;\n};\n\n#endif\n\n//tree.c\nvoid test1()\n{\n    //A\n    RNode&lt;int&gt;* A = new RNode&lt;int&gt;;\n    A-&gt;data = 5;\n    A-&gt;lNode = nullptr;\n    A-&gt;rNode = nullptr;\n    //B\n    RNode&lt;int&gt;* B = new RNode&lt;int&gt;;\n    B-&gt;data = 3;\n    B-&gt;lNode = nullptr;\n    B-&gt;rNode = nullptr;\n    //C\n    RNode&lt;int&gt;* C = new RNode&lt;int&gt;;\n    C-&gt;data = 4;\n    C-&gt;lNode = nullptr;\n    C-&gt;rNode = nullptr;\n    //D\n    RNode&lt;int&gt;* D = new RNode&lt;int&gt;;\n    D-&gt;data = 7;\n    D-&gt;lNode = nullptr;\n    D-&gt;rNode = nullptr;\n    //E\n    RNode&lt;int&gt;* E = new RNode&lt;int&gt;;\n    E-&gt;data = 12;\n    E-&gt;lNode = nullptr;\n    E-&gt;rNode = nullptr;\n\n    // 建立联系\n    A-&gt;lNode = B;\n    A-&gt;rNode = C;\n    B-&gt;lNode = D;\n    C-&gt;rNode = E;\n}\n</code></pre>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><h5 id=\"前序\"><a href=\"#前序\" class=\"headerlink\" title=\"前序\"></a>前序</h5><p>根 –&gt; 左子树 –&gt; 右子树</p>\n<p>leetcode相关链接: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==\">二叉树的前序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"c++\">void PrevOrder(RNode&lt;int&gt;* P)\n{\n    if (P == nullptr)\n    {\n        cout &lt;&lt; \"NULL \";\n        return;\n    }\n    cout &lt;&lt; P-&gt;data &lt;&lt; \" \";\n    PrevOrder(P-&gt;lNode);\n    PrevOrder(P-&gt;rNode);\n}\n</code></pre>\n<p>附上 leetcode 上的迭代写法</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;ans;\n        if(root==nullptr)\n            return ans;\n        \n        stack&lt;TreeNode*&gt;record;\n        TreeNode* node=root;\n        while(!record.empty()||node!=nullptr)\n        {\n            while(node!=nullptr)\n            {\n                ans.push_back(node-&gt;val);\n                record.push(node);\n                node=node-&gt;left;\n            }\n            node=record.top();\n            record.pop();\n            node=node-&gt;right;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h5 id=\"中序\"><a href=\"#中序\" class=\"headerlink\" title=\"中序\"></a>中序</h5><p>左子树 –&gt; 根 –&gt; 右子树</p>\n<p>leetcode相关链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv\">二叉树的中序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"c++\">void MidOrder(RNode&lt;int&gt;* P)\n{\n    if (P == nullptr)\n    {\n        cout &lt;&lt; \"NULL \";\n        return;\n    }\n    MidOrder(P-&gt;lNode);\n    cout &lt;&lt; P-&gt;data &lt;&lt; \" \";\n    MidOrder(P-&gt;rNode);\n}\n</code></pre>\n<p>附上leetcode上的迭代写法</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;ans;\n        if(root==nullptr)\n            return ans;\n        stack&lt;TreeNode*&gt;re;\n        TreeNode* node=root;\n        while(!re.empty()||node!=nullptr)\n        {\n            while(node!=nullptr)\n            {\n                re.push(node);\n                node=node-&gt;left;\n            }\n            node=re.top();\n            ans.push_back(node-&gt;val);\n            re.pop();\n            node=node-&gt;right;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h5 id=\"后序\"><a href=\"#后序\" class=\"headerlink\" title=\"后序\"></a>后序</h5><p>左子树 –&gt;右子树 –&gt;根</p>\n<p>leetcode 相关链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==\">二叉树的后序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"c++\">void LastOrder(RNode&lt;int&gt;* P)\n{\n    if (P == nullptr)\n    {\n        cout &lt;&lt; \"NULL \";\n        return;\n    }\n    LastOrder(P-&gt;lNode);\n    LastOrder(P-&gt;rNode);\n    cout &lt;&lt; P-&gt;data &lt;&lt; \" \";\n}\n</code></pre>\n<p>附上leetcode上的迭代写法</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode *root) {\n        vector&lt;int&gt; res;\n        if (root == nullptr) {\n            return res;\n        }\n\n        stack&lt;TreeNode *&gt; stk;\n        TreeNode *prev = nullptr;\n        while (root != nullptr || !stk.empty()) {\n            while (root != nullptr) {\n                stk.emplace(root);\n                root = root-&gt;left;\n            }\n            root = stk.top();\n            stk.pop();\n            if (root-&gt;right == nullptr || root-&gt;right == prev) {\n                res.emplace_back(root-&gt;val);\n                prev = root;\n                root = nullptr;\n            } else {\n                stk.emplace(root);\n                root = root-&gt;right;\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<p>相关解释</p>\n<p>为了实现这一顺序，该方法中</p>\n<ol>\n<li><p>由于左子树始终首先输出，那么依旧存入所有的左子树结点</p>\n</li>\n<li><p>为了防止根先于右子树输出，在该方法中，使用了<code>prev</code>这一变量，代表的是前一个右子树，只有当右子树为空或者右子树之前输出过了才可以输入<code>root</code>的内容，而为了先输出右子树的内容，会将右子树的根节点存入栈中，并指向该节点的右子树</p>\n</li>\n<li><p>然后再判断上面的指向是否为存在子树(即进入while循环判断，如果有，那么继续深入)</p>\n</li>\n<li><p>之后按照正常输出即可</p>\n</li>\n</ol>\n<h1 id=\"其他相关题目\"><a href=\"#其他相关题目\" class=\"headerlink\" title=\"其他相关题目\"></a>其他相关题目</h1><ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=\">二叉树的最大深度</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv\">平衡二叉树</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==\">二叉树的层序遍历</span></li>\n</ol>\n",
            "tags": [
                "树",
                "二叉树",
                "数据结构"
            ]
        }
    ]
}