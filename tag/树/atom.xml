<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://dpm12345.cn</id>
    <title>dpm12345 • Posts by &#34;树&#34; tag</title>
    <link href="http://dpm12345.cn" />
    <updated>2022-02-20T12:07:26.000Z</updated>
    <category term="Qt" />
    <category term="ms17" />
    <category term="msf" />
    <category term="git" />
    <category term="CTF" />
    <category term="sql注入" />
    <category term="笔记" />
    <category term="SSRF" />
    <category term="kali" />
    <category term="nmap" />
    <category term="Misc" />
    <category term="MFC" />
    <category term="cryptography" />
    <category term="ctfshow" />
    <category term="Web" />
    <category term="树" />
    <category term="二叉树" />
    <category term="数据结构" />
    <category term="hexo" />
    <category term="队列" />
    <category term="前缀和" />
    <category term="动态规划" />
    <category term="滑动窗口" />
    <category term="数组" />
    <category term="哈希表" />
    <category term="链表" />
    <category term="矩阵" />
    <category term="递归" />
    <category term="贪心" />
    <category term="子序列" />
    <category term="最长公共子序列" />
    <category term="最长回文子序列" />
    <category term="字符串" />
    <category term="括号" />
    <category term="vector" />
    <category term="栈" />
    <category term="双指针（快慢指针）" />
    <category term="排列组合" />
    <category term="等差数列" />
    <category term="深度优先搜索" />
    <category term="广度优先搜索" />
    <category term="ciscn" />
    <category term="SSTI" />
    <category term="arm-linux" />
    <category term="Tiny6410" />
    <category term="信息安全" />
    <category term="linux" />
    <category term="web" />
    <category term="javascript" />
    <category term="XXE" />
    <entry>
        <id>http://dpm12345.cn/posts/e85d694a/</id>
        <title>二叉树</title>
        <link rel="alternate" href="http://dpm12345.cn/posts/e85d694a/"/>
        <content type="html">&lt;h1 id=&#34;树的相关定义&#34;&gt;&lt;a href=&#34;#树的相关定义&#34; class=&#34;headerlink&#34; title=&#34;树的相关定义&#34;&gt;&lt;/a&gt;树的相关定义&lt;/h1&gt;&lt;p&gt;![](../../../post_images/树.jpeg “树”)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组成：树由若干个节点构成，根节点在最上方，如图 1 为根节点&lt;/li&gt;
&lt;li&gt;度：节点下方延申的部分称为子树，其个数被称为度，如图 2，3，4，5 为 1 的度，个数为 4叶子节点和分支节点：度为$0$ 的节点被称为&lt;/li&gt;
&lt;li&gt;叶子节点或终端节点，不为$0$ 被称为非终端节点或分支节点，如 13 为叶子节点，3 为分支节点&lt;/li&gt;
&lt;li&gt;父节点：若一个节点含有子节点，那么称为该子节点的父节点，如 6 为 13 的父节点&lt;/li&gt;
&lt;li&gt;兄弟节点：具有相同父节点的节点互称为兄弟节点，如 2，3，4，5&lt;/li&gt;
&lt;li&gt;树的度：一棵树中，最大的节点的度称为树的度&lt;/li&gt;
&lt;li&gt;节点点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；树的高度或深度：树中节点的最大层次，如图为 4&lt;/li&gt;
&lt;li&gt;节点的祖先：从根到该节点所经分支上的所有节点；如上图：1 是所有节点的祖先&lt;/li&gt;
&lt;li&gt;子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是 1 的子孙&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二叉树的定义&#34;&gt;&lt;a href=&#34;#二叉树的定义&#34; class=&#34;headerlink&#34; title=&#34;二叉树的定义&#34;&gt;&lt;/a&gt;二叉树的定义&lt;/h1&gt;&lt;p&gt;只有两个子树&lt;/p&gt;
&lt;p&gt;基本组成形式为 节点 + 左子树 + 右子树 &lt;/p&gt;
&lt;p&gt;如图:&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/../../../post_images/%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg&#34; title=&#34;二叉树&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;特殊的二叉树&#34;&gt;&lt;a href=&#34;#特殊的二叉树&#34; class=&#34;headerlink&#34; title=&#34;特殊的二叉树&#34;&gt;&lt;/a&gt;特殊的二叉树&lt;/h1&gt;&lt;p&gt;**满二叉树:**一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为$K$，且结点总数是$2^k-1$，则它就是满二叉树。&lt;/p&gt;
&lt;p&gt;**完全二叉树:**完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为$K$的，有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$K$的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。要注意的是满二叉树是一种特殊的完全二叉树。&lt;/p&gt;
&lt;p&gt;![](../../../post_images/满二叉树.png “满二叉树”)&lt;/p&gt;
&lt;h1 id=&#34;二叉树的性质&#34;&gt;&lt;a href=&#34;#二叉树的性质&#34; class=&#34;headerlink&#34; title=&#34;二叉树的性质&#34;&gt;&lt;/a&gt;二叉树的性质&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;若规定根节点的层数为$1$，则一棵非空二叉树的第$i$层上最多有$2^{i-1}$个结点.&lt;/li&gt;
&lt;li&gt;若规定根节点的层数为$1$，则深度为h的二叉树的最大结点数是$2^h-1$.&lt;/li&gt;
&lt;li&gt;对任何一棵二叉树，如果度为$0$其叶结点个数为$n_0$, 度为2的分支结点个数为$n_2$, 则有$n_0＝n_2+1$&lt;/li&gt;
&lt;li&gt;若规定根节点的层数为$1$，具有$n$个结点的满二叉树的深度，$h=LogN$&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二叉树的实现形式&#34;&gt;&lt;a href=&#34;#二叉树的实现形式&#34; class=&#34;headerlink&#34; title=&#34;二叉树的实现形式&#34;&gt;&lt;/a&gt;二叉树的实现形式&lt;/h1&gt;&lt;h2 id=&#34;顺序形式&#34;&gt;&lt;a href=&#34;#顺序形式&#34; class=&#34;headerlink&#34; title=&#34;顺序形式&#34;&gt;&lt;/a&gt;顺序形式&lt;/h2&gt;&lt;p&gt;采用数组的方式，一个存放一个节点，可能会存在空，大小需要变化&lt;/p&gt;
&lt;p&gt;采用该种方式构建的完全二叉树&lt;/p&gt;
&lt;p&gt;性质&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左子树根节点 $leftchild=parent*2+1$&lt;/li&gt;
&lt;li&gt;右子树根节点 $leftchild=parent*2+1$&lt;/li&gt;
&lt;li&gt;根节点 $parent=(child-1)/2$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;链式形式&#34;&gt;&lt;a href=&#34;#链式形式&#34; class=&#34;headerlink&#34; title=&#34;链式形式&#34;&gt;&lt;/a&gt;链式形式&lt;/h2&gt;&lt;p&gt;可以定义出每一个节点，用地址进行链接&lt;/p&gt;
&lt;h3 id=&#34;二叉树的链式实现及相关遍历&#34;&gt;&lt;a href=&#34;#二叉树的链式实现及相关遍历&#34; class=&#34;headerlink&#34; title=&#34;二叉树的链式实现及相关遍历&#34;&gt;&lt;/a&gt;二叉树的链式实现及相关遍历&lt;/h3&gt;&lt;h4 id=&#34;实现&#34;&gt;&lt;a href=&#34;#实现&#34; class=&#34;headerlink&#34; title=&#34;实现&#34;&gt;&lt;/a&gt;实现&lt;/h4&gt;&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;//tree.h
#ifndef TREE_H
#define TREE_H

// 每个结点的定义
template&amp;lt;class T&amp;gt;
class RNode{
public:
    T data;
    class RNode&amp;lt;T&amp;gt; * lNode;
    class RNode&amp;lt;T&amp;gt; * rNode;
};

#endif

//tree.c
void test1()
{
    //A
    RNode&amp;lt;int&amp;gt;* A = new RNode&amp;lt;int&amp;gt;;
    A-&amp;gt;data = 5;
    A-&amp;gt;lNode = nullptr;
    A-&amp;gt;rNode = nullptr;
    //B
    RNode&amp;lt;int&amp;gt;* B = new RNode&amp;lt;int&amp;gt;;
    B-&amp;gt;data = 3;
    B-&amp;gt;lNode = nullptr;
    B-&amp;gt;rNode = nullptr;
    //C
    RNode&amp;lt;int&amp;gt;* C = new RNode&amp;lt;int&amp;gt;;
    C-&amp;gt;data = 4;
    C-&amp;gt;lNode = nullptr;
    C-&amp;gt;rNode = nullptr;
    //D
    RNode&amp;lt;int&amp;gt;* D = new RNode&amp;lt;int&amp;gt;;
    D-&amp;gt;data = 7;
    D-&amp;gt;lNode = nullptr;
    D-&amp;gt;rNode = nullptr;
    //E
    RNode&amp;lt;int&amp;gt;* E = new RNode&amp;lt;int&amp;gt;;
    E-&amp;gt;data = 12;
    E-&amp;gt;lNode = nullptr;
    E-&amp;gt;rNode = nullptr;

    // 建立联系
    A-&amp;gt;lNode = B;
    A-&amp;gt;rNode = C;
    B-&amp;gt;lNode = D;
    C-&amp;gt;rNode = E;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;遍历&#34;&gt;&lt;a href=&#34;#遍历&#34; class=&#34;headerlink&#34; title=&#34;遍历&#34;&gt;&lt;/a&gt;遍历&lt;/h4&gt;&lt;h5 id=&#34;前序&#34;&gt;&lt;a href=&#34;#前序&#34; class=&#34;headerlink&#34; title=&#34;前序&#34;&gt;&lt;/a&gt;前序&lt;/h5&gt;&lt;p&gt;根 –&amp;gt; 左子树 –&amp;gt; 右子树&lt;/p&gt;
&lt;p&gt;leetcode相关链接: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==&#34;&gt;二叉树的前序遍历&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void PrevOrder(RNode&amp;lt;int&amp;gt;* P)
{
    if (P == nullptr)
    {
        cout &amp;lt;&amp;lt; &#34;NULL &#34;;
        return;
    }
    cout &amp;lt;&amp;lt; P-&amp;gt;data &amp;lt;&amp;lt; &#34; &#34;;
    PrevOrder(P-&amp;gt;lNode);
    PrevOrder(P-&amp;gt;rNode);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附上 leetcode 上的迭代写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) {
        vector&amp;lt;int&amp;gt;ans;
        if(root==nullptr)
            return ans;
        
        stack&amp;lt;TreeNode*&amp;gt;record;
        TreeNode* node=root;
        while(!record.empty()||node!=nullptr)
        {
            while(node!=nullptr)
            {
                ans.push_back(node-&amp;gt;val);
                record.push(node);
                node=node-&amp;gt;left;
            }
            node=record.top();
            record.pop();
            node=node-&amp;gt;right;
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;中序&#34;&gt;&lt;a href=&#34;#中序&#34; class=&#34;headerlink&#34; title=&#34;中序&#34;&gt;&lt;/a&gt;中序&lt;/h5&gt;&lt;p&gt;左子树 –&amp;gt; 根 –&amp;gt; 右子树&lt;/p&gt;
&lt;p&gt;leetcode相关链接:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv&#34;&gt;二叉树的中序遍历&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void MidOrder(RNode&amp;lt;int&amp;gt;* P)
{
    if (P == nullptr)
    {
        cout &amp;lt;&amp;lt; &#34;NULL &#34;;
        return;
    }
    MidOrder(P-&amp;gt;lNode);
    cout &amp;lt;&amp;lt; P-&amp;gt;data &amp;lt;&amp;lt; &#34; &#34;;
    MidOrder(P-&amp;gt;rNode);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附上leetcode上的迭代写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) {
        vector&amp;lt;int&amp;gt;ans;
        if(root==nullptr)
            return ans;
        stack&amp;lt;TreeNode*&amp;gt;re;
        TreeNode* node=root;
        while(!re.empty()||node!=nullptr)
        {
            while(node!=nullptr)
            {
                re.push(node);
                node=node-&amp;gt;left;
            }
            node=re.top();
            ans.push_back(node-&amp;gt;val);
            re.pop();
            node=node-&amp;gt;right;
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;后序&#34;&gt;&lt;a href=&#34;#后序&#34; class=&#34;headerlink&#34; title=&#34;后序&#34;&gt;&lt;/a&gt;后序&lt;/h5&gt;&lt;p&gt;左子树 –&amp;gt;右子树 –&amp;gt;根&lt;/p&gt;
&lt;p&gt;leetcode 相关链接:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==&#34;&gt;二叉树的后序遍历&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;void LastOrder(RNode&amp;lt;int&amp;gt;* P)
{
    if (P == nullptr)
    {
        cout &amp;lt;&amp;lt; &#34;NULL &#34;;
        return;
    }
    LastOrder(P-&amp;gt;lNode);
    LastOrder(P-&amp;gt;rNode);
    cout &amp;lt;&amp;lt; P-&amp;gt;data &amp;lt;&amp;lt; &#34; &#34;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附上leetcode上的迭代写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;c++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode *root) {
        vector&amp;lt;int&amp;gt; res;
        if (root == nullptr) {
            return res;
        }

        stack&amp;lt;TreeNode *&amp;gt; stk;
        TreeNode *prev = nullptr;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.emplace(root);
                root = root-&amp;gt;left;
            }
            root = stk.top();
            stk.pop();
            if (root-&amp;gt;right == nullptr || root-&amp;gt;right == prev) {
                res.emplace_back(root-&amp;gt;val);
                prev = root;
                root = nullptr;
            } else {
                stk.emplace(root);
                root = root-&amp;gt;right;
            }
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相关解释&lt;/p&gt;
&lt;p&gt;为了实现这一顺序，该方法中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;由于左子树始终首先输出，那么依旧存入所有的左子树结点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为了防止根先于右子树输出，在该方法中，使用了&lt;code&gt;prev&lt;/code&gt;这一变量，代表的是前一个右子树，只有当右子树为空或者右子树之前输出过了才可以输入&lt;code&gt;root&lt;/code&gt;的内容，而为了先输出右子树的内容，会将右子树的根节点存入栈中，并指向该节点的右子树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后再判断上面的指向是否为存在子树(即进入while循环判断，如果有，那么继续深入)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;之后按照正常输出即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;其他相关题目&#34;&gt;&lt;a href=&#34;#其他相关题目&#34; class=&#34;headerlink&#34; title=&#34;其他相关题目&#34;&gt;&lt;/a&gt;其他相关题目&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=&#34;&gt;二叉树的最大深度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv&#34;&gt;平衡二叉树&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==&#34;&gt;二叉树的层序遍历&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="树" />
        <category term="二叉树" />
        <category term="数据结构" />
        <updated>2022-02-20T12:07:26.000Z</updated>
    </entry>
</feed>
