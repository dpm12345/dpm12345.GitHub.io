{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"广度优先搜索\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.github.io",
    "items": [
        {
            "id": "http://dpm12345.github.io/2021/12/07/leetcode/regular-exercise/%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/",
            "url": "http://dpm12345.github.io/2021/12/07/leetcode/regular-exercise/%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/",
            "title": "边界着色 岛屿数量",
            "date_published": "2021-12-07T07:54:40.000Z",
            "content_html": "<h1 id=\"边界着色\"><a class=\"anchor\" href=\"#边界着色\">#</a> 边界着色</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29sb3JpbmctYS1ib3JkZXIv\">边界着色</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2.jpg\" alt=\"\" /></p>\n<p>思路：与 200. 岛屿数量题相类似，可以使用深度优先搜索或广度优先搜索进行解题。先找出满足连通分量的位置，再判断是否为边界</p>\n<h2 id=\"深度优先搜索\"><a class=\"anchor\" href=\"#深度优先搜索\">#</a> 深度优先搜索</h2>\n<p><strong>以下为代码</strong></p>\n<pre><code class=\"language-c++\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n        vector&lt;pair&lt;int, int&gt;&gt; borders;\n        int originalColor = grid[row][col];\n        visited[row][col] = true;\n        dfs(grid, row, col, visited, borders, originalColor);\n        for (auto &amp; [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, vector&lt;vector&lt;bool&gt;&gt; &amp; visited, vector&lt;pii&gt; &amp; borders, int originalColor) {\n        int m = grid.size(), n = grid[0].size();\n        bool isBorder = false;\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int i = 0; i &lt; 4; i++) {\n            int nx = direc[i][0] + x, ny = direc[i][1] + y;\n            if (!(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == originalColor)) {\n                isBorder = true;\n            } else if (!visited[nx][ny]) {\n                visited[nx][ny] = true;\n                dfs(grid, nx, ny, visited, borders, originalColor);\n            }                \n        }\n        if (isBorder) {\n            borders.emplace_back(x, y);\n        }\n    }\n};\n</code></pre>\n<h2 id=\"广度优先搜索\"><a class=\"anchor\" href=\"#广度优先搜索\">#</a> 广度优先搜索</h2>\n<pre><code class=\"language-c++\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n        vector&lt;pair&lt;int, int&gt;&gt; borders;\n        int originalColor = grid[row][col];\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.emplace(row, col);\n        visited[row][col] = true;\n        while (!q.empty()) {\n            pair&lt;int, int&gt; &amp; node = q.front();\n            q.pop();\n            int x = node.first, y = node.second;\n\n            bool isBorder = false;\n            for (int i = 0; i &lt; 4; i++) {\n                int nx = direc[i][0] + x, ny = direc[i][1] + y;\n                if (!(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == originalColor)) {\n                    isBorder = true;\n                } else if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.emplace(nx, ny);\n                }         \n            }\n            if (isBorder) {\n                borders.emplace_back(x, y);\n            }\n        }\n        for (auto &amp; [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n};\n</code></pre>\n<h1 id=\"岛屿数量\"><a class=\"anchor\" href=\"#岛屿数量\">#</a> 岛屿数量</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLWlzbGFuZHMv\">岛屿数量</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.png\" alt=\"\" /></p>\n<h2 id=\"深度优先搜索-2\"><a class=\"anchor\" href=\"#深度优先搜索-2\">#</a> 深度优先搜索</h2>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int r,int c)\n        &#123;\n            int m=grid.size(),n=grid[0].size();\n            grid[r][c]='0';\n            if(r-1&gt;=0&amp;&amp;grid[r-1][c]=='1')  dfs(grid,r-1,c);\n            if(r+1&lt;m&amp;&amp;grid[r+1][c]=='1')  dfs(grid,r+1,c);\n            if(c-1&gt;=0&amp;&amp;grid[r][c-1]=='1')  dfs(grid,r,c-1);\n            if(c+1&lt;n&amp;&amp;grid[r][c+1]=='1')  dfs(grid,r,c+1);\n        &#125;\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        int m=grid.size(),n=grid[0].size();\n        if(m==0)return 0;\n        int ans=0;\n        for(int i=0;i&lt;m;i++)\n        &#123;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                if(grid[i][j]=='1')\n                &#123;\n                    ans++;\n                    dfs(grid,i,j);\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"广度优先搜索-2\"><a class=\"anchor\" href=\"#广度优先搜索-2\">#</a> 广度优先搜索</h2>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        int m=grid.size(),n=grid[0].size();\n        if(m==0)  \n            return 0;\n        int ans=0;\n        for(int i=0;i&lt;m;i++)\n        &#123;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                if(grid[i][j]=='1')\n                &#123;\n                    ans++;\n                    grid[i][j]='0';\n                    queue&lt;pair&lt;int,int&gt;&gt;s;\n                    s.push(&#123;i,j&#125;);\n                    while(!s.empty())\n                    &#123;\n                        auto [r,c]=s.front();\n                        s.pop();\n                        if(r-1&gt;=0&amp;&amp;grid[r-1][c]=='1')\n                        &#123;\n                            grid[r-1][c]='0';\n                            s.push(&#123;r-1,c&#125;);\n                        &#125;\n                        if(r+1&lt;m&amp;&amp;grid[r+1][c]=='1')\n                        &#123;\n                            grid[r+1][c]='0';\n                            s.push(&#123;r+1,c&#125;);\n                        &#125;\n                        if(c-1&gt;=0&amp;&amp;grid[r][c-1]=='1')\n                        &#123;    \n                            grid[r][c-1]='0';\n                            s.push(&#123;r,c-1&#125;);\n                        &#125;\n                        if(c+1&lt;n&amp;&amp;grid[r][c+1]=='1')\n                        &#123;\n                            grid[r][c+1]='0';\n                            s.push(&#123;r,c+1&#125;);\n                        &#125;\n\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "深度优先搜索",
                "广度优先搜索"
            ]
        }
    ]
}