{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"javascript\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/6882c75c/",
            "url": "http://dpm12345.cn/posts/6882c75c/",
            "title": "JavaScript 原型链污染(Prototype).md",
            "date_published": "2023-08-15T12:15:40.000Z",
            "content_html": "<p>JavaScript是一门非常灵活的语言，我感觉在某些方面可能比PHP更加灵活。所以，除了传统的SQL注入、代码执行等注入型漏洞外，也会有一些独有的安全问题，比如prototype污染。</p>\n<h1 id=\"prototype和-proto\"><a href=\"#prototype和-proto\" class=\"headerlink\" title=\"prototype和__proto__\"></a><code>prototype</code>和<code>__proto__</code></h1><p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p>\n<pre><code class=\"javascript\">function Foo() {\n    this.state = 1\n}\n\nnew Foo()\n</code></pre>\n<p><code>Foo</code>函数的内容，就是<code>Foo</code>类的构造函数，而<code>this.state</code>就是<code>Foo</code>类的一个属性。</p>\n<p>为了简化编写JavaScript代码，ECMAScript 6后增加了<code>class</code>语法，但<code>class</code>其实只是一个语法糖。</p>\n<p>一个类必然有一些方法，类似属性<code>this.state</code>，我们也可以将方法定义在构造函数内部：</p>\n<pre><code class=\"javascript\">function Foo() {\n    this.state = 1\n    this.show = function() {\n        console.log(this.state)\n    }\n}\n\n(new Foo()).show()\n</code></pre>\n<p>但这样写有一个问题，就是每当我们新建一个Foo对象时，<code>this.show = function...</code>就会执行一次，这个<code>show</code>方法实际上是绑定在对象上的，而不是绑定在“类”中。</p>\n<p>我希望在创建类的时候只创建一次<code>show</code>方法，这时候就则需要使用原型（prototype）了：</p>\n<pre><code class=\"javascript\">function Foo() {\n    this.state = 1\n}\n\nFoo.prototype.show = function show() {\n    console.log(this.state)\n}\n\nlet foo = new Foo()\nfoo.show()\n</code></pre>\n<p>我们可以认为原型<code>prototype</code>是类<code>Foo</code>的一个属性，而所有用<code>Foo</code>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法。</p>\n<p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但<code>Foo</code>实例化出来的对象，是不能通过prototype访问原型的(即，若<code>foo</code>是<code>Foo</code>类实例化的一个对象，那么<code>foo.prototype</code>是无法使用的。这时候，就该<code>__proto__</code>登场了。</p>\n<p>一个Foo类实例化出来的foo对象，可以通过<code>foo.__proto__</code>属性来访问Foo类的原型，也就是说：</p>\n<pre><code class=\"javascript\">foo.__proto__ == Foo.prototype\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li>\n<li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li>\n</ol>\n<h1 id=\"JavaScript原型链继承\"><a href=\"#JavaScript原型链继承\" class=\"headerlink\" title=\"JavaScript原型链继承\"></a>JavaScript原型链继承</h1><p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p>\n<p>如：</p>\n<pre><code class=\"javascript\">function Father() {\n    this.first_name = 'Donald'\n    this.last_name = 'Trump'\n}\n\nfunction Son() {\n    this.first_name = 'Melania'\n}\n\nSon.prototype = new Father()\n\nlet son = new Son()\nconsole.log(`Name: ${son.first_name} ${son.last_name}`)\n</code></pre>\n<p>Son类继承了Father类的<code>last_name</code>属性，最后输出的是<code>Name: Melania Trump</code>。</p>\n<p>总结一下，对于对象son，在调用<code>son.last_name</code>的时候，实际上JavaScript引擎会进行如下操作：</p>\n<ol>\n<li>在对象son中寻找last_name</li>\n<li>如果找不到，则在<code>son.__proto__</code>中寻找last_name</li>\n<li>如果仍然找不到，则继续在<code>son.__proto__.__proto__</code>中寻找last_name</li>\n<li>依次寻找，直到找到<code>null</code>结束。比如，<code>Object.prototype</code>的<code>__proto__</code>就是<code>null</code></li>\n</ol>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_1.png\" alt=\"image-20230815221255583\"></p>\n<p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。</p>\n<p>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p>\n<ol>\n<li>每个构造函数(constructor)都有一个原型对象(prototype)</li>\n<li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li>\n<li>JavaScript使用prototype链实现继承机制</li>\n</ol>\n<h1 id=\"原型链污染\"><a href=\"#原型链污染\" class=\"headerlink\" title=\"原型链污染\"></a>原型链污染</h1><p>简单来说，根据前面的介绍，即对象与类之间的关系，比如一个<code>Foo</code>类的实例对象<code>foo</code>，<code>foo.__proto__ == Foo.prototype</code>,如果对<code>foo.__proto__</code>进行修改而在之后，<code>Foo</code>类的实例化对象的属性由于继承关系将会随之改变</p>\n<p>如下面的代码</p>\n<pre><code class=\"javascript\">// foo是一个简单的JavaScript对象\nlet foo = {bar: 1}\n\n// foo.bar 此时为1\nconsole.log(foo.bar)\n\n// 修改foo的原型（即Object）\nfoo.__proto__.bar = 2\n\n// 由于查找顺序的原因，foo.bar仍然是1\nconsole.log(foo.bar)\n\n// 此时再用Object创建一个空的zoo对象\nlet zoo = {}\n\n// 查看zoo.bar\nconsole.log(zoo.bar)\n</code></pre>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_2.png\" alt=\"image-20230815221822410\"></p>\n<p>可以看到输出了<code>1 1 2</code>，证明原型链被污染，成功修改了原来的类</p>\n<p>原理：因为前面我们修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。</p>\n<p>后来，我们又用Object类创建了一个zoo对象<code>let zoo = {}</code>，zoo对象自然也有一个bar属性了。</p>\n<p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p>\n<h1 id=\"原型链污染可能发生的场景\"><a href=\"#原型链污染可能发生的场景\" class=\"headerlink\" title=\"原型链污染可能发生的场景\"></a>原型链污染可能发生的场景</h1><ul>\n<li>对象merge</li>\n<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li>\n</ul>\n<p>以对象merge为例，我们想象一个简单的merge函数：</p>\n<pre><code class=\"javascript\">function merge(target, source) {\n    for (let key in source) {\n        if (key in source &amp;&amp; key in target) {\n            merge(target[key], source[key])\n        } else {\n            target[key] = source[key]\n        }\n    }\n}\n</code></pre>\n<p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，就可以顺势原型链污染</p>\n<p>用如下代码实验一下：</p>\n<pre><code class=\"javascript\">let o1 = {}\nlet o2 = {a: 1, \"__proto__\": {b: 2}}\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = {}\nconsole.log(o3.b)\n</code></pre>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_3.png\" alt=\"image-20230815222140080\"></p>\n<p>但现在的输出似乎与之前的设想有所违背，但这是因为，我们用JavaScript创建o2的过程（<code>let o2 = {a: 1, \"__proto__\": {b: 2}}</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，拿到的仅为<code>{a:1,b:2}</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p>\n<p>而要让<code>__proto__</code>被识别为一个键，下面的写法可以实现</p>\n<pre><code class=\"javascript\">let o1 = {}\nlet o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}')\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = {}\nconsole.log(o3.b)\n</code></pre>\n<p>这里使用<code>JSON.parse</code></p>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_4.png\" alt=\"image-20230815222650451\"></p>\n<p>成功修改了<code>b</code>，从而实现了原型链污染</p>\n<p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>ctfshow web入门 web 338</p>\n<p>common.js</p>\n<pre><code class=\"javascript\">module.exports = {\n  copy:copy\n};\n\nfunction copy(object1, object2){\n    for (let key in object2) {\n        if (key in object2 &amp;&amp; key in object1) {\n            copy(object1[key], object2[key])\n        } else {\n            object1[key] = object2[key]\n        }\n    }\n  }\n</code></pre>\n<p>而在login.js中</p>\n<pre><code class=\"javascript\">/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow==='36dboy'){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n  \n  \n});\n</code></pre>\n<p>通过调用copy将请求发送来的json数据进行copy，而在该代码中，<code>secret={}</code>，为了使得其有属性<code>ctfshow</code>，故可以通过修改发送的json数据，添加<code>__proto__</code>，增添<code>ctfshow：'36dboy'</code></p>\n<p>，从而影响Object类，继承，从而使得secret含有属性<code>ctfshow</code>,并且值为<code>36dboy</code></p>\n<p><img data-src=\"/./../../../post_images/ctfshow/Web-vip/web_338_1.png\" alt=\"web_338_1\"></p>\n",
            "tags": [
                "CTF",
                "web",
                "javascript"
            ]
        }
    ]
}