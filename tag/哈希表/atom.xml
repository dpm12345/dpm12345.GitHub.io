<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://dpm12345.github.io</id>
    <title>dpm12345 • Posts by &#34;哈希表&#34; tag</title>
    <link href="http://dpm12345.github.io" />
    <updated>2022-03-18T15:54:40.000Z</updated>
    <category term="git" />
    <category term="Qt" />
    <category term="ms17" />
    <category term="msf" />
    <category term="CTF" />
    <category term="sql注入" />
    <category term="Misc" />
    <category term="笔记" />
    <category term="SSRF" />
    <category term="kali" />
    <category term="nmap" />
    <category term="MFC" />
    <category term="树" />
    <category term="二叉树" />
    <category term="数据结构" />
    <category term="队列" />
    <category term="ctfshow" />
    <category term="Web" />
    <category term="前缀和" />
    <category term="动态规划" />
    <category term="滑动窗口" />
    <category term="数组" />
    <category term="哈希表" />
    <category term="链表" />
    <category term="矩阵" />
    <category term="递归" />
    <category term="贪心" />
    <category term="子序列" />
    <category term="最长公共子序列" />
    <category term="最长回文子序列" />
    <category term="字符串" />
    <category term="括号" />
    <category term="vector" />
    <category term="栈" />
    <category term="排列组合" />
    <category term="双指针（快慢指针）" />
    <category term="等差数列" />
    <category term="深度优先搜索" />
    <category term="广度优先搜索" />
    <entry>
        <id>http://dpm12345.github.io/2022/03/18/leetcode/regular-exercise/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
        <title>两数相加</title>
        <link rel="alternate" href="http://dpm12345.github.io/2022/03/18/leetcode/regular-exercise/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
        <content type="html">&lt;p&gt;题目链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv&#34;&gt;两数相加&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;题目详情：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E7%B4%A0%E6%9D%90/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;不带头节点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不带头节点&#34;&gt;#&lt;/a&gt; 不带头节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/**
 * Definition for singly-linked list.
 * struct ListNode &amp;#123;
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) &amp;#123;&amp;#125;
 *     ListNode(int x) : val(x), next(nullptr) &amp;#123;&amp;#125;
 *     ListNode(int x, ListNode *next) : val(x), next(next) &amp;#123;&amp;#125;
 * &amp;#125;;
 */
class Solution &amp;#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &amp;#123;
        ListNode* ans = nullptr;               // 开始节点
        ListNode* tail = nullptr;              // 尾节点
        int add = 0;                           // 进位
        while(l1!=nullptr||l2!=nullptr)
        &amp;#123;
            int m = l1? l1 -&amp;gt;val : 0;
            int n = l2? l2 -&amp;gt;val : 0;
            int num = (m + n + add) %10;       // 个位数
            add = (m + n + add)/10;            // 进位
            if(!ans)                           
            &amp;#123;                                  
                ans = tail = new ListNode(num);
            &amp;#125;
            else
            &amp;#123;
                tail -&amp;gt; next = new ListNode(num);
                tail = tail -&amp;gt; next;
            &amp;#125;

            if(l1)
                l1 = l1 -&amp;gt; next;
            if(l2)
                l2 = l2 -&amp;gt; next;
        &amp;#125;
        if(add)                                // 如果还有进位，那么应该再创建一个节点
            tail -&amp;gt;next = new ListNode(add);
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;带头结点-省去了无节点情况的考虑代码&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#带头结点-省去了无节点情况的考虑代码&#34;&gt;#&lt;/a&gt; 带头结点 (省去了无节点情况的考虑代码)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &amp;#123;
        ListNode* ans = new ListNode(-1);       //ans-&amp;gt;next 为答案
        ListNode* cnode = ans;                  // 遍历节点指针
        int add = 0;                            // 进位
        while(l1!=nullptr||l2!=nullptr)
        &amp;#123;
            int m = l1 ? l1 -&amp;gt;val : 0;
            int n = l2 ? l2 -&amp;gt;val : 0;
            int num = (m + n + add) %10;        // 个位数
            add = (m + n + add)/10;             // 进位
            cnode -&amp;gt; next = new ListNode(num);  // 链接
            cnode = cnode -&amp;gt; next;              // 转移
            if(l1)
                l1 = l1 -&amp;gt; next;
            if(l2)
                l2 = l2 -&amp;gt; next;
        &amp;#125;
        if(add)
            cnode -&amp;gt;next = new ListNode(add);
        return ans-&amp;gt;next;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="哈希表" />
        <category term="链表" />
        <updated>2022-03-18T15:54:40.000Z</updated>
    </entry>
    <entry>
        <id>http://dpm12345.github.io/2022/03/18/leetcode/regular-exercise/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
        <title>两数之和</title>
        <link rel="alternate" href="http://dpm12345.github.io/2022/03/18/leetcode/regular-exercise/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
        <content type="html">&lt;p&gt;题目链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLw==&#34;&gt;两数之和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;题目详情：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E7%B4%A0%E6%9D%90/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
    vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) &amp;#123;
        unordered_map&amp;lt;int,int&amp;gt;temp;
        for(int i=0;i&amp;lt;nums.size();i++)
        &amp;#123;
            int num = nums[i];
            if(temp.find(target-num)!=temp.end())
                return &amp;#123;temp[target-num],i&amp;#125;;
            else
                temp.insert(&amp;#123;num,i&amp;#125;);
        &amp;#125;
        return &amp;#123;&amp;#125;;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="数组" />
        <category term="哈希表" />
        <updated>2022-03-18T14:54:40.000Z</updated>
    </entry>
    <entry>
        <id>http://dpm12345.github.io/2022/03/18/leetcode/regular-exercise/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</id>
        <title>无重复字符的最长字串</title>
        <link rel="alternate" href="http://dpm12345.github.io/2022/03/18/leetcode/regular-exercise/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
        <content type="html">&lt;p&gt;题目链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLw==&#34;&gt;无重复字符的最长字串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;题目详情：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E7%B4%A0%E6%9D%90/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
    int lengthOfLongestSubstring(string s) &amp;#123;
        if(s.size()==0)
            return 0;
        int ans = 1;
        int left = 0;
        unordered_set&amp;lt;char&amp;gt;temp;
        for(int i=0;i&amp;lt;s.size();i++)         // 遍历每个元素
        &amp;#123;
            while(temp.find(s[i])!=temp.end())          // 如果出现过了，由于求的是子串，故以此为开头的字符必不成立，故删去开头
            &amp;#123;
                temp.erase(s[left]);
                left++;
            &amp;#125;
            temp.insert(s[i]);                         // 找到没有出现过的字符，加入
            ans = max(ans,i-left+1);
        &amp;#125;
        return ans;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="滑动窗口" />
        <category term="哈希表" />
        <category term="字符串" />
        <updated>2022-03-18T12:54:40.000Z</updated>
    </entry>
    <entry>
        <id>http://dpm12345.github.io/2021/12/31/leetcode/regular-exercise/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</id>
        <title>环形链表</title>
        <link rel="alternate" href="http://dpm12345.github.io/2021/12/31/leetcode/regular-exercise/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
        <content type="html">&lt;h1 id=&#34;环形链表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#环形链表&#34;&gt;#&lt;/a&gt; 环形链表&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv&#34;&gt;环形链表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;题目详情：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;利用哈希表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#利用哈希表&#34;&gt;#&lt;/a&gt; 利用哈希表&lt;/h2&gt;
&lt;p&gt;** 方法详情：** 由于如果一个链表是环形链表，那么在不断地跳入下一个结点坐标时，其地址必然与前面 d 的某个地址相同，也就是说，我们可以把每个结点的地址存入哈希表中，当出现要存入结点地址已经在哈希表中存过之后，那么该链表必然是环形链表，否则不是。据此，时间方面，我们可知只需最长只需遍历链表结点一遍；空间方面，我们创建了一个哈希表，最多存入链表的总个数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下为代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
    bool hasCycle(ListNode *head) &amp;#123;
        unordered_map&amp;lt;ListNode*,int&amp;gt;a;
        while(head!=NULL)
        &amp;#123;
            if(a.count(head))
            return true;
            a.insert(&amp;#123;head,0&amp;#125;);
            head=head-&amp;gt;next;
        &amp;#125;
        return false;
        
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;利用双指针快慢指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#利用双指针快慢指针&#34;&gt;#&lt;/a&gt; 利用双指针（快慢指针）&lt;/h2&gt;
&lt;p&gt;题目中的进阶要求我们使用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的内存，该方案是可以实现的，具体涉及到双指针方法详情：我们可以创建两个指针，快指针 fast，每次走两步，慢指针 slow，每次走一步。那么就很容易得到如果该环形链表为环形链表，快指针必定会在环形结点的某一个结点与慢指针相遇 (或者说是追上慢指针)，那么只需判断最后两个指针是否指向同一个结点即可&lt;/p&gt;
&lt;p&gt;** 证明：** 在该方法中，使用了分别走一步和两步的指针。如果该链表是环形链表，当慢指针进入环形部分中，此时快指针也在某处，设他们相差&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 个结点，而他们的速度之差为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mspace width=&#34;1em&#34;/&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&#34;1em&#34;/&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n\quad mod\quad1==0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:1em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:1em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 也就是说，必定存在某一时刻能够使两指针指向同一个地址据此，时间方面，在慢指针进入环形结点后，快慢指针初始相距最长为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;L(L&amp;lt;=N)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;, 而在此之前遍历次数也只和&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;N&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.10903em;&#34;&gt;N&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 有关，如果没有环形链表，那么遍历次数为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;⌊&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\lfloor&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;⌊&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mfrac&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\frac{n}{2}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.040392em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.695392em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathnormal mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;⌋&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\rfloor&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;⌋&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下为代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
    bool hasCycle(ListNode *head) &amp;#123;
        ListNode*fast=head,*slow=head;
        while(fast!=NULL&amp;amp;&amp;amp;fast-&amp;gt;next!=NULL)
        &amp;#123;
            fast=fast-&amp;gt;next-&amp;gt;next;
            slow=slow-&amp;gt;next;
            if(fast==slow)
                return true;
        &amp;#125;
        return false;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;环形链表-ii求出环形链表开始结点位置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#环形链表-ii求出环形链表开始结点位置&#34;&gt;#&lt;/a&gt; 环形链表 II（求出环形链表开始结点位置）&lt;/h1&gt;
&lt;p&gt;题目链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv&#34;&gt;环形链表 II&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;题目详情：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;该题与上面题目比较像，但在确定环的同时也要返回环开始结点&lt;/p&gt;
&lt;h2 id=&#34;哈希表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#哈希表&#34;&gt;#&lt;/a&gt; 哈希表&lt;/h2&gt;
&lt;p&gt;在上一个问题中，我们是找到重复就返回 true，那么同理在这里我们可以使用相同的代码，仅仅把返回值的 true 和 false 分别改成对应节点和 NULL 即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
    ListNode *detectCycle(ListNode *head) &amp;#123;
        unordered_map&amp;lt;ListNode*,int&amp;gt;a;
        while(head!=NULL)
        &amp;#123;
            if(a.count(head))
               return head;
            a.insert(&amp;#123;head,1&amp;#125;);
            head=head-&amp;gt;next;
        &amp;#125;
        return NULL;
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;双指针快慢指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#双指针快慢指针&#34;&gt;#&lt;/a&gt; 双指针（快慢指针）&lt;/h2&gt;
&lt;p&gt;为了降低内存我们同样也可以使用快慢指针，将空间复杂度降到&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，这里涉及到一个证明&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E8%AF%81%E6%98%8E.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以我们可以在双指针基础上，在他们相遇时新建两个指针 (或者直接用现成的 &lt;code&gt;head&lt;/code&gt;  和 &lt;code&gt;slow/fast&lt;/code&gt;  指针，不断往后面走，相遇时得到该位置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(n)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;O(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
    ListNode *detectCycle(ListNode *head) &amp;#123;
        ListNode *slow=head,*fast=head;
        while(fast&amp;amp;&amp;amp;fast-&amp;gt;next)
        &amp;#123;
            slow=slow-&amp;gt;next;
            fast=fast-&amp;gt;next-&amp;gt;next;
            if(slow==fast)
            &amp;#123;
                ListNode* start=head,*meet=slow;
                while(start!=meet)
                &amp;#123;
                    start=start-&amp;gt;next;
                    meet=meet-&amp;gt;next;
                &amp;#125;
                return meet;
            &amp;#125;
        &amp;#125;
        return NULL;
        
    &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="哈希表" />
        <category term="链表" />
        <category term="双指针（快慢指针）" />
        <updated>2021-12-31T11:54:40.000Z</updated>
    </entry>
    <entry>
        <id>http://dpm12345.github.io/2021/11/21/leetcode/regular-exercise/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</id>
        <title>整数拆分</title>
        <link rel="alternate" href="http://dpm12345.github.io/2021/11/21/leetcode/regular-exercise/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
        <content type="html">&lt;p&gt;&lt;span class=&#34;orange&#34;&gt;题目链接:&lt;/span&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay8=&#34;&gt; 整数拆分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;orange&#34;&gt;题目详情&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;/%E7%B4%A0%E6%9D%90/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png&#34; alt=&#34;整数拆分_1&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;blue&#34;&gt;数学方法可以证明乘积最大时，因子最终都可以分解为若干个 3 和若干个 2，且 3 的个数尽可能多&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Solution &amp;#123;
public:
	int integerBreak(int n) &amp;#123;
		if (n == 2)return 1;
		if (n == 3)return 2;
		int num_3 = n / 3, num_2 = (n % 3) / 2;
		if (n % 3 == 1)
		&amp;#123;
			num_3--;
			num_2 += 2;
		&amp;#125;
		return pow(3, num_3)*pow(2, num_2);
	&amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
</content>
        <category term="滑动窗口" />
        <category term="哈希表" />
        <category term="字符串" />
        <updated>2021-11-21T07:54:40.000Z</updated>
    </entry>
</feed>
