{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"贪心\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/4a8b7903/",
            "url": "http://dpm12345.cn/posts/4a8b7903/",
            "title": "方法总结",
            "date_published": "2021-12-26T02:20:40.000Z",
            "content_html": "<h1 id=\"括号问题\"><a href=\"#括号问题\" class=\"headerlink\" title=\"括号问题\"></a>括号问题</h1><h2 id=\"是否为有效括号\"><a href=\"#是否为有效括号\" class=\"headerlink\" title=\"是否为有效括号\"></a>是否为有效括号</h2><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv\">有效的括号</span></p>\n<p>可采用栈的先入后出特性，一个个匹配</p>\n<h2 id=\"判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由-locked-存储\"><a href=\"#判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由-locked-存储\" class=\"headerlink\" title=\"判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由 locked 存储\"></a>判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由 locked 存储</h2><p>如 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzaXMtc3RyaW5nLw==\">有效的括号字符串</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2hlY2staWYtYS1wYXJlbnRoZXNlcy1zdHJpbmctY2FuLWJlLXZhbGlkLw==\">判断一个括号字符串是否有效</span></p>\n<p>利用平衡值的方法，一个字符串是否为有效括号，那么在某个位置前的右括号之前必然有左括号相匹配，在某个某个位置的左括号之后必然有右括号相匹配</p>\n<p>以下为几种不同的具体方法</p>\n<h3 id=\"两次遍历，正序遍历和逆序遍历。\"><a href=\"#两次遍历，正序遍历和逆序遍历。\" class=\"headerlink\" title=\"两次遍历，正序遍历和逆序遍历。\"></a>两次遍历，正序遍历和逆序遍历。</h3><p>正序遍历时，用 count 记录此时未匹配左括号数，其中如果<code>locked[i]=′0′</code>，那么以左括号来记，当匹配到不可变的右括号时，<code>count−−</code>，如果<code>count &lt; 0</code>出现了，那么该字符串不是有效的括号字符串</p>\n<p>逆序遍历时，同正序遍历时的方法，用 count 记录此时未匹配右括号数，其中如果<code>locked[i]=′0′</code>，那么以右括号来记，当匹配到不可变的左括号时，<code>count−−</code>，如果<code>count &lt; 0</code>出现了，那么该字符串不是有效的括号字符串</p>\n<p>以下为参考代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool checkValidString(string s) {\n        int count=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(s[i]=='('||s[i]=='*')\n                count++;\n            else\n                count--;\n            if(count&lt;0)\n                return false;\n        }\n        count=0;\n        for(int i=s.size()-1;i&gt;=0;i--)\n        {\n            if(s[i]==')'||s[i]=='*')\n                count++;\n            else\n                count--;\n            if(count&lt;0)\n                return false;\n        }\n        return true;\n    }\n};\n</code></pre>\n<h3 id=\"贪心算法：一次遍历，用-maxc-记录最大未匹配数，minc-记录最小未匹配数\"><a href=\"#贪心算法：一次遍历，用-maxc-记录最大未匹配数，minc-记录最小未匹配数\" class=\"headerlink\" title=\"贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数\"></a>贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数</h3><p>当遇到不可变的右(左)括号时<code>maxc</code>，和<code>minc</code>都加一 (减一), 如果在此期间，<code>maxc &lt; 0</code>，那么证明有右括号不能被匹配那么这串字符串是无效的</p>\n<p>当遇到可变的位置时，由于既可以变也可以不变，那么<code>maxcpp</code>，<code>minc--</code>；其中如果<code>minc</code>减之前如果是0，那么<code>minc</code>就变为1，因为会增加(如果是<code>*</code>可代表左右括号或者空字符，那么只需维护<code>minc&gt;=0</code>即可，因为<code>*</code>有三种状态)</p>\n<p>如果在遍历过程中，<code>minc &gt; maxc</code>，那么证明该串是无效的</p>\n<p>最后如果该串是有效，那么<code>minc</code>必为0，所以返回值为<code>minc == 0</code></p>\n<p>代码示例</p>\n<h4 id=\"第一道\"><a href=\"#第一道\" class=\"headerlink\" title=\"第一道\"></a>第一道</h4><pre><code class=\"cpp\">class Solution {\npublic:\n    bool checkValidString(string s) {\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(s[i]=='(')\n            {\n                mincpp;\n                maxcpp;\n            }\n            else if(s[i]==')')\n            {\n                minc=minc==0?0:minc-1;\n                maxc--;\n                if(maxc&lt;0)\n                    return false;\n            }\n            else\n            {\n                minc=minc==0?0:minc-1;\n                maxcpp;\n            }\n        }\n        return minc==0;\n    }\n};\n</code></pre>\n<h4 id=\"第二道\"><a href=\"#第二道\" class=\"headerlink\" title=\"第二道\"></a>第二道</h4><pre><code class=\"cpp\">class Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        if(s.size()%2==1)  return false;\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(locked[i]=='1')\n            {\n                if(s[i]=='(')\n                {\n                    mincpp;\n                    maxcpp;\n                }\n                if(s[i]==')')\n                {\n                    maxc--;\n                    minc=minc==0?1:minc-1;\n                    if(maxc&lt;0)\n                        return false;\n                }\n            }\n            else\n            {\n                minc=minc==0?1:minc-1;\n                maxcpp;\n            }\n            if(minc&gt;maxc)\n                return false;\n        }\n        return minc==0;\n    }\n};\n</code></pre>\n",
            "tags": [
                "贪心",
                "括号"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/b115b06a/",
            "url": "http://dpm12345.cn/posts/b115b06a/",
            "title": "加油站",
            "date_published": "2021-11-27T06:20:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi8=\">加油站</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E5%8A%A0%E6%B2%B9%E7%AB%99_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<p>算法思路：贪心算法</p>\n<h1 id=\"pos-数组记录每个位置的剩余油量\"><a href=\"#pos-数组记录每个位置的剩余油量\" class=\"headerlink\" title=\"pos 数组记录每个位置的剩余油量\"></a>pos 数组记录每个位置的剩余油量</h1><ol>\n<li><p>使用另一个数组$pos$，其中$pos[i]=gas[i]-cost[i]$, 从下标$0$开始遍历，若$pos[i]&lt;0$, 则必不以此为起点；若 $pos[i]&gt;=0$, 则以其为起点，</p>\n<p> 用$res$存储当前剩余油量，之后以此为起点遍历之后位置$n$，若$pos[n]+res&lt;0$, 此起点不满足题意，若 $&gt;=0$, 则更新$res$，并使</p>\n<p> $n=(n+1)%pos.size()$，继续遍历若正常结束循环，则可以返回$i$的值</p>\n</li>\n</ol>\n<p>  以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        if(gas.size()==1)return (gas[0]&lt;cost[0])?-1:0;\n        vector&lt;int&gt;pos(gas.size());\n        for(int i=0;i&lt;pos.size();i++)\n        {\n            pos[i]=gas[i]-cost[i];\n        }\n        for(int i=0;i&lt;pos.size();i++)\n        {\n            if(pos[i]&gt;0)\n            {\n                int res=pos[i],n=(i+1)%pos.size();\n                while(n!=i)\n                {\n                    if(pos[n]+res&lt;0)\n                    break;\n                    res+=pos[n];\n                    n=(n+1)%pos.size();\n                }\n                if(n==i)return i;\n            }\n            \n        }\n        return -1;\n    }\n};\n</code></pre>\n<ol start=\"2\">\n<li><p>优化：由上代码，当不满足$pos[n]+res&gt;=0$时，$n$即为以$i$为起点不可能到达的位置，那么这两个位置之间的位置都不可能到达$n$因为以$i$为起点，当它到两者中间位置时，初始油量大于等于零，而从$i$位置到达不了，更别说两者其中位置了由此，可增加一个变量记录每次前进的长度$num$，当以某一起点得不到答案时，使$i=i+num+1$更新$i$，提高效率</p>\n<p>代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int n=gas.size();\n        int i=0;\n        while(i&lt;n)\n        {\n            int num=0,total_gas=0,total_cost=0;\n            while(num&lt;n)\n            {\n                int j=(i+num)%n;\n                total_gas+=gas[j];\n                total_cost+=cost[j];\n                if(total_gas&lt;total_cost)\n                break;\n                num++;\n            }\n            if(num==n)return i;\n            else\n            {\n                i=i+num+1;\n            }\n        }\n        return -1;\n\n    }\n};\n</code></pre>\n</li>\n</ol>\n",
            "tags": [
                "贪心"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/723dcd0c/",
            "url": "http://dpm12345.cn/posts/723dcd0c/",
            "title": "摆动序列",
            "date_published": "2021-11-26T02:20:40.000Z",
            "content_html": "<p>[题目链接:]{.orange}<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlLw==\">摆动序列</span></p>\n<p>[题目详情:]{.orange}</p>\n<p><img data-src=\"/../../../post_images/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"摆动序列_题目详情\"></p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"原始\"><a href=\"#原始\" class=\"headerlink\" title=\"原始\"></a>原始</h2><p>思路：关键点在于，当增添一个数成为摆动序列中的一个元素时，那么这个数要么小于，要么大于其前面的一个数 其大于或小于取决于前面一个数与再前面一个数之间的大小关系 就此，可利用动态规划的思想，分别用$up[i]$,$down[i]$记录前$i+1$个数的最长摆动序列。(其中$up[i]$记录末尾为上升的，$down[i]$记录下降的)     </p>\n<p>将题目解决方法转换为三方面：   </p>\n<ol>\n<li><p>当$nums[i]&lt;nums[i-1]$时，该元素不可添加到$up[i]$中，而对于$down[i]$，取$down[i-1]$(不加上该数),$up[i-1]+1$(加上该数)中的最大值，即<br>$$<br>down[i] = max{up[i-1]+1, down[i-1]}<br>$$</p>\n</li>\n<li><p>当$nums[i]&gt;nums[i-1]$时，该元素不可添加到$down[i]$中,而对于$up[i]$,取$up[i-1]$(不加上该数),$down[i-1]+1$(加上该数)中的最大值，即<br>$$<br>up[i] = max{up[i-1], down[i-1]+1}<br>$$</p>\n</li>\n<li><p>当$nums[i]=nums[i-1]$时，都不能加上,故<br>$$<br>up[i]=up[i-1]<br>$$</p>\n<p>$$<br>dowm[i]=down[i-1]<br>$$</p>\n</li>\n</ol>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n == 1) return n;\n        vector&lt;int&gt;up(n), down(n);\n        up[0] = down[0] = 1;\n        for (int i = 1; i&lt;n; i++)\n        {\n            if (nums[i]&lt;nums[i - 1])\n            {\n                up[i] = up[i - 1];\n                down[i] = max(down[i - 1], up[i - 1] + 1);\n            }\n            else if (nums[i]&gt;nums[i - 1])\n            {\n                up[i] = max(up[i - 1], down[i - 1] + 1);\n                down[i] = down[i - 1];\n            }\n            else\n            {\n                up[i] = up[i - 1];\n                down[i] = down[i - 1];\n            }\n        }\n        return max(up[n - 1], down[n - 1]);\n    }\n};\n</code></pre>\n<h3 id=\"动态规划的空间优化\"><a href=\"#动态规划的空间优化\" class=\"headerlink\" title=\"动态规划的空间优化\"></a>动态规划的空间优化</h3><p>由于$up[i]$,$down[i]$只与下标为$i-1$的值有关，那么可以用两个变量代替数组，最后取这两个变量的最大值</p>\n<p>优化代码如下:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n == 1) return n;\n        int up = 1, down = 1;\n        for (int i = 1; i&lt;n; i++)\n        {\n            if (nums[i]&lt;nums[i - 1])\n            {\n                down = max(down, up + 1);\n            }\n            else if (nums[i]&gt;nums[i - 1])\n            {\n                up = max(up, down + 1);\n            }\n        }\n        return max(up, down);\n    }\n};\n</code></pre>\n<h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><p>代码如下:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n &lt; 2) {\n            return n;\n        }\n        int prevdiff = nums[1] - nums[0];\n        int num = prevdiff != 0 ? 2 : 1;\n        for (int i = 2; i &lt; n; i++) {\n            int diff = nums[i] - nums[i - 1];\n            if ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) {\n                num++;\n                prevdiff = diff;\n            }\n        }\n        return num;\n    }\n};\n</code></pre>\n<p>一开始本身的疑点：其代码行只要有<code>(diff&gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)</code>情况出现，则<code>num++</code>,<br>不会导致因为所选数不是最佳方案而造成答案错误吗？<br>// 经过思考：正因为代码段</p>\n<pre><code class=\"cpp\">int diff = nums[i] - nums[i - 1];\nif ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) {\n    num++;\n    prevdiff = diff;\n}\n</code></pre>\n<p>每次都会更新diff的值，也就是说每次都会更新“峰”或“谷”的值，从而使得为最佳方案</p>\n",
            "tags": [
                "动态规划",
                "贪心"
            ]
        }
    ]
}