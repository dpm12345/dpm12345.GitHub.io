{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"递归\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.github.io",
    "items": [
        {
            "id": "http://dpm12345.github.io/posts/12ad1f11/",
            "url": "http://dpm12345.github.io/posts/12ad1f11/",
            "title": "全排列",
            "date_published": "2021-12-24T01:54:40.000Z",
            "content_html": "<h1 id=\"无重复数字的全排列\"><a class=\"anchor\" href=\"#无重复数字的全排列\">#</a> 无重复数字的全排列</h1>\n<p>先考虑 2 个数的全排列，很明显就是只有两种，一种两个数字的顺序不改变，另一种改变两个数字的顺序</p>\n<p>然后再考虑 3 个数的全排列，比如 <code>1，2，3</code></p>\n<p>那么总共排列的种类总共为</p>\n<p>1，2，3<br />\n1，3，2<br />\n2，1，3<br />\n2，3，1<br />\n3，1，2<br />\n3，2，1</p>\n<p>由此不难发现，每一次的排列总个数（不同的数字开头）都可以看作是在前一种的基础上交换两个数的结果</p>\n<p>例如 <code>1，3，2</code>  是在 <code>1，2，3</code>  的基础上交换 2，3 位置后得到的。以此类推，4 个数，5 个数，n 个数也一样。那么在这里可以采用递归方法，与汉诺塔问题相似，我们将 n 个数划分为 1 和 n-1 个数，先交换两部分得到一种情况，然后以此为基础再进行交换，结束此种情况后将数字交换回来进入下一种情况</p>\n<p>因此我们可以构造 perm 函数，第一个形参为数组，第二个为未交换数，第三个为数组的末尾下标</p>\n<p>因此核心代码为:</p>\n<pre><code class=\"language-c++\">// 假设这里的递归函数为 perm，数组为 nums，交换的对象为 nums [i] 和 nums [k]\n\tfor(int i=k;i&lt;=m;i++)        // 这里用于把后面的数进行交换\n\t&#123;\n        swap(nums[i],nums[k]);            // 交换，创造新的情况\n\t    perm(nums,k+1,m);                 // 进入新的情况，k+1 为之后未交换的情况\n\t\tswap(nums[i],nums[k]);           // 交换回来\n\t&#125;\n</code></pre>\n<p>这里我们需要考虑原来的情况，也就是说此时不需要交换，所以为了保持代码的一致性，可以一开始使其与自身交换，因此为 <code>swap(nums[i],nums[k])</code></p>\n<p>代码如下</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    void swap(int*p,int*q)\n    &#123;\n        int temp=*p;\n        *p=*q;\n        *q=temp;\n    &#125;\n    void out(vector&lt;int&gt;&amp;nums,vector&lt;vector&lt;int&gt;&gt;&amp;ans,int k,int m)\n    &#123;\n        if(k==m)\n        &#123;\n            ans.push_back(nums);\n        &#125;\n        else\n        &#123;\n            for(int i=k;i&lt;=m;i++)\n            &#123;\n                swap(&amp;nums[i],&amp;nums[k]);\n                out(nums,ans,k+1,m);\n                swap(&amp;nums[i],&amp;nums[k]);\n            &#125;\n        &#125;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt;ans;\n        out(nums,ans,0,nums.size()-1);\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<p>该问题在 leetcode 也有题目</p>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==\">全排列</span></p>\n<h1 id=\"有重复数字的全排列\"><a class=\"anchor\" href=\"#有重复数字的全排列\">#</a> 有重复数字的全排列</h1>\n",
            "tags": [
                "递归"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/20c47d09/",
            "url": "http://dpm12345.github.io/posts/20c47d09/",
            "title": "快速幂",
            "date_published": "2021-12-05T02:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcG93eC1uLw==\">快速幂</span></p>\n<p>题目详情：实现 Pow (x,n)</p>\n<h1 id=\"递归\"><a class=\"anchor\" href=\"#递归\">#</a> 递归</h1>\n<p>思路：要实现<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mi>o</mi><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Pow(x,n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，显然不可能用 for 或 while 循环进行一个一个<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 相乘，这样时间相对较长，那么可以做以下简化，若要求<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>，当 n 为奇数时，那么<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 就等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding=\"application/x-tex\">x^{\\frac{n}{2}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84708em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.84708em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6915428571428572em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span></span></span></span></span></span></span></span></span> 次方的的平方再乘一个<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>；当 n 为偶数时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding=\"application/x-tex\">x^{\\frac{n}{2}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84708em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.84708em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6915428571428572em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span></span></span></span></span></span></span></span></span> 的平方，以此类推，递归方程就可写出以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    double quickMul(double x, long long N) &#123;\n        if (N == 0) &#123;\n            return 1.0;\n        &#125;\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    &#125;\n\n    double myPow(double x, int n) &#123;\n        long long N = n;\n        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    &#125;\n&#125;;\n</code></pre>\n<p>注意：代码中递归结束条件为 <code>N==0</code> ，而不是 <code>N==1</code> ；原因为考虑一开始 <code>N==0</code>  的情况</p>\n<h1 id=\"迭代优化\"><a class=\"anchor\" href=\"#迭代优化\">#</a> 迭代优化</h1>\n<p>在递归方法中，我们是通过倒序来进行判断什么时候乘 x，什么时候不乘 x 的，而要实现迭代优化，那么必然要正序遍历，所以现在的目的便是要找到怎样正序遍历的方法。</p>\n<p>我们再仔细想一下第一种确定乘 x 和不乘 x 的方法，是偶数不乘，是奇数则乘 x，倒序遍历，或许这样说还不够明白，那么换一种说法，偶数乘 x 的零次方 (和不乘结果相同), 而奇数乘 x 的 1 次方，倒序排列，换成这样的说法，我们很容易得到，这便是 n 的二进制形式，它的二进制的每一位表示着乘 x 的权，而每次计算时又会平方，那么也就是幂的二进制乘 2，若偶数末尾即零，奇数末尾即 1，如此继续下去，最后得到的值便为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 的值，因此这样便可得到迭代优化后的程序</p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    double myPow(double x, int n) &#123;\n        double ans=1;\n        int flag=n;\n        double xc=x;         // 记录每一位如果为 1 应乘的 x 次方\n        while(n!=0)\n        &#123;\n            if(n%2)\n                ans*=xc;\n            xc=xc*xc;               // 每进一位则平方一次 xc\n            n/=2;\n        &#125;\n        return flag&gt;0?ans:1.0/ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "递归"
            ]
        }
    ]
}