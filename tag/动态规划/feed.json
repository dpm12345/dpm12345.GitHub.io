{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"动态规划\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/73645ce2/",
            "url": "http://dpm12345.cn/posts/73645ce2/",
            "title": "丑数",
            "date_published": "2022-01-14T14:54:40.000Z",
            "content_html": "<p>丑数，其所有因数均属于所给的数字集合，如对于因数 2，3，5，</p>\n<p>2，6，10 均为满足条件的丑数</p>\n<p>以下为 leetcode 上丑数的相关问题</p>\n<h1 id=\"丑数\"><a class=\"anchor\" href=\"#丑数\">#</a> 丑数</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdWdseS1udW1iZXIvc29sdXRpb24v\"> 丑数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"../../../post_images/%E4%B8%91%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\"></p>\n<p>根据丑数因数特点，我们可以依次不断除以所给因数集的各因数，如果其为丑数，结束后其必定变为数字 <code>1</code> ，如果不满足，其必不为 <code>1</code></p>\n<p>代码如下:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>丑数</span></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">bool</span> <span class=\"token function\">isUgly</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">int</span> div<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> div<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                n <span class=\"token operator\">/=</span> div<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">return</span> n<span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr></tbody></table></figure><h1 id=\"丑数-ii\"><a class=\"anchor\" href=\"#丑数-ii\">#</a> 丑数 II</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdWdseS1udW1iZXItaWkv\"> 丑数 II</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"../../../post_images/%E4%B8%91%E6%95%B0II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\"></p>\n<p><strong>思路:</strong></p>\n<p>这一道题目的因数集与上题相同，但要求不同，求的是满足条件的第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个丑数</p>\n<p>仔细观察题目示例，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>12</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2,3,4,5,6,8,9,10,12]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span> 为前十个丑数组成的序列，结合丑数特点，每个数字最多只有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">2,3,5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span></span></span></span>，三个因数，也就是说我们可以利用动态规划的思想，在前面的基础上乘以因数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">2,3,5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span></span></span></span>​，得到的数必然为满足的丑数。由于要涵盖所有的数，那么前面的数都应要乘各项因数，因此可以为不同因数各设置一个记录应该乘第几个丑数的变量，并将所得乘积记录到数组中，在取时，只需取数组中的最小值即可，取出后相应的也需要更新该因数对应的最小数</p>\n<p>由于存在公倍数，因此在判断取出的数是哪个因数时需要对每个因素都进行判断一次，排除重复的情况</p>\n<p>代码如下:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>丑数II</span></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token function\">nthUglyNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//dp [n] 表示第 n 个丑数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        dp<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// 默认第一个为 1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">int</span> p2 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> p3 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> p5 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//p2,p3,p5 分别表示对应因数应乘的丑数下标</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>p2<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> num3 <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>p3<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> num5 <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>p5<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 更新数组</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>num2<span class=\"token punctuation\">,</span> num3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> num5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 找到最小值</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                        <span class=\"token comment\">// 判断该最小值是否由因数 2 得到</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                p2<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> num3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                        <span class=\"token comment\">// 判断该最小值是否由因数 2 得到</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                p3<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> num5<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                        <span class=\"token comment\">// 判断该最小值是否由因数 2 得到</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                p5<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr></tbody></table></figure><h1 id=\"xxxxxxxxxx49-1class-solution-2public3-int-numislandsvectorvectorchar-grid-4-int-mgridsizengrid0size5-ifm0-6-return-07-int-ans08-forint-i0imi9-10-forint-j0jnj11-12-ifgridij113-14-ans15-gridij016-queuepairintints17-spushij18-whilesempty19-20-auto-rcsfront21-spop22-ifr-10gridr-1c123-24-gridr-1c025-spushr-1c26-27-ifr1mgridr1c128-29-gridr1c030-spushr1c31-32-ifc-10gridrc-1133-34-gridrc-1035-spushrc-136-37-ifc1ngridrc1138-39-gridrc1040-spushrc141-4243-44-45-46-47-return-ans48-49cpp-广度优先搜索4\"><a class=\"anchor\" href=\"#xxxxxxxxxx49-1class-solution-2public3-int-numislandsvectorvectorchar-grid-4-int-mgridsizengrid0size5-ifm0-6-return-07-int-ans08-forint-i0imi9-10-forint-j0jnj11-12-ifgridij113-14-ans15-gridij016-queuepairintints17-spushij18-whilesempty19-20-auto-rcsfront21-spop22-ifr-10gridr-1c123-24-gridr-1c025-spushr-1c26-27-ifr1mgridr1c128-29-gridr1c030-spushr1c31-32-ifc-10gridrc-1133-34-gridrc-1035-spushrc-136-37-ifc1ngridrc1138-39-gridrc1040-spushrc141-4243-44-45-46-47-return-ans48-49cpp-广度优先搜索4\">#</a> xxxxxxxxxx49&nbsp;1class Solution {2public:3 &nbsp; &nbsp;int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {4 &nbsp; &nbsp; &nbsp; &nbsp;int m=grid.size(),n=grid[0].size();5 &nbsp; &nbsp; &nbsp; &nbsp;if(m<mark>0) &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 0;7 &nbsp; &nbsp; &nbsp; &nbsp;int ans=0;8 &nbsp; &nbsp; &nbsp; &nbsp;for(int i=0;i&lt;m;i++)9 &nbsp; &nbsp; &nbsp;  {10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(int j=0;j&lt;n;j++)11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(grid[i][j]</mark>'1')13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans++;15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[i][j]='0';16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;queue&lt;pair&lt;int,int&gt;&gt;s;17 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({i,j});18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while(!s.empty())19 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto [r,c]=s.front();21 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.pop();22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(r-1&gt;=0&amp;&amp;grid[r-1][c]<mark>'1')23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {24 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[r-1][c]='0';25 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({r-1,c});26 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }27 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(r+1&lt;m&amp;&amp;grid[r+1][c]</mark>'1')28 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {29 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[r+1][c]='0';30 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({r+1,c});31 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(c-1&gt;=0&amp;&amp;grid[r][c-1]<mark>'1')33 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  { &nbsp; &nbsp;34 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[r][c-1]='0';35 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({r,c-1});36 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }37 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(c+1&lt;n&amp;&amp;grid[r][c+1]</mark>'1') 38 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid [r][c+1]='0';40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push ({r,c+1});41 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 42​43 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 44 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 45 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 46 &nbsp; &nbsp; &nbsp;  } 47 &nbsp; &nbsp; &nbsp; &nbsp;return ans;48 &nbsp;  } 49};cpp  广度优先搜索 4</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VwZXItdWdseS1udW1iZXIv\"> 超级丑数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"../../../post_images/%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"超级丑数_题目详情\"></p>\n<p>这题与与丑数 II 十分相似，不同的是，因数集不在是固定为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[2,3,5]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">]</span></span></span></span>，而是由给定的数组决定。</p>\n<p>同样的沿用丑数 II 的思想，在丑数 II 中，首先需要存储丑数的数组 dp，同时用于实现动态规划思想，其次需要有记录各因数应乘丑数的下标和记录目前丑数集的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">num</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span></span></span></span></p>\n<p>因此需要的变量为：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span> 存储丑数</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">point[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 记录因数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">primes[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 应乘的丑数下标</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">nums[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 存储丑数集，其中下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应因数下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></li>\n</ul>\n<p>代码如下:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>超级丑数</span></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token function\">nthSuperUglyNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span><span class=\"token operator\">&amp;</span> primes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span><span class=\"token function\">point</span><span class=\"token punctuation\">(</span>primes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token comment\">// 使用 long 防止数据溢出，因为虽然题目保证第 n 各数不会超出 32-bit，</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token comment\">// 但我们在使用该方法时是找已知丑数的最小值，因此可能超过 32-bit</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">long</span><span class=\"token operator\">&gt;</span><span class=\"token function\">nums</span><span class=\"token punctuation\">(</span>primes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">long</span><span class=\"token operator\">&gt;</span><span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">long</span> minn<span class=\"token operator\">=</span>INT_MAX<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// 用于找到丑数集中的最小数</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                minn<span class=\"token operator\">=</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>minn<span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>minn<span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// 放入存储丑数的数组中</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>minn<span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>         <span class=\"token comment\">// 表示目前找到的最小丑数可以有因数 primes [j] 得到</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                    point<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 对应丑数小标加 1</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                    nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>dp<span class=\"token punctuation\">[</span>point<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>primes<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 更新丑数集</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr></tbody></table></figure>",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/9e6e8fdc/",
            "url": "http://dpm12345.cn/posts/9e6e8fdc/",
            "title": "子序列问题",
            "date_published": "2021-12-09T01:54:40.000Z",
            "content_html": "<h1 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\">最长公共子序列</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\"></p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\"></p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>我们可以用$dp [i][j]$表示字符串1$[0<del>i]$范围内和字符串2$ [0</del>i]$范围内的最长公共序列</p>\n<p>当$text1[i]=text2[j]$时，很明显 $dp [i][j]=dp [i-1][j-1]+2$</p>\n<p>当$text1[i]!=text2[j]$时，$dp[i][j]=max(dp[i][j-1],dp[i-1][j])$</p>\n<p>因为此时需要找个最长的子序列为然后连接上后面未知的字符，这样遍历到最后就能得到最大</p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.length(),n=text2.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1));\n        int ans=0;\n        for(int i=1;i&lt;=m;i++)\n        {\n            for(int j=1;j&lt;=n;j++)\n            {\n                if(text1[i-1]==text2[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"最长回文子序列\"><a href=\"#最长回文子序列\" class=\"headerlink\" title=\"最长回文子序列\"></a>最长回文子序列</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnNlcXVlbmNlL3N1Ym1pc3Npb25zLw==\">最长回文子序列</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.jpg\"></p>\n<h2 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h2><p>沿用求最长公共子序列的方法，我们可以先将字符串反转，得到一个新的字符串，再求这两个字符串的最长公共子序列的值，即为最长回文子序列</p>\n<p><strong>证明：</strong> 回文串的表现为成对称分布，从前往后遍历和从后往前遍历的结果是一样的，所以说如果求其与其本身的反转字符串的最长公共子序列，因为一个是正向，一个是反向，当求的该共同字符串时，那就说明该字符子序列在原字符串中为回文子序列，又由于在求解过程中记录的为最长，那么结果就能得到最长回文子序列</p>\n<p>下面为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        string re=s;\n        int ans=0;\n        reverse(re.begin(),re.end());\n        vector&lt;vector&lt;int&gt;&gt;dp(s.length()+1,vector&lt;int&gt;(s.length()+1));\n        for(int i=1;i&lt;=s.length();i++)\n        {\n            for(int j=1;j&lt;=re.length();j++)\n            {\n                if(s[i-1]==re[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        return ans;\n\n    }\n};\n</code></pre>\n<h2 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h2><p>根据回文串的特征，如果一段字符串是回文串，那么将其两边各删去一个字符后依然为回文串，所以我们可以用$dp[i][j]$来表示$i$到$j$最长回文子序列的长度，当遍历时，如果$s[i]=s[j]$，那么$dp[i]=dp[i+1][j-1]+2$，如果不相等，$dp[i][j]=max(dp[i+1][j],dp[i][j-1]$</p>\n<p>需要注意的是，回文串最短为其本身，所以在开始真正寻找前，可以先将$dp [i][i]=1$</p>\n<p>在这里，我们选择由后至前推导，根据上方思想，那么最后的值应为$dp [0][n-1]$($n$为字符串长度)</p>\n<p>下面为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n=s.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(n));\n        for(int i=n-1;i&gt;=0;i--)\n        {\n            dp[i][i]=1;\n            for(int j=i+1;j&lt;n;j++)\n            {\n                if(s[j]==s[i])\n                    dp[i][j]=dp[i+1][j-1]+2;\n                else\n                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n        return dp[0][n-1];\n    }\n};\n</code></pre>\n",
            "tags": [
                "动态规划",
                "子序列",
                "最长公共子序列",
                "最长回文子序列"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/ca7417e/",
            "url": "http://dpm12345.cn/posts/ca7417e/",
            "title": "三个无重叠子数组的最大和",
            "date_published": "2021-12-09T01:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWZ1bmN0aW9uLw==\">旋转函数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0.jpg\"></p>\n<p>解题思路:</p>\n<p>由题目中的旋转函数形式<br>$$<br>F(k) = 0 * B_k[0] + 1 * B_k[1] + … + (n-1) * B_k[n-1]<br>$$<br>以题目示例为例</p>\n<blockquote>\n<p>A = [4, 3, 2, 6]</p>\n</blockquote>\n<blockquote>\n<p>F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 </p>\n<p>F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</p>\n</blockquote>\n<p>即<br>$$<br>F(0) = (0 * A [0]) + (1 * A [1]) + (2 * A [2]) + (3 * A [3])<br>$$</p>\n<p>$$<br>F(1) = (0 * A[3]) + (1 * A[0]) + (2 * A[1]) + (3 * A[2])<br>$$</p>\n<p>$$<br>F(2) = (0 * A[2]) + (1 * A[3]) + (2 * A[0]) + (3 * A[1])<br>$$</p>\n<p>$$<br>F(3) = (0 * A[1]) + (1 * A[2]) + (2 * A[3]) + (3 * A[0])<br>$$</p>\n<p>将相邻两个函数相减，可以发现<br>$$<br>F(1)-F(0)=A[0]+A[1]+A[2]+A[3]-4*A[3]<br>$$</p>\n<p>$$<br>F(2)-F(1)=A[0]+A[1]+A[2]+A[3]-4*A[2]<br>$$</p>\n<p>$$<br>F(3)-F(2)=A[0]+A[1]+A[2]+A[3]-4*A[1]<br>$$</p>\n<p>那么可以发现一般规律<br>$$<br>F(k)-F(k-1)=A[0]+A[1]+A[2]+A[3]+···+A[n-1]-n<em>A[n-k];<br>$$<br>形式为数组A元素之和减去$n</em>A[n-k]$</p>\n<p>由此我们可以维护一个$dp$数组，$dp[i]$表示$F(k)$; 一个$sum$表示$A$的元素之和。<br>$$<br>dp[i]=dp[i-1]+sum-n*A[n-i];<br>$$<br>特别的，当$i=0$时，$dp[i]=sum$。</p>\n<p>最后输出$dp[i]$的最大值</p>\n<p>因此，代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxRotateFunction(vector&lt;int&gt;&amp; nums) {\n        int n=nums.size();\n        int sum=0;\n        vector&lt;int&gt;dp(n);\n        for(int i=0;i&lt;n;i++)\n        {\n            sum+=nums[i];\n            dp[0]+=i*nums[i];\n        }\n        for(int i=1;i&lt;n;i++)\n        {\n            dp[i]=dp[i-1]+sum-n*nums[n-i];\n        }\n        return *max_element(dp.begin(),dp.end());\n    }\n};\n</code></pre>\n",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/ca7417e/",
            "url": "http://dpm12345.cn/posts/ca7417e/",
            "title": "三个无重叠子数组的最大和",
            "date_published": "2021-12-08T01:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdW0tb2YtMy1ub24tb3ZlcmxhcHBpbmctc3ViYXJyYXlzLw==\"> 三个无重叠子数组的最大和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.jpg\"></p>\n<p>该题为 2021-12-8 的每日一题，可解决该问题的方法涉及到前缀和，动态规划，滑动窗口知识</p>\n<p>思路: 题目要求求出某一数组三个长度为 k 的无重叠数组，使它们的元素之和为最大。</p>\n<p>看到这个个数为 k，很容易想到滑动窗口这一算法，只是在这里，需要同时存在三个滑动窗口，</p>\n<p>同样的，在这题，也可以用动态规划进行解决</p>\n<p>下面是我自己在解题时的过程</p>\n<h1 id=\"动态规划（劣质版）\"><a href=\"#动态规划（劣质版）\" class=\"headerlink\" title=\"动态规划（劣质版）\"></a>动态规划（劣质版）</h1><p>刚拿到题目时，我能想到，该题可以使用动态规划解决，但并无方向该从哪个地方下手将什么作为$dp[i]$所表达的意义，</p>\n<p>思考了大约20分钟后，我还是无从下手，于是打开了题解，第一眼看到的是”单个子数组的最大和“，顿时恍然大悟，我可以将不同个数的子数组作为一个$dp$，在计算个数加一时，便可以利用前面的$dp$，得到最优解。仔细思考，该方案的时间复杂度为$O(n)$。</p>\n<p>在以下的代码中，我是如此考虑的：</p>\n<p>先用$sum[i]$计算前缀和，为后续计算提供便利再分别使用$dp1$，$dp2$，$dp3$记录不同个数的子数组元素的最大值，其转移方程分别为：<br>$$<br>dp1[i]=max{dp1[i-1],sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>$$<br>dp2[i]=max{dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>$$<br>dp3[i]=max{dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>但这样并不能记录下标输出答案，所以这里我采用了，三个flag数组，用于记录下标，具体见代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n        vector&lt;int&gt;flag1(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag3(n);\n        vector&lt;int&gt;sum(n+1,0);\n        vector&lt;int&gt;ans;\n        for(int i=0;i&lt;n;i++)\n        {\n            sum[i+1]+=nums[i]+sum[i];           \n        }\n        for(int i=k-1;i&lt;n;i++)\n        {\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            {\n                flag1[i]=flag1[i-1];\n            }\n            else\n            {\n                flag1[i]=i-k+1;\n            }\n        }\n        for(int i=2*k-1;i&lt;n;i++)\n        {\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            {\n                flag2[i]=flag2[i-1];\n            }\n            else\n            {\n                flag2[i]={flag1[i-k],i-k+1};\n            }\n        }\n        for(int i=3*k-1;i&lt;n;i++)\n        {\n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            {\n                flag3[i]=flag3[i-1];\n            }\n            else\n            {\n                flag3[i]={flag2[i-k].second,i-k+1};\n            }\n        }\n        return {flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second};\n    }\n};\n</code></pre>\n<p>xxxxxxxxxx&nbsp;class Solution {public: &nbsp; &nbsp;int maxResult(vector<int>&amp; nums, int k) { &nbsp; &nbsp; &nbsp; &nbsp;int n = nums.size(); &nbsp; &nbsp; &nbsp; &nbsp;vector<int> dp(n); &nbsp; &nbsp; &nbsp; &nbsp;dp[0] = nums[0]; &nbsp; &nbsp; &nbsp; &nbsp;priority_queue&lt;pair&lt;int, int&gt;&gt; q; &nbsp; &nbsp; &nbsp; &nbsp;q.emplace(nums[0], 0); &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt; n; ++i) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (i - q.top().second &gt; k) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;q.pop(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i] = q.top().first + nums[i]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;q.emplace(dp[i], i); &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;return dp[n - 1]; &nbsp;  }};cpp 优先级队列2</int></int></p>\n<p><img data-src=\"/../../../post_images/%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF.png\"></p>\n<p>观察报错信息，可知，在我的代码中，并未考虑<code>k==1</code>的情况，因为代码中我是通过<code>for(int i=k-1;i&lt;n;i++)</code>实现循环的，k-1 就会为 0，至于后面 i-1 造成错误</p>\n<p>改进代码:</p>\n<pre><code class=\"cpp\">if(k==1)                      // 考虑 k==1 的情况\n    {\n        vector&lt;int&gt;ans(3);\n        for(int i=0;i&lt;3;i++)\n        {\n            ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n        }\n        sort(ans.begin(),ans.end());\n        return ans;\n    }\n</code></pre>\n<p>再次提交，发现答案出错，如下:</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0.png\"></p>\n<p>在这并不能看出什么，为此，我进行了多组数据的尝试，发现第一个大部分都不符合答案，但后两个一直都是正确的，说明<code>flag1</code>求解过程无误，而是输出出错</p>\n<p>对此，进行代码分析，最后输出时，我写的是</p>\n<p><code>return {flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second};</code></p>\n<p><code>[flag2[flag3[n-1].first].first</code>，因为我在<code>flag3.first</code>存入的是<code>flag2</code>的索引的第二个元素，以此来得到<code>flag1</code>明显是不可行的，因为对应<code>flag1</code>的下标与<code>flag2</code>的第二个元素并无关系，<code>flag1[i-k]</code>可能是前一个继承来的，与<code>flag2</code>的第二个元素无关，也有可能与其有关，总之该方法不一定正确</p>\n<p>那么我做以下修改</p>\n<ol>\n<li>重新定义<code>flag3</code>数组类型，为<code>&lt;pair&lt;pair&lt;int,int&gt;，int&gt;&gt;</code></li>\n<li>存入<code>flag3</code>时存入<code>{flag2 [i-k],i-k+1}</code></li>\n<li>读取第一个使用<code>flag3[n-1].first.first</code>，第二个使用<code>flag3[n-1].first.second</code></li>\n</ol>\n<p>以下为修改后的代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        if(k==1)                      // 考虑 k==1 的情况\n        {\n            vector&lt;int&gt;ans(3);\n            for(int i=0;i&lt;3;i++)\n            {\n                ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n            }\n            sort(ans.begin(),ans.end());\n            return ans;\n        }\n        //dp [i] 表示 0 到该位置所能得到的 x 个无重叠数组和的最大值\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n        \n        //flag1 记录某一位置 1 个最大无重叠数组的下标       \n        vector&lt;int&gt;flag1(n);\n        \n        //flag2 记录某一位置 2 个最大无重叠数组的下标    \n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n        \n        //flag3 记录某一位置 3 个最大无重叠数组的下标                  \n        vector&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt;flag3(n);              \n        \n        //sum [i] 表示前 i 个数之和\n        vector&lt;int&gt;sum(n+1,0); \n        \n        for(int i=0;i&lt;n;i++)                       // 计算前缀和\n        {\n            sum[i+1]+=nums[i]+sum[i];           \n        }\n        \n        // 计算从 k-1 开始 1 个无重叠子数组最大的值，用 flag1 记录下标值\n        for(int i=k-1;i&lt;n;i++)                      \n        {\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            {\n                flag1[i]=flag1[i-1];\n            }\n            else\n            {\n                flag1[i]=i-k+1;\n            }\n        }\n        \n        // 计算从 2*k-1 开始 2 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=2*k-1;i&lt;n;i++)                   \n        {\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            {\n                flag2[i]=flag2[i-1];\n            }\n            else\n            {\n                flag2[i]={flag1[i-k],i-k+1};\n            }\n        }\n        \n        // 计算从 3*k-1 位置开始 3 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=3*k-1;i&lt;n;i++)                        \n        { \n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            {\n                flag3[i]=flag3[i-1];\n            }\n            else\n            {\n                flag3[i]={flag2[i-k],i-k+1};\n            }\n        }\n        \n        // 根据 flag3 找寻下标\n        return {flag3[n-1].first.first,flag3[n-1].first.second,flag3[n-1].second};   \n    }\n};\n</code></pre>\n<h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><p>维护<code>sum1</code>，<code>sum2</code>，<code>sum3</code>，分别表示<code>n</code>个子数组的最大值，若大于原来的更新下标(代码中为<code>sum1maxid,sum2maxid1,sum2maxid2</code>) 当数组个数大于等于k时，那么需删去首个元素，更新窗口</p>\n<p>以下为代码实现</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        int sum1=0,sum2=0,sum3=0;\n        int sum1max=0,sum2max=0,sum3max=0;\n        int sum1maxid,sum2maxid1,sum2maxid2;\n        vector&lt;int&gt;ans;\n        for(int i=2*k;i&lt;n;i++)\n        {\n            sum1+=nums[i-2*k];\n            sum2+=nums[i-k];\n            sum3+=nums[i];\n            if(i&gt;=3*k-1)\n            {\n                if(sum1&gt;sum1max)\n                {\n                    sum1max=sum1;\n                    sum1maxid=i-3*k+1;          // 更新 1 个子数组最大值下标\n                }\n                if(sum1max+sum2&gt;sum2max)\n                {\n                    sum2max=sum1max+sum2;\n                    sum2maxid1=sum1maxid;       // 更新两个子数组中 1 个子数组最大值下标\n                    sum2maxid2=i-2*k+1;         // 更新 1 个子数组最大值下标\n                }\n                if(sum2max+sum3&gt;sum3max)\n                {\n                    sum3max=sum2max+sum3;\n                    ans={sum2maxid1,sum2maxid2,i-k+1};  // 更新答案\n                }\n                sum1-=nums[i-3*k+1];             // 删去首个\n                sum2-=nums[i-2*k+1];             // 删去首个\n                sum3-=nums[i-k+1];               // 删去首个\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "前缀和",
                "动态规划",
                "滑动窗口"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/5beb97b2/",
            "url": "http://dpm12345.cn/posts/5beb97b2/",
            "title": "无重叠区间",
            "date_published": "2021-12-06T11:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy8=\">无重叠区间</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.png\"></p>\n<p>思路：在这道题中，我们可以把题目要求所解问题换一种说法，找删去最少区间使剩下成为无重叠区间，即包含区间最多数。</p>\n<p>我们注意到，当其为无重叠区间时，前一个区间的末端必然小于等于后一个区间首端，那么我们便可以将这一组的无重叠区间的端点看作为一组不严格单调递增的序列。这样便与求 “最长上升序列” 的序列的问题相同了。</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>我们维护一个数组$dp[i]$，其中$dp[i]$以该位置为末尾区间的，所能得到的数量最多的无重叠区间的值。那么很容易得到，先分别枚举末尾区间位置，再从0开始遍历，寻找最长，转移方程即为： $dp[i]=max(dp[j]+1,dp[i])$（当$intervals[j][1]&lt;intervals[i][0]$时)</p>\n<p>以下为代码:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        sort(intervals.begin(),intervals.end());\n        int n=intervals.size();\n        vector&lt;int&gt;dp(n,1);\n        for(int i=0;i&lt;intervals.size();i++)\n        {\n            for(int j=0;j&lt;i;j++)\n            {\n                if(intervals[j][1]&lt;=intervals[i][0])\n                {\n                    dp[i]=max(dp[j]+1,dp[i]);\n                }\n            }\n        }\n        return n-*max_element(dp.begin(),dp.end());\n\n    }\n};\n</code></pre>\n<p>提交后很不幸，超时了，时间复杂度为$O(n^2)$, 为此我们需要将时间优化。</p>\n<h1 id=\"贪心方案\"><a href=\"#贪心方案\" class=\"headerlink\" title=\"贪心方案\"></a>贪心方案</h1><p>上面的动态规划方案中，枚举末尾，再从0开始遍历，寻找最长，这是无法避免的，为此难以优化，这样，我们可以使用贪心方案，将时间复杂度降低 </p>\n<p>实现思想: 我们要想得到最多数量的无重叠区间，那么我们需要尽可能地将区间长度较小地放入这一无重叠区间内，因此我们可以设想，如果我们将各个区间地右端点按升序排序，设一个变量<code>right</code>为目前无重叠区间的右端点，如果下一个区间的左端大于<code>right</code>，区间加一，<code>right</code>更新，这样以此类推， 最终可以得到答案 </p>\n<p>证明：由于我们是将右端点降序排序，那么当两段区间相同时，实际上无论选择哪段结果都是一样的，因为不管该区间的左端点为多少，后面的区间只要左区间不大于<code>right</code>，那么该区间必会被删。而当之后区间的左端点大于<code>right</code>时，那么此时所选取的区间的右端点必然是满足条件的最小值，也因此能够得到最多数量的无重叠区间 </p>\n<p>以下为实现代码:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        if (intervals.empty()) {\n            return 0;\n        }\n        \n        sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) {\n            return u[1] &lt; v[1];\n        });\n\n        int n = intervals.size();\n        int right = intervals[0][1];\n        int ans = 1;\n        for (int i = 1; i &lt; n; ++i) {\n            if (intervals[i][0] &gt;= right) {\n                ++ans;\n                right = intervals[i][1];\n            }\n        }\n        return n - ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/6f1a75f/",
            "url": "http://dpm12345.cn/posts/6f1a75f/",
            "title": "跳跃游戏 VI",
            "date_published": "2021-12-05T06:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLXZpLw==\">跳跃游戏 VI</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/1696%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI.jpg\"></p>\n<h1 id=\"初期想法\"><a href=\"#初期想法\" class=\"headerlink\" title=\"初期想法\"></a>初期想法</h1><p>看到题目，很容易想到使用动态规划算法，$dp[i]$表示跳到位置$i$能取到的最大的值,其中$dp[i]=min{dp[i-1],dp[i-2]……,dp[i-k]}+nums[i]$, 那么很容易写出代码 如图</p>\n<p><img data-src=\"/../../../post_images/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI_%E5%88%9D%E5%A7%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png\"></p>\n<p>但是已提交便发现，超时了，也就是说纯纯动态规划不能完成题目要求。</p>\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>思考初期想法的代码，哪里造成了代码超时呢？</p>\n<p>不难发现，在确定$i$位置前的$[i-k,i-1]$范围内的最小值时，每一个都比较了一次，而当$i$加一时，除去上次的$i-k$，和新增的$i-1$，其他位置又比较了一次，如果最大值，即比较过后仍然比较，其原因是缺少记录最大值的渠道。那么是否可以在循环时加上一个变量MAX记录$[i-k,i-1]$的最大值，当$i+1$时，将MAX与$dp[i]$比较呢？</p>\n<p>其结果是只能解决一部分，因为假设$MAX=dp[i-k]$，当$i+1$时，MAX的值明显不在之后的$[i-k,i-1]$范围之内了，因此要将原来范围内的次大值与$dp[i]$比较，这样我们又多了个任务，求次大值，所以单纯增加一个变量并不能解决问题。</p>\n<p>下面为解决方案：</p>\n<h1 id=\"优化（单调队列）\"><a href=\"#优化（单调队列）\" class=\"headerlink\" title=\"优化（单调队列）\"></a>优化（单调队列）</h1><p>经过上面的分析，我们需要存储$[i-k,i-1]$内的最大值，同时要在最大值被删去时能快速得到之后的最大值那么，队列无非是我们的选择</p>\n<p>方法：为方便，我们将元素下标存入队列中队列内的元素按降序排序，即队首为最大元素的下标，队列第二个元素即为次大值循环时，首先先确保队首元素满足在下标$[i-k,i-1]$范围内，如不满足则删除队首，然后再进行$dp[i]$的计算$dp[i]=dp[q.front()]+nums[i]$，最后向队列中存入元素$dp[i]$（若$dp[i]&gt;dp[q.back()]$, 便可将队尾元素删除，直到$dp[i]&lt;=dp[q.back]$或队列为空），这样便为后面取最大值做准备。</p>\n<p>因此，代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        vector&lt;int&gt;dp(n);\n        dp[0]=nums[0];\n        deque&lt;int&gt;q;\n        q.push_back(0);\n        for(int i=1;i&lt;n;i++)\n        {\n            while(q.size()&amp;&amp;i-q.front()&gt;k)\n            {\n                q.pop_front();\n            }\n            dp[i]=dp[q.front()]+nums[i];\n            while(q.size()&amp;&amp;dp[i]&gt;dp[q.back()])\n            {\n                q.pop_back();\n            }\n            q.push_back(i);\n        }\n        return dp[n-1];\n    }\n};\n</code></pre>\n<h1 id=\"优化（优先级队列）\"><a href=\"#优化（优先级队列）\" class=\"headerlink\" title=\"优化（优先级队列）\"></a>优化（优先级队列）</h1><p>与单调队列思想相同，只是优先级队列不用进行排序</p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) {\n        int n = nums.size();\n        vector&lt;int&gt; dp(n);\n        dp[0] = nums[0];\n        priority_queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.emplace(nums[0], 0);\n        for (int i = 1; i &lt; n; ++i) {\n            while (i - q.top().second &gt; k) {\n                q.pop();\n            }\n            dp[i] = q.top().first + nums[i];\n            q.emplace(dp[i], i);\n        }\n        return dp[n - 1];\n    }\n};\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/ccc6bc8a/",
            "url": "http://dpm12345.cn/posts/ccc6bc8a/",
            "title": "下降路径最小和",
            "date_published": "2021-11-26T07:20:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1mYWxsaW5nLXBhdGgtc3VtLw==\">下降路径最小和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<p>思路：由题意知，到达某一位置只能有在上一行中与它纵坐标相差1内 的位置到达，那么显然这题使用动态规划 其转移方程在一般情况下，为<br>$$<br>dp[i][j] = {min(dp[i - 1][j], dp[i - 1][j - 1], dp[i - 1][j + 1]} + matrix[i][j];<br>$$<br>而当$i=0$，<br>$$<br>dp[i][j] = matrix[i][j];<br>$$<br>$j=0$<br>$$<br>dp[i][j] = {min(dp[i - 1][j], dp[i - 1][j + 1]} + matrix[i][j];<br>$$<br>$j = n - 1$<br>$$<br>dp[i][j] = {min(dp[i - 1][j], dp[i - 1][j - 1]} + matrix[i][j];<br>$$</p>\n<h1 id=\"原始\"><a href=\"#原始\" class=\"headerlink\" title=\"原始\"></a>原始</h1><pre><code class=\"cpp\">class Solution {\npublic:\n    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt;dp(m, vector&lt;int&gt;(n));\n        for (int i = 0; i&lt;m; i++)\n        {\n            for (int j = 0; j&lt;n; j++)\n            {\n                if (i == 0)\n                {\n                    dp[i][j] = matrix[i][j];\n                }\n                else if (j == 0)\n                {\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];\n                }\n                else if (j == n - 1)\n                {\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j];\n                }\n                else\n                {\n                    dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i - 1][j + 1])) + matrix[i][j];\n                }\n            }\n        }\n        return *min_element(dp[m - 1].begin(), dp[m - 1].end());\n\n    }\n};\n</code></pre>\n<h1 id=\"空间优化\"><a href=\"#空间优化\" class=\"headerlink\" title=\"空间优化\"></a>空间优化</h1><p>使用一个一维数组</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector&lt;int&gt;dp(n + 2);              // 确保每个位置都是 min {dp [i-1],dp [i],dp [i+1]};\n        int last;                        //last 记录上一个变换的 dp [i];\n        for (int i = 0; i&lt;m; i++)\n        {\n            dp[0] = dp[n + 1] = INT_MAX;\n            last = dp[0];\n            for (int j = 0; j&lt;n; j++)\n            {\n                int temp = dp[j + 1];\n                dp[j + 1] = min(last, min(dp[j + 1], dp[j + 2])) + matrix[i][j];             \n                // 由于把原来数组增加了两个位置，\n                // 所以记录 dp 时只需更新下标 1~n+1 的 dp 值\n                last = temp;\n            }\n        }\n        return *min_element(dp.begin(), dp.end());\n\n    }\n};\n</code></pre>\n",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/723dcd0c/",
            "url": "http://dpm12345.cn/posts/723dcd0c/",
            "title": "摆动序列",
            "date_published": "2021-11-26T02:20:40.000Z",
            "content_html": "<p>[题目链接:]{.orange}<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlLw==\">摆动序列</span></p>\n<p>[题目详情:]{.orange}</p>\n<p><img data-src=\"/../../../post_images/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"摆动序列_题目详情\"></p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"原始\"><a href=\"#原始\" class=\"headerlink\" title=\"原始\"></a>原始</h2><p>思路：关键点在于，当增添一个数成为摆动序列中的一个元素时，那么这个数要么小于，要么大于其前面的一个数 其大于或小于取决于前面一个数与再前面一个数之间的大小关系 就此，可利用动态规划的思想，分别用$up[i]$,$down[i]$记录前$i+1$个数的最长摆动序列。(其中$up[i]$记录末尾为上升的，$down[i]$记录下降的)     </p>\n<p>将题目解决方法转换为三方面：   </p>\n<ol>\n<li><p>当$nums[i]&lt;nums[i-1]$时，该元素不可添加到$up[i]$中，而对于$down[i]$，取$down[i-1]$(不加上该数),$up[i-1]+1$(加上该数)中的最大值，即<br>$$<br>down[i] = max{up[i-1]+1, down[i-1]}<br>$$</p>\n</li>\n<li><p>当$nums[i]&gt;nums[i-1]$时，该元素不可添加到$down[i]$中,而对于$up[i]$,取$up[i-1]$(不加上该数),$down[i-1]+1$(加上该数)中的最大值，即<br>$$<br>up[i] = max{up[i-1], down[i-1]+1}<br>$$</p>\n</li>\n<li><p>当$nums[i]=nums[i-1]$时，都不能加上,故<br>$$<br>up[i]=up[i-1]<br>$$</p>\n<p>$$<br>dowm[i]=down[i-1]<br>$$</p>\n</li>\n</ol>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n == 1) return n;\n        vector&lt;int&gt;up(n), down(n);\n        up[0] = down[0] = 1;\n        for (int i = 1; i&lt;n; i++)\n        {\n            if (nums[i]&lt;nums[i - 1])\n            {\n                up[i] = up[i - 1];\n                down[i] = max(down[i - 1], up[i - 1] + 1);\n            }\n            else if (nums[i]&gt;nums[i - 1])\n            {\n                up[i] = max(up[i - 1], down[i - 1] + 1);\n                down[i] = down[i - 1];\n            }\n            else\n            {\n                up[i] = up[i - 1];\n                down[i] = down[i - 1];\n            }\n        }\n        return max(up[n - 1], down[n - 1]);\n    }\n};\n</code></pre>\n<h3 id=\"动态规划的空间优化\"><a href=\"#动态规划的空间优化\" class=\"headerlink\" title=\"动态规划的空间优化\"></a>动态规划的空间优化</h3><p>由于$up[i]$,$down[i]$只与下标为$i-1$的值有关，那么可以用两个变量代替数组，最后取这两个变量的最大值</p>\n<p>优化代码如下:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n == 1) return n;\n        int up = 1, down = 1;\n        for (int i = 1; i&lt;n; i++)\n        {\n            if (nums[i]&lt;nums[i - 1])\n            {\n                down = max(down, up + 1);\n            }\n            else if (nums[i]&gt;nums[i - 1])\n            {\n                up = max(up, down + 1);\n            }\n        }\n        return max(up, down);\n    }\n};\n</code></pre>\n<h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><p>代码如下:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n &lt; 2) {\n            return n;\n        }\n        int prevdiff = nums[1] - nums[0];\n        int num = prevdiff != 0 ? 2 : 1;\n        for (int i = 2; i &lt; n; i++) {\n            int diff = nums[i] - nums[i - 1];\n            if ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) {\n                num++;\n                prevdiff = diff;\n            }\n        }\n        return num;\n    }\n};\n</code></pre>\n<p>一开始本身的疑点：其代码行只要有<code>(diff&gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)</code>情况出现，则<code>num++</code>,<br>不会导致因为所选数不是最佳方案而造成答案错误吗？<br>// 经过思考：正因为代码段</p>\n<pre><code class=\"cpp\">int diff = nums[i] - nums[i - 1];\nif ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) {\n    num++;\n    prevdiff = diff;\n}\n</code></pre>\n<p>每次都会更新diff的值，也就是说每次都会更新“峰”或“谷”的值，从而使得为最佳方案</p>\n",
            "tags": [
                "动态规划",
                "贪心"
            ]
        }
    ]
}