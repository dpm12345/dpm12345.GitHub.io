{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"数据结构\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/e85d694a/",
            "url": "http://dpm12345.cn/posts/e85d694a/",
            "title": "二叉树",
            "date_published": "2022-02-20T12:07:26.000Z",
            "content_html": "<h1 id=\"树的相关定义\"><a href=\"#树的相关定义\" class=\"headerlink\" title=\"树的相关定义\"></a>树的相关定义</h1><p>![](../../../post_images/树.jpeg “树”)</p>\n<ul>\n<li>组成：树由若干个节点构成，根节点在最上方，如图 1 为根节点</li>\n<li>度：节点下方延申的部分称为子树，其个数被称为度，如图 2，3，4，5 为 1 的度，个数为 4叶子节点和分支节点：度为$0$ 的节点被称为</li>\n<li>叶子节点或终端节点，不为$0$ 被称为非终端节点或分支节点，如 13 为叶子节点，3 为分支节点</li>\n<li>父节点：若一个节点含有子节点，那么称为该子节点的父节点，如 6 为 13 的父节点</li>\n<li>兄弟节点：具有相同父节点的节点互称为兄弟节点，如 2，3，4，5</li>\n<li>树的度：一棵树中，最大的节点的度称为树的度</li>\n<li>节点点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；树的高度或深度：树中节点的最大层次，如图为 4</li>\n<li>节点的祖先：从根到该节点所经分支上的所有节点；如上图：1 是所有节点的祖先</li>\n<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是 1 的子孙</li>\n</ul>\n<h1 id=\"二叉树的定义\"><a href=\"#二叉树的定义\" class=\"headerlink\" title=\"二叉树的定义\"></a>二叉树的定义</h1><p>只有两个子树</p>\n<p>基本组成形式为 节点 + 左子树 + 右子树 </p>\n<p>如图:</p>\n<p><img data-src=\"/../../../post_images/%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg\" title=\"二叉树\"></p>\n<h1 id=\"特殊的二叉树\"><a href=\"#特殊的二叉树\" class=\"headerlink\" title=\"特殊的二叉树\"></a>特殊的二叉树</h1><p>**满二叉树:**一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为$K$，且结点总数是$2^k-1$，则它就是满二叉树。</p>\n<p>**完全二叉树:**完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为$K$的，有$n$个结点的二叉树，当且仅当其每一个结点都与深度为$K$的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。要注意的是满二叉树是一种特殊的完全二叉树。</p>\n<p>![](../../../post_images/满二叉树.png “满二叉树”)</p>\n<h1 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h1><ul>\n<li>若规定根节点的层数为$1$，则一棵非空二叉树的第$i$层上最多有$2^{i-1}$个结点.</li>\n<li>若规定根节点的层数为$1$，则深度为h的二叉树的最大结点数是$2^h-1$.</li>\n<li>对任何一棵二叉树，如果度为$0$其叶结点个数为$n_0$, 度为2的分支结点个数为$n_2$, 则有$n_0＝n_2+1$</li>\n<li>若规定根节点的层数为$1$，具有$n$个结点的满二叉树的深度，$h=LogN$</li>\n</ul>\n<h1 id=\"二叉树的实现形式\"><a href=\"#二叉树的实现形式\" class=\"headerlink\" title=\"二叉树的实现形式\"></a>二叉树的实现形式</h1><h2 id=\"顺序形式\"><a href=\"#顺序形式\" class=\"headerlink\" title=\"顺序形式\"></a>顺序形式</h2><p>采用数组的方式，一个存放一个节点，可能会存在空，大小需要变化</p>\n<p>采用该种方式构建的完全二叉树</p>\n<p>性质</p>\n<ul>\n<li>左子树根节点 $leftchild=parent*2+1$</li>\n<li>右子树根节点 $leftchild=parent*2+1$</li>\n<li>根节点 $parent=(child-1)/2$</li>\n</ul>\n<h2 id=\"链式形式\"><a href=\"#链式形式\" class=\"headerlink\" title=\"链式形式\"></a>链式形式</h2><p>可以定义出每一个节点，用地址进行链接</p>\n<h3 id=\"二叉树的链式实现及相关遍历\"><a href=\"#二叉树的链式实现及相关遍历\" class=\"headerlink\" title=\"二叉树的链式实现及相关遍历\"></a>二叉树的链式实现及相关遍历</h3><h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>代码如下</p>\n<pre><code class=\"c++\">//tree.h\n#ifndef TREE_H\n#define TREE_H\n\n// 每个结点的定义\ntemplate&lt;class T&gt;\nclass RNode{\npublic:\n    T data;\n    class RNode&lt;T&gt; * lNode;\n    class RNode&lt;T&gt; * rNode;\n};\n\n#endif\n\n//tree.c\nvoid test1()\n{\n    //A\n    RNode&lt;int&gt;* A = new RNode&lt;int&gt;;\n    A-&gt;data = 5;\n    A-&gt;lNode = nullptr;\n    A-&gt;rNode = nullptr;\n    //B\n    RNode&lt;int&gt;* B = new RNode&lt;int&gt;;\n    B-&gt;data = 3;\n    B-&gt;lNode = nullptr;\n    B-&gt;rNode = nullptr;\n    //C\n    RNode&lt;int&gt;* C = new RNode&lt;int&gt;;\n    C-&gt;data = 4;\n    C-&gt;lNode = nullptr;\n    C-&gt;rNode = nullptr;\n    //D\n    RNode&lt;int&gt;* D = new RNode&lt;int&gt;;\n    D-&gt;data = 7;\n    D-&gt;lNode = nullptr;\n    D-&gt;rNode = nullptr;\n    //E\n    RNode&lt;int&gt;* E = new RNode&lt;int&gt;;\n    E-&gt;data = 12;\n    E-&gt;lNode = nullptr;\n    E-&gt;rNode = nullptr;\n\n    // 建立联系\n    A-&gt;lNode = B;\n    A-&gt;rNode = C;\n    B-&gt;lNode = D;\n    C-&gt;rNode = E;\n}\n</code></pre>\n<h4 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h4><h5 id=\"前序\"><a href=\"#前序\" class=\"headerlink\" title=\"前序\"></a>前序</h5><p>根 –&gt; 左子树 –&gt; 右子树</p>\n<p>leetcode相关链接: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==\">二叉树的前序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"c++\">void PrevOrder(RNode&lt;int&gt;* P)\n{\n    if (P == nullptr)\n    {\n        cout &lt;&lt; \"NULL \";\n        return;\n    }\n    cout &lt;&lt; P-&gt;data &lt;&lt; \" \";\n    PrevOrder(P-&gt;lNode);\n    PrevOrder(P-&gt;rNode);\n}\n</code></pre>\n<p>附上 leetcode 上的迭代写法</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;ans;\n        if(root==nullptr)\n            return ans;\n        \n        stack&lt;TreeNode*&gt;record;\n        TreeNode* node=root;\n        while(!record.empty()||node!=nullptr)\n        {\n            while(node!=nullptr)\n            {\n                ans.push_back(node-&gt;val);\n                record.push(node);\n                node=node-&gt;left;\n            }\n            node=record.top();\n            record.pop();\n            node=node-&gt;right;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h5 id=\"中序\"><a href=\"#中序\" class=\"headerlink\" title=\"中序\"></a>中序</h5><p>左子树 –&gt; 根 –&gt; 右子树</p>\n<p>leetcode相关链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv\">二叉树的中序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"c++\">void MidOrder(RNode&lt;int&gt;* P)\n{\n    if (P == nullptr)\n    {\n        cout &lt;&lt; \"NULL \";\n        return;\n    }\n    MidOrder(P-&gt;lNode);\n    cout &lt;&lt; P-&gt;data &lt;&lt; \" \";\n    MidOrder(P-&gt;rNode);\n}\n</code></pre>\n<p>附上leetcode上的迭代写法</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) {\n        vector&lt;int&gt;ans;\n        if(root==nullptr)\n            return ans;\n        stack&lt;TreeNode*&gt;re;\n        TreeNode* node=root;\n        while(!re.empty()||node!=nullptr)\n        {\n            while(node!=nullptr)\n            {\n                re.push(node);\n                node=node-&gt;left;\n            }\n            node=re.top();\n            ans.push_back(node-&gt;val);\n            re.pop();\n            node=node-&gt;right;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h5 id=\"后序\"><a href=\"#后序\" class=\"headerlink\" title=\"后序\"></a>后序</h5><p>左子树 –&gt;右子树 –&gt;根</p>\n<p>leetcode 相关链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==\">二叉树的后序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"c++\">void LastOrder(RNode&lt;int&gt;* P)\n{\n    if (P == nullptr)\n    {\n        cout &lt;&lt; \"NULL \";\n        return;\n    }\n    LastOrder(P-&gt;lNode);\n    LastOrder(P-&gt;rNode);\n    cout &lt;&lt; P-&gt;data &lt;&lt; \" \";\n}\n</code></pre>\n<p>附上leetcode上的迭代写法</p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode *root) {\n        vector&lt;int&gt; res;\n        if (root == nullptr) {\n            return res;\n        }\n\n        stack&lt;TreeNode *&gt; stk;\n        TreeNode *prev = nullptr;\n        while (root != nullptr || !stk.empty()) {\n            while (root != nullptr) {\n                stk.emplace(root);\n                root = root-&gt;left;\n            }\n            root = stk.top();\n            stk.pop();\n            if (root-&gt;right == nullptr || root-&gt;right == prev) {\n                res.emplace_back(root-&gt;val);\n                prev = root;\n                root = nullptr;\n            } else {\n                stk.emplace(root);\n                root = root-&gt;right;\n            }\n        }\n        return res;\n    }\n};\n</code></pre>\n<p>相关解释</p>\n<p>为了实现这一顺序，该方法中</p>\n<ol>\n<li><p>由于左子树始终首先输出，那么依旧存入所有的左子树结点</p>\n</li>\n<li><p>为了防止根先于右子树输出，在该方法中，使用了<code>prev</code>这一变量，代表的是前一个右子树，只有当右子树为空或者右子树之前输出过了才可以输入<code>root</code>的内容，而为了先输出右子树的内容，会将右子树的根节点存入栈中，并指向该节点的右子树</p>\n</li>\n<li><p>然后再判断上面的指向是否为存在子树(即进入while循环判断，如果有，那么继续深入)</p>\n</li>\n<li><p>之后按照正常输出即可</p>\n</li>\n</ol>\n<h1 id=\"其他相关题目\"><a href=\"#其他相关题目\" class=\"headerlink\" title=\"其他相关题目\"></a>其他相关题目</h1><ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=\">二叉树的最大深度</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv\">平衡二叉树</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==\">二叉树的层序遍历</span></li>\n</ol>\n",
            "tags": [
                "树",
                "二叉树",
                "数据结构"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/3140d327/",
            "url": "http://dpm12345.cn/posts/3140d327/",
            "title": "队列实现",
            "date_published": "2022-01-04T02:07:26.000Z",
            "content_html": "<h1 id=\"队列的实现\"><a href=\"#队列的实现\" class=\"headerlink\" title=\"队列的实现\"></a>队列的实现</h1><p>该实现使用的是C++的函数模板</p>\n<h2 id=\"队列的特点\"><a href=\"#队列的特点\" class=\"headerlink\" title=\"队列的特点\"></a>队列的特点</h2><p>与栈有些许类似，将数据放入队列中时，放入的位置是队尾，但弹出$pop()$ 操作时，是将队头元素删去，并且队列可以通过$[$ $]$来访问数据，故可知实现的函数功能有以下:</p>\n<ul>\n<li><p>void push(T val); // 入队</p>\n</li>\n<li><p>void pop(); // 出队</p>\n</li>\n<li><p>T back(); // 返回队尾元素</p>\n</li>\n<li><p>T front(); // 返回队首元素</p>\n</li>\n<li><p>void operator=(const Queue<t>&amp; q); // 重载 = 运算符</t></p>\n</li>\n<li><p>void print(); // 打印队列</p>\n</li>\n<li><p>bool empty(); // 判断是否为空</p>\n</li>\n<li><p>int size(); // 返回队列大小</p>\n</li>\n</ul>\n<h2 id=\"实现之前的思考\"><a href=\"#实现之前的思考\" class=\"headerlink\" title=\"实现之前的思考\"></a>实现之前的思考</h2><p>由上面的实现功能列表，可以清楚此时队列中的元素增删分别是在尾部和头部来进行的 如果存储数据的是数组，增加数据时还好，可以直接添加，如果是删去元素，那么为了确保队列前面都有人存在(不为循环队列), 必须分别将各个元素慢慢地向前挪，效率较慢。注意到队列的增删操作与链表的尾插和头删相同，而链表的尾插和头删比较简单，因此 此实现采用链表来存储数据</p>\n<h2 id=\"结点构造\"><a href=\"#结点构造\" class=\"headerlink\" title=\"结点构造\"></a>结点构造</h2><p>由于采用的是链表来存储数据，所以直接按照链表格式创建结点即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nstruct node{\n    T data;\n    node&lt;T&gt;* next;\n};\n</code></pre>\n<h2 id=\"Queue-类\"><a href=\"#Queue-类\" class=\"headerlink\" title=\"Queue 类\"></a>Queue 类</h2><h3 id=\"函数成员\"><a href=\"#函数成员\" class=\"headerlink\" title=\"函数成员\"></a>函数成员</h3><p>在队列的实现中，我们要进行头删，尾插，并且可以通过$[$ $]$来访问数据，故需要的数据分别为头结点地址、尾结点地址(方便进行尾插)、链表的元素个数</p>\n<p>而函数成员即为实现功能所列</p>\n<p>所以整体结构为：</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nclass Queue{\nprivate:\n    node&lt;T&gt;* head;         // 头结点\n    node&lt;T&gt;* tail;         // 尾结点\n    int num;\npublic:\n    Queue();                              // 无参构造函数\n    Queue(T val);                         // 有参构造函数\n    ~Queue();                             // 析构函数\n    Queue(const Queue&lt;T&gt;&amp; q);             // 复制构造函数\n    void push(T val);                     // 入队\n    void pop();                           // 出队\n    T back();                             // 返回队尾元素\n    T front();                            // 返回队首元素\n    void operator =(const Queue&lt;T&gt;&amp; q);   // 重载 = 运算符\n    void print();                         // 打印队列\n    bool empty();                         // 判断是否为空\n    int size();                           // 返回队列大小\n\n};\n</code></pre>\n<h3 id=\"成员函数实现\"><a href=\"#成员函数实现\" class=\"headerlink\" title=\"成员函数实现\"></a>成员函数实现</h3><h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>在上面，拟定为两种构造函数形式，无参和有参，两种方式做的工作一样，目的是对数据进行初始化。</p>\n<p>如果是无参，$head$和$tail$都应指向空，而$num=0$, 如果是有参，那么新建一个结点后，$head$ 和$tail$ 都指向它，$num=1$</p>\n<p>由于涉及指针，故需要深复制，重写复制构造函数</p>\n<p>以下为实现代码：</p>\n<pre><code class=\"c++\">// 无参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue()\n{\n    head = tail = nullptr;\n    num = 0;\n}\n\n// 有参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    head = tail = newnode;\n    num = 1;\n}\n\n// 复制构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(const Queue&lt;T&gt;&amp; q)\n{\n    node&lt;T&gt;*newp = q.head;\n    while (newp!= nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n\n}\n</code></pre>\n<h4 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h4><p>由于存储数据申请了空间，那么析构函数应当执行释放内存操作</p>\n<p>代码如下：</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nQueue&lt;T&gt;::~Queue()\n{\n    while (head != nullptr)\n    {\n        node&lt;T&gt;* temp = head;\n        head = head-&gt;next;\n        delete temp;\n    }\n    tail = nullptr;\n    num = 0;\n}\n</code></pre>\n<h4 id=\"push-T-val\"><a href=\"#push-T-val\" class=\"headerlink\" title=\"push(T val)\"></a>push(T val)</h4><p>由于$push_back()$即为链表中的尾插，那么只需创建新的结点，存储数值，之后使当前$tail$的$next$指向该结点，最后$tail$指向该结点即可。需要注意的是，如果队列中无元素，那么直接将$head$和$tail$指向该结点即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::push(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    if (head == nullptr)        // 无元素，或者可以写成 tail==nullptr 或 num==0\n    {\n        head = tail = newnode;\n        num = 1;\n    }\n    else\n    {\n        tail-&gt;next = newnode;\n        tail = tail-&gt;next;\n        num++;\n    }\n}\n</code></pre>\n<h4 id=\"pop\"><a href=\"#pop\" class=\"headerlink\" title=\"pop()\"></a>pop()</h4><p>所做的操作为头删</p>\n<p>在删之前，我们必须考虑队列为空的情况，因此可以使用$assert()$进行判断报错</p>\n<p>当队列中有元素时，删去头结点，那么可以先创建一个结点指针指向头结点，在删去头结点后再令<code>head=head-&gt;next</code>，<code>num--</code></p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::pop()\n{\n    assert(head);\n    node&lt;T&gt;*temp = head;\n    head = head-&gt;next;\n    delete temp;     // 删去 head 也可以，只不过上面的 head 赋值需换到下面写成 head=temp-&gt;next;\n    num--;\n}\n</code></pre>\n<h4 id=\"back\"><a href=\"#back\" class=\"headerlink\" title=\"back()\"></a>back()</h4><p>返回队尾元素，直接使用$tail$指针即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nT Queue&lt;T&gt;::back()\n{\n    return tail-&gt;data;\n}\n</code></pre>\n<h4 id=\"front\"><a href=\"#front\" class=\"headerlink\" title=\"front()\"></a>front()</h4><p>返回队首元素，直接使用$head$指针即可</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nT Queue&lt;T&gt;::front()\n{\n    return head-&gt;data;\n}\n</code></pre>\n<h4 id=\"operator-x3D-const-Queue-amp-q\"><a href=\"#operator-x3D-const-Queue-amp-q\" class=\"headerlink\" title=\"operator=(const Queue&amp;q)\"></a>operator=(const Queue<t>&amp;q)</t></h4><p>与复制构造函数类似，但这里需要判断原Queue对象是否已经有队列元素</p>\n<pre><code class=\"c++\">// 重载 = 运算符\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::operator =(const Queue&lt;T&gt;&amp; q)\n{\n    if (head)             // 如果存在队列\n    {\n        this-&gt;~Queue();\n    }\n    node&lt;T&gt;*newp = q.head;\n    while (newp != nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n}\n</code></pre>\n<h4 id=\"print\"><a href=\"#print\" class=\"headerlink\" title=\"print()\"></a>print()</h4><p>即遍历链表，打印队列</p>\n<p>较为简单，直接上代码:</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::print()\n{\n    node&lt;T&gt;* temp = head;\n    while (temp != nullptr)\n    {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \"  \";\n        temp = temp-&gt;next;\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre>\n<h4 id=\"empty\"><a href=\"#empty\" class=\"headerlink\" title=\"empty()\"></a>empty()</h4><p>判断是否为空，即可判断$n==0?$</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nbool Queue&lt;T&gt;::empty()\n{\n    return num == 0;\n}\n</code></pre>\n<h4 id=\"size\"><a href=\"#size\" class=\"headerlink\" title=\"size()\"></a>size()</h4><p>返回队列大小，即为$num$的值</p>\n<pre><code class=\"c++\">template&lt;class T&gt;\nint Queue&lt;T&gt;::size()\n{\n    return num;\n}\n</code></pre>\n<h1 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h1><pre><code class=\"c++\">//#ifndef  _QUEUE_H\n//#define  _QUEUE_H\n\n#include&lt;assert.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nstruct node{\n    T data;\n    node&lt;T&gt;* next;\n};\n\n\ntemplate&lt;class T&gt;\nclass Queue{\nprivate:\n    node&lt;T&gt;* head;         // 头结点\n    node&lt;T&gt;* tail;         // 尾结点\n    int num;\npublic:\n    Queue();                              // 无参构造函数\n    Queue(T val);                         // 有参构造函数\n    ~Queue();                             // 析构函数\n    Queue(const Queue&lt;T&gt;&amp; q);             // 复制构造函数\n    void push(T val);                     // 入队\n    void pop();                           // 出队\n    T back();                             // 返回队尾元素\n    T front();                            // 返回队首元素\n    void operator =(const Queue&lt;T&gt;&amp; q);   // 重载 = 运算符\n    void print();                         // 打印队列\n    bool empty();                         // 判断是否为空\n    int size();                           // 返回队列大小\n\n};\n\n// 无参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue()\n{\n    head = tail = nullptr;\n    num = 0;\n}\n\n// 有参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    head = tail = newnode;\n    num = 1;\n}\n\n// 析构函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::~Queue()\n{\n    while (head != nullptr)\n    {\n        node&lt;T&gt;* temp = head;\n        head = head-&gt;next;\n        delete temp;\n    }\n    tail = nullptr;\n    num = 0;\n}\n\n// 复制构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(const Queue&lt;T&gt;&amp; q)\n{\n    node&lt;T&gt;*newp = q.head;\n    while (newp!= nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n\n}\n\n// 入队 (尾插)\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::push(T val)\n{\n    node&lt;T&gt;* newnode = new node&lt;T&gt;;\n    newnode-&gt;data = val;\n    newnode-&gt;next = nullptr;\n    if (head == nullptr)\n    {\n        head = tail = newnode;\n        num = 1;\n    }\n    else\n    {\n        tail-&gt;next = newnode;\n        tail = tail-&gt;next;\n        num++;\n    }\n}\n\n// 出队 (头删)\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::pop()\n{\n    assert(head);\n    node&lt;T&gt;*temp = head;\n    head = head-&gt;next;\n    delete temp;\n    num--;\n}\n\n// 返回队尾元素\ntemplate&lt;class T&gt;\nT Queue&lt;T&gt;::back()\n{\n    return tail-&gt;data;\n}\n\n// 返回队首元素\ntemplate&lt;class T&gt;\nT Queue&lt;T&gt;::front()\n{\n    return head-&gt;data;\n}\n\n// 重载 = 运算符\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::operator =(const Queue&lt;T&gt;&amp; q)\n{\n    if (head)\n    {\n        this-&gt;~Queue();\n    }\n    node&lt;T&gt;*newp = q.head;\n    while (newp != nullptr)\n    {\n        node&lt;T&gt;* newnode = new node&lt;T&gt;;\n        newnode-&gt;data = newp-&gt;data;\n        newnode-&gt;next = nullptr;\n        if (head == nullptr)\n        {\n            head = tail = newnode;\n            num = 1;\n        }\n        else\n        {\n            tail-&gt;next = newnode;\n            tail = tail-&gt;next;\n            num++;\n        }\n        newp = newp-&gt;next;\n    }\n}\n\n// 打印队列\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::print()\n{\n    node&lt;T&gt;* temp = head;\n    while (temp != nullptr)\n    {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \"  \";\n        temp = temp-&gt;next;\n    }\n    cout &lt;&lt; endl;\n}\n\n// 判断队列是否为空\ntemplate&lt;class T&gt;\nbool Queue&lt;T&gt;::empty()\n{\n    return num == 0;\n}\n\n// 返回队列大小\ntemplate&lt;class T&gt;\nint Queue&lt;T&gt;::size()\n{\n    return num;\n}\n//#endif\n</code></pre>\n",
            "tags": [
                "数据结构",
                "队列"
            ]
        }
    ]
}