{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"数据结构\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.github.io",
    "items": [
        {
            "id": "http://dpm12345.github.io/posts/e85d694a/",
            "url": "http://dpm12345.github.io/posts/e85d694a/",
            "title": "二叉树",
            "date_published": "2022-02-20T12:07:26.000Z",
            "content_html": "<h1 id=\"树的相关定义\"><a class=\"anchor\" href=\"#树的相关定义\">#</a> 树的相关定义</h1>\n<p>![](/ 素材 / 树.jpeg “树”)</p>\n<ul>\n<li>组成：树由若干个节点构成，根节点在最上方，如图 1 为根节点</li>\n<li>度：节点下方延申的部分称为子树，其个数被称为度，如图 2，3，4，5 为 1 的度，个数为 4 叶子节点和分支节点：度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 的节点被称为</li>\n<li>叶子节点或终端节点，不为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 被称为非终端节点或分支节点，如 13 为叶子节点，3 为分支节点</li>\n<li>父节点：若一个节点含有子节点，那么称为该子节点的父节点，如 6 为 13 的父节点</li>\n<li>兄弟节点：具有相同父节点的节点互称为兄弟节点，如 2，3，4，5</li>\n<li>树的度：一棵树中，最大的节点的度称为树的度</li>\n<li>节点点的层次：从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推；树的高度或深度：树中节点的最大层次，如图为 4</li>\n<li>节点的祖先：从根到该节点所经分支上的所有节点；如上图：1 是所有节点的祖先</li>\n<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。如上图：所有节点都是 1 的子孙</li>\n</ul>\n<h1 id=\"二叉树的定义\"><a class=\"anchor\" href=\"#二叉树的定义\">#</a> 二叉树的定义</h1>\n<p>只有两个子树</p>\n<p>基本组成形式为 节点 + 左子树 + 右子树</p>\n<p>如图:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%BA%8C%E5%8F%89%E6%A0%91.jpeg\" alt=\"\" title=\"二叉树\" /></p>\n<h1 id=\"特殊的二叉树\"><a class=\"anchor\" href=\"#特殊的二叉树\">#</a> 特殊的二叉树</h1>\n<p>** 满二叉树:** 一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span>，且结点总数是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^k-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.932438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，则它就是满二叉树。</p>\n<p>** 完全二叉树:** 完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 的，有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个结点的二叉树，当且仅当其每一个结点都与深度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 的满二叉树中编号从 1 至 n 的结点一一对应时称之为完全二叉树。要注意的是满二叉树是一种特殊的完全二叉树。</p>\n<p>![](/ 素材 / 满二叉树.png “满二叉树”)</p>\n<h1 id=\"二叉树的性质\"><a class=\"anchor\" href=\"#二叉树的性质\">#</a> 二叉树的性质</h1>\n<ul>\n<li>若规定根节点的层数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，则一棵非空二叉树的第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 层上最多有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">2^{i-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.824664em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点.</li>\n<li>若规定根节点的层数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，则深度为 h 的二叉树的最大结点数是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^h-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.932438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">h</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>.</li>\n<li>对任何一棵二叉树，如果度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 其叶结点个数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, 度为 2 的分支结点个数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">n_2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>, 则有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mtext>＝</mtext><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n_0＝n_2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">＝</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n<li>若规定根节点的层数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，具有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个结点的满二叉树的深度，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mo>=</mo><mi>L</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">h=LogN</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></li>\n</ul>\n<h1 id=\"二叉树的实现形式\"><a class=\"anchor\" href=\"#二叉树的实现形式\">#</a> 二叉树的实现形式</h1>\n<h2 id=\"顺序形式\"><a class=\"anchor\" href=\"#顺序形式\">#</a> 顺序形式</h2>\n<p>采用数组的方式，一个存放一个节点，可能会存在空，大小需要变化</p>\n<p>采用该种方式构建的完全二叉树</p>\n<p>性质</p>\n<ul>\n<li>左子树根节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo>=</mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">leftchild=parent*2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n<li>右子树根节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo>=</mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">leftchild=parent*2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n<li>根节点 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">parent=(child-1)/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80952em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span></span></span></span></li>\n</ul>\n<h2 id=\"链式形式\"><a class=\"anchor\" href=\"#链式形式\">#</a> 链式形式</h2>\n<p>可以定义出每一个节点，用地址进行链接</p>\n<h3 id=\"二叉树的链式实现及相关遍历\"><a class=\"anchor\" href=\"#二叉树的链式实现及相关遍历\">#</a> 二叉树的链式实现及相关遍历</h3>\n<h4 id=\"实现\"><a class=\"anchor\" href=\"#实现\">#</a> 实现</h4>\n<p>代码如下</p>\n<pre><code class=\"language-c++\">//tree.h\n#ifndef TREE_H\n#define TREE_H\n\n// 每个结点的定义\ntemplate&lt;class T&gt;\nclass RNode&#123;\npublic:\n\tT data;\n\tclass RNode&lt;T&gt; * lNode;\n\tclass RNode&lt;T&gt; * rNode;\n&#125;;\n\n#endif\n\n//tree.c\nvoid test1()\n&#123;\n\t//A\n\tRNode&lt;int&gt;* A = new RNode&lt;int&gt;;\n\tA-&gt;data = 5;\n\tA-&gt;lNode = nullptr;\n\tA-&gt;rNode = nullptr;\n\t//B\n\tRNode&lt;int&gt;* B = new RNode&lt;int&gt;;\n\tB-&gt;data = 3;\n\tB-&gt;lNode = nullptr;\n\tB-&gt;rNode = nullptr;\n\t//C\n\tRNode&lt;int&gt;* C = new RNode&lt;int&gt;;\n\tC-&gt;data = 4;\n\tC-&gt;lNode = nullptr;\n\tC-&gt;rNode = nullptr;\n\t//D\n\tRNode&lt;int&gt;* D = new RNode&lt;int&gt;;\n\tD-&gt;data = 7;\n\tD-&gt;lNode = nullptr;\n\tD-&gt;rNode = nullptr;\n\t//E\n\tRNode&lt;int&gt;* E = new RNode&lt;int&gt;;\n\tE-&gt;data = 12;\n\tE-&gt;lNode = nullptr;\n\tE-&gt;rNode = nullptr;\n\n\t// 建立联系\n\tA-&gt;lNode = B;\n\tA-&gt;rNode = C;\n\tB-&gt;lNode = D;\n\tC-&gt;rNode = E;\n&#125;\n</code></pre>\n<h4 id=\"遍历\"><a class=\"anchor\" href=\"#遍历\">#</a> 遍历</h4>\n<h5 id=\"前序\"><a class=\"anchor\" href=\"#前序\">#</a> 前序</h5>\n<p>根 --&gt; 左子树 --&gt; 右子树</p>\n<p>leetcode 相关链接: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==\">二叉树的前序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"language-c++\">void PrevOrder(RNode&lt;int&gt;* P)\n&#123;\n\tif (P == nullptr)\n\t&#123;\n\t\tcout &lt;&lt; &quot;NULL &quot;;\n\t\treturn;\n\t&#125;\n\tcout &lt;&lt; P-&gt;data &lt;&lt; &quot; &quot;;\n\tPrevOrder(P-&gt;lNode);\n\tPrevOrder(P-&gt;rNode);\n&#125;\n</code></pre>\n<p>附上 leetcode 上的迭代写法</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt;ans;\n        if(root==nullptr)\n            return ans;\n        \n        stack&lt;TreeNode*&gt;record;\n        TreeNode* node=root;\n        while(!record.empty()||node!=nullptr)\n        &#123;\n            while(node!=nullptr)\n            &#123;\n                ans.push_back(node-&gt;val);\n                record.push(node);\n                node=node-&gt;left;\n            &#125;\n            node=record.top();\n            record.pop();\n            node=node-&gt;right;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h5 id=\"中序\"><a class=\"anchor\" href=\"#中序\">#</a> 中序</h5>\n<p>左子树 --&gt; 根 --&gt; 右子树</p>\n<p>leetcode 相关链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtaW5vcmRlci10cmF2ZXJzYWwv\"> 二叉树的中序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"language-c++\">void MidOrder(RNode&lt;int&gt;* P)\n&#123;\n\tif (P == nullptr)\n\t&#123;\n\t\tcout &lt;&lt; &quot;NULL &quot;;\n\t\treturn;\n\t&#125;\n\tMidOrder(P-&gt;lNode);\n\tcout &lt;&lt; P-&gt;data &lt;&lt; &quot; &quot;;\n\tMidOrder(P-&gt;rNode);\n&#125;\n</code></pre>\n<p>附上 leetcode 上的迭代写法</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;\n        vector&lt;int&gt;ans;\n        if(root==nullptr)\n            return ans;\n        stack&lt;TreeNode*&gt;re;\n        TreeNode* node=root;\n        while(!re.empty()||node!=nullptr)\n        &#123;\n            while(node!=nullptr)\n            &#123;\n                re.push(node);\n                node=node-&gt;left;\n            &#125;\n            node=re.top();\n            ans.push_back(node-&gt;val);\n            re.pop();\n            node=node-&gt;right;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h5 id=\"后序\"><a class=\"anchor\" href=\"#后序\">#</a> 后序</h5>\n<p>左子树 --&gt; 右子树 --&gt; 根</p>\n<p>leetcode 相关链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcHJlb3JkZXItdHJhdmVyc2FsLw==\"> 二叉树的后序遍历</span></p>\n<p>代码</p>\n<pre><code class=\"language-c++\">void LastOrder(RNode&lt;int&gt;* P)\n&#123;\n\tif (P == nullptr)\n\t&#123;\n\t\tcout &lt;&lt; &quot;NULL &quot;;\n\t\treturn;\n\t&#125;\n\tLastOrder(P-&gt;lNode);\n\tLastOrder(P-&gt;rNode);\n\tcout &lt;&lt; P-&gt;data &lt;&lt; &quot; &quot;;\n&#125;\n</code></pre>\n<p>附上 leetcode 上的迭代写法</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123;\n        vector&lt;int&gt; res;\n        if (root == nullptr) &#123;\n            return res;\n        &#125;\n\n        stack&lt;TreeNode *&gt; stk;\n        TreeNode *prev = nullptr;\n        while (root != nullptr || !stk.empty()) &#123;\n            while (root != nullptr) &#123;\n                stk.emplace(root);\n                root = root-&gt;left;\n            &#125;\n            root = stk.top();\n            stk.pop();\n            if (root-&gt;right == nullptr || root-&gt;right == prev) &#123;\n                res.emplace_back(root-&gt;val);\n                prev = root;\n                root = nullptr;\n            &#125; else &#123;\n                stk.emplace(root);\n                root = root-&gt;right;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;;\n</code></pre>\n<p>相关解释</p>\n<p>为了实现这一顺序，该方法中</p>\n<ol>\n<li>\n<p>由于左子树始终首先输出，那么依旧存入所有的左子树结点</p>\n</li>\n<li>\n<p>为了防止根先于右子树输出，在该方法中，使用了 <code>prev</code>  这一变量，代表的是前一个右子树，只有当右子树为空或者右子树之前输出过了才可以输入 <code>root</code>  的内容，而为了先输出右子树的内容，会将右子树的根节点存入栈中，并指向该节点的右子树</p>\n</li>\n<li>\n<p>然后再判断上面的指向是否为存在子树 (即进入 while 循环判断，如果有，那么继续深入)</p>\n</li>\n<li>\n<p>之后按照正常输出即可</p>\n</li>\n</ol>\n<h1 id=\"其他相关题目\"><a class=\"anchor\" href=\"#其他相关题目\">#</a> 其他相关题目</h1>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=\">二叉树的最大深度</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv\">平衡二叉树</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==\">二叉树的层序遍历</span></li>\n</ol>\n",
            "tags": [
                "树",
                "二叉树",
                "数据结构"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/3140d327/",
            "url": "http://dpm12345.github.io/posts/3140d327/",
            "title": "队列实现",
            "date_published": "2022-01-04T02:07:26.000Z",
            "content_html": "<h1 id=\"队列的实现\"><a class=\"anchor\" href=\"#队列的实现\">#</a> 队列的实现</h1>\n<p>该实现使用的是 C++ 的函数模板</p>\n<h2 id=\"队列的特点\"><a class=\"anchor\" href=\"#队列的特点\">#</a> 队列的特点</h2>\n<p>与栈有些许类似，将数据放入队列中时，放入的位置是队尾，但弹出<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">pop()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span> 操作时，是将队头元素删去，并且队列可以通过<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo></mrow><annotation encoding=\"application/x-tex\">[</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">]</span></span></span></span> 来访问数据，故可知实现的函数功能有以下:</p>\n<ul>\n<li>\n<p>void push (T val); // 入队</p>\n</li>\n<li>\n<p>void pop (); // 出队</p>\n</li>\n<li>\n<p>T back (); // 返回队尾元素</p>\n</li>\n<li>\n<p>T front (); // 返回队首元素</p>\n</li>\n<li>\n<p>void operator=(const Queue&lt;T&gt;&amp; q); // 重载 = 运算符</p>\n</li>\n<li>\n<p>void print (); // 打印队列</p>\n</li>\n<li>\n<p>bool empty (); // 判断是否为空</p>\n</li>\n<li>\n<p>int size (); // 返回队列大小</p>\n</li>\n</ul>\n<h2 id=\"实现之前的思考\"><a class=\"anchor\" href=\"#实现之前的思考\">#</a> 实现之前的思考</h2>\n<p>由上面的实现功能列表，可以清楚此时队列中的元素增删分别是在尾部和头部来进行的 如果存储数据的是数组，增加数据时还好，可以直接添加，如果是删去元素，那么为了确保队列前面都有人存在 (不为循环队列), 必须分别将各个元素慢慢地向前挪，效率较慢。注意到队列的增删操作与链表的尾插和头删相同，而链表的尾插和头删比较简单，因此 此实现采用链表来存储数据</p>\n<h2 id=\"结点构造\"><a class=\"anchor\" href=\"#结点构造\">#</a> 结点构造</h2>\n<p>由于采用的是链表来存储数据，所以直接按照链表格式创建结点即可</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nstruct node&#123;\n\tT data;\n\tnode&lt;T&gt;* next;\n&#125;;\n</code></pre>\n<h2 id=\"queue-类\"><a class=\"anchor\" href=\"#queue-类\">#</a> Queue 类</h2>\n<h3 id=\"函数成员\"><a class=\"anchor\" href=\"#函数成员\">#</a> 函数成员</h3>\n<p>在队列的实现中，我们要进行头删，尾插，并且可以通过<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo></mrow><annotation encoding=\"application/x-tex\">[</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span></span></span></span> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">]</span></span></span></span> 来访问数据，故需要的数据分别为头结点地址、尾结点地址 (方便进行尾插)、链表的元素个数</p>\n<p>而函数成员即为实现功能所列</p>\n<p>所以整体结构为：</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nclass Queue&#123;\nprivate:\n\tnode&lt;T&gt;* head;         // 头结点\n\tnode&lt;T&gt;* tail;         // 尾结点\n\tint num;\npublic:\n\tQueue();                              // 无参构造函数\n\tQueue(T val);                         // 有参构造函数\n\t~Queue();                             // 析构函数\n\tQueue(const Queue&lt;T&gt;&amp; q);             // 复制构造函数\n\tvoid push(T val);                     // 入队\n\tvoid pop();                           // 出队\n\tT back();                             // 返回队尾元素\n\tT front();                            // 返回队首元素\n\tvoid operator =(const Queue&lt;T&gt;&amp; q);   // 重载 = 运算符\n\tvoid print();                         // 打印队列\n\tbool empty();                         // 判断是否为空\n\tint size();                           // 返回队列大小\n\n&#125;;\n</code></pre>\n<h3 id=\"成员函数实现\"><a class=\"anchor\" href=\"#成员函数实现\">#</a> 成员函数实现</h3>\n<h4 id=\"构造函数\"><a class=\"anchor\" href=\"#构造函数\">#</a> 构造函数</h4>\n<p>在上面，拟定为两种构造函数形式，无参和有参，两种方式做的工作一样，目的是对数据进行初始化。</p>\n<p>如果是无参，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">head</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">d</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">tail</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 都应指向空，而<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">num=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, 如果是有参，那么新建一个结点后，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">head</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">d</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">tail</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 都指向它，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">num=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<p>由于涉及指针，故需要深复制，重写复制构造函数</p>\n<p>以下为实现代码：</p>\n<pre><code class=\"language-c++\">// 无参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue()\n&#123;\n\thead = tail = nullptr;\n\tnum = 0;\n&#125;\n\n// 有参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(T val)\n&#123;\n\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\tnewnode-&gt;data = val;\n\tnewnode-&gt;next = nullptr;\n\thead = tail = newnode;\n\tnum = 1;\n&#125;\n\n// 复制构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(const Queue&lt;T&gt;&amp; q)\n&#123;\n\tnode&lt;T&gt;*newp = q.head;\n\twhile (newp!= nullptr)\n\t&#123;\n\t\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\t\tnewnode-&gt;data = newp-&gt;data;\n\t\tnewnode-&gt;next = nullptr;\n\t\tif (head == nullptr)\n\t\t&#123;\n\t\t\thead = tail = newnode;\n\t\t\tnum = 1;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\ttail-&gt;next = newnode;\n\t\t\ttail = tail-&gt;next;\n\t\t\tnum++;\n\t\t&#125;\n\t\tnewp = newp-&gt;next;\n\t&#125;\n\n&#125;\n</code></pre>\n<h4 id=\"析构函数\"><a class=\"anchor\" href=\"#析构函数\">#</a> 析构函数</h4>\n<p>由于存储数据申请了空间，那么析构函数应当执行释放内存操作</p>\n<p>代码如下：</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nQueue&lt;T&gt;::~Queue()\n&#123;\n\twhile (head != nullptr)\n\t&#123;\n\t\tnode&lt;T&gt;* temp = head;\n\t\thead = head-&gt;next;\n\t\tdelete temp;\n\t&#125;\n\ttail = nullptr;\n\tnum = 0;\n&#125;\n</code></pre>\n<h4 id=\"pusht-val\"><a class=\"anchor\" href=\"#pusht-val\">#</a> push(T val)</h4>\n<p>由于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>u</mi><mi>s</mi><mi>h</mi><mi mathvariant=\"normal\">_</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">push\\_back()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">h</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span> 即为链表中的尾插，那么只需创建新的结点，存储数值，之后使当前<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">tail</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding=\"application/x-tex\">next</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span></span></span></span> 指向该结点，最后<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">tail</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 指向该结点即可。需要注意的是，如果队列中无元素，那么直接将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">head</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">d</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">tail</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 指向该结点即可</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::push(T val)\n&#123;\n\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\tnewnode-&gt;data = val;\n\tnewnode-&gt;next = nullptr;\n\tif (head == nullptr)        // 无元素，或者可以写成 tail==nullptr 或 num==0\n\t&#123;\n\t\thead = tail = newnode;\n\t\tnum = 1;\n\t&#125;\n\telse\n\t&#123;\n\t\ttail-&gt;next = newnode;\n\t\ttail = tail-&gt;next;\n\t\tnum++;\n\t&#125;\n&#125;\n</code></pre>\n<h4 id=\"pop\"><a class=\"anchor\" href=\"#pop\">#</a> pop()</h4>\n<p>所做的操作为头删</p>\n<p>在删之前，我们必须考虑队列为空的情况，因此可以使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mi>s</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">assert()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span> 进行判断报错</p>\n<p>当队列中有元素时，删去头结点，那么可以先创建一个结点指针指向头结点，在删去头结点后再令 <code>head=head-&gt;next</code> ， <code>num--</code></p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::pop()\n&#123;\n\tassert(head);\n\tnode&lt;T&gt;*temp = head;\n\thead = head-&gt;next;\n\tdelete temp;     // 删去 head 也可以，只不过上面的 head 赋值需换到下面写成 head=temp-&gt;next;\n\tnum--;\n&#125;\n</code></pre>\n<h4 id=\"back\"><a class=\"anchor\" href=\"#back\">#</a> back()</h4>\n<p>返回队尾元素，直接使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow><annotation encoding=\"application/x-tex\">tail</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span></span></span></span> 指针即可</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nT Queue&lt;T&gt;::back()\n&#123;\n\treturn tail-&gt;data;\n&#125;\n</code></pre>\n<h4 id=\"front\"><a class=\"anchor\" href=\"#front\">#</a> front()</h4>\n<p>返回队首元素，直接使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi></mrow><annotation encoding=\"application/x-tex\">head</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">d</span></span></span></span> 指针即可</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nT Queue&lt;T&gt;::front()\n&#123;\n\treturn head-&gt;data;\n&#125;\n</code></pre>\n<h4 id=\"operatorconst-queuetq\"><a class=\"anchor\" href=\"#operatorconst-queuetq\">#</a> operator=(const Queue&lt;T&gt;&amp;q)</h4>\n<p>与复制构造函数类似，但这里需要判断原 Queue 对象是否已经有队列元素</p>\n<pre><code class=\"language-c++\">// 重载 = 运算符\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::operator =(const Queue&lt;T&gt;&amp; q)\n&#123;\n\tif (head)             // 如果存在队列\n\t&#123;\n\t\tthis-&gt;~Queue();\n\t&#125;\n\tnode&lt;T&gt;*newp = q.head;\n\twhile (newp != nullptr)\n\t&#123;\n\t\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\t\tnewnode-&gt;data = newp-&gt;data;\n\t\tnewnode-&gt;next = nullptr;\n\t\tif (head == nullptr)\n\t\t&#123;\n\t\t\thead = tail = newnode;\n\t\t\tnum = 1;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\ttail-&gt;next = newnode;\n\t\t\ttail = tail-&gt;next;\n\t\t\tnum++;\n\t\t&#125;\n\t\tnewp = newp-&gt;next;\n\t&#125;\n&#125;\n</code></pre>\n<h4 id=\"print\"><a class=\"anchor\" href=\"#print\">#</a> print()</h4>\n<p>即遍历链表，打印队列</p>\n<p>较为简单，直接上代码:</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nvoid Queue&lt;T&gt;::print()\n&#123;\n\tnode&lt;T&gt;* temp = head;\n\twhile (temp != nullptr)\n\t&#123;\n\t\tcout &lt;&lt; temp-&gt;data &lt;&lt; &quot;  &quot;;\n\t\ttemp = temp-&gt;next;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n</code></pre>\n<h4 id=\"empty\"><a class=\"anchor\" href=\"#empty\">#</a> empty()</h4>\n<p>判断是否为空，即可判断<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mo>=</mo><mn>0</mn><mo stretchy=\"false\">?</mo></mrow><annotation encoding=\"application/x-tex\">n==0?</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">?</span></span></span></span></p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nbool Queue&lt;T&gt;::empty()\n&#123;\n\treturn num == 0;\n&#125;\n</code></pre>\n<h4 id=\"size\"><a class=\"anchor\" href=\"#size\">#</a> size()</h4>\n<p>返回队列大小，即为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">num</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span></span></span></span> 的值</p>\n<pre><code class=\"language-c++\">template&lt;class T&gt;\nint Queue&lt;T&gt;::size()\n&#123;\n\treturn num;\n&#125;\n</code></pre>\n<h1 id=\"结果\"><a class=\"anchor\" href=\"#结果\">#</a> 结果</h1>\n<pre><code class=\"language-c++\">//#ifndef  _QUEUE_H\n//#define  _QUEUE_H\n\n#include&lt;assert.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nstruct node&#123;\n\tT data;\n\tnode&lt;T&gt;* next;\n&#125;;\n\n\ntemplate&lt;class T&gt;\nclass Queue&#123;\nprivate:\n\tnode&lt;T&gt;* head;         // 头结点\n\tnode&lt;T&gt;* tail;         // 尾结点\n\tint num;\npublic:\n\tQueue();                              // 无参构造函数\n\tQueue(T val);                         // 有参构造函数\n\t~Queue();                             // 析构函数\n\tQueue(const Queue&lt;T&gt;&amp; q);             // 复制构造函数\n\tvoid push(T val);                     // 入队\n\tvoid pop();                           // 出队\n\tT back();                             // 返回队尾元素\n\tT front();                            // 返回队首元素\n\tvoid operator =(const Queue&lt;T&gt;&amp; q);   // 重载 = 运算符\n\tvoid print();                         // 打印队列\n\tbool empty();                         // 判断是否为空\n\tint size();                           // 返回队列大小\n\n&#125;;\n\n// 无参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue()\n&#123;\n\thead = tail = nullptr;\n\tnum = 0;\n&#125;\n\n// 有参构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(T val)\n&#123;\n\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\tnewnode-&gt;data = val;\n\tnewnode-&gt;next = nullptr;\n\thead = tail = newnode;\n\tnum = 1;\n&#125;\n\n// 析构函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::~Queue()\n&#123;\n\twhile (head != nullptr)\n\t&#123;\n\t\tnode&lt;T&gt;* temp = head;\n\t\thead = head-&gt;next;\n\t\tdelete temp;\n\t&#125;\n\ttail = nullptr;\n\tnum = 0;\n&#125;\n\n// 复制构造函数\ntemplate&lt;class T&gt;\nQueue&lt;T&gt;::Queue(const Queue&lt;T&gt;&amp; q)\n&#123;\n\tnode&lt;T&gt;*newp = q.head;\n\twhile (newp!= nullptr)\n\t&#123;\n\t\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\t\tnewnode-&gt;data = newp-&gt;data;\n\t\tnewnode-&gt;next = nullptr;\n\t\tif (head == nullptr)\n\t\t&#123;\n\t\t\thead = tail = newnode;\n\t\t\tnum = 1;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\ttail-&gt;next = newnode;\n\t\t\ttail = tail-&gt;next;\n\t\t\tnum++;\n\t\t&#125;\n\t\tnewp = newp-&gt;next;\n\t&#125;\n\n&#125;\n\n// 入队 (尾插)\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::push(T val)\n&#123;\n\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\tnewnode-&gt;data = val;\n\tnewnode-&gt;next = nullptr;\n\tif (head == nullptr)\n\t&#123;\n\t\thead = tail = newnode;\n\t\tnum = 1;\n\t&#125;\n\telse\n\t&#123;\n\t\ttail-&gt;next = newnode;\n\t\ttail = tail-&gt;next;\n\t\tnum++;\n\t&#125;\n&#125;\n\n// 出队 (头删)\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::pop()\n&#123;\n\tassert(head);\n\tnode&lt;T&gt;*temp = head;\n\thead = head-&gt;next;\n\tdelete temp;\n\tnum--;\n&#125;\n\n// 返回队尾元素\ntemplate&lt;class T&gt;\nT Queue&lt;T&gt;::back()\n&#123;\n\treturn tail-&gt;data;\n&#125;\n\n// 返回队首元素\ntemplate&lt;class T&gt;\nT Queue&lt;T&gt;::front()\n&#123;\n\treturn head-&gt;data;\n&#125;\n\n// 重载 = 运算符\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::operator =(const Queue&lt;T&gt;&amp; q)\n&#123;\n\tif (head)\n\t&#123;\n\t\tthis-&gt;~Queue();\n\t&#125;\n\tnode&lt;T&gt;*newp = q.head;\n\twhile (newp != nullptr)\n\t&#123;\n\t\tnode&lt;T&gt;* newnode = new node&lt;T&gt;;\n\t\tnewnode-&gt;data = newp-&gt;data;\n\t\tnewnode-&gt;next = nullptr;\n\t\tif (head == nullptr)\n\t\t&#123;\n\t\t\thead = tail = newnode;\n\t\t\tnum = 1;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\ttail-&gt;next = newnode;\n\t\t\ttail = tail-&gt;next;\n\t\t\tnum++;\n\t\t&#125;\n\t\tnewp = newp-&gt;next;\n\t&#125;\n&#125;\n\n// 打印队列\ntemplate&lt;class T&gt;\nvoid Queue&lt;T&gt;::print()\n&#123;\n\tnode&lt;T&gt;* temp = head;\n\twhile (temp != nullptr)\n\t&#123;\n\t\tcout &lt;&lt; temp-&gt;data &lt;&lt; &quot;  &quot;;\n\t\ttemp = temp-&gt;next;\n\t&#125;\n\tcout &lt;&lt; endl;\n&#125;\n\n// 判断队列是否为空\ntemplate&lt;class T&gt;\nbool Queue&lt;T&gt;::empty()\n&#123;\n\treturn num == 0;\n&#125;\n\n// 返回队列大小\ntemplate&lt;class T&gt;\nint Queue&lt;T&gt;::size()\n&#123;\n\treturn num;\n&#125;\n//#endif\n</code></pre>\n",
            "tags": [
                "数据结构",
                "队列"
            ]
        }
    ]
}