{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"滑动窗口\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/1c771f88/",
            "url": "http://dpm12345.cn/posts/1c771f88/",
            "title": "最小覆盖子串",
            "date_published": "2023-04-15T02:20:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv\">最小覆盖子串</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<p>这道题是一道滑动窗口，根据题目意思，要保证查找到的子串既包含<code>t</code>中所有出现的字符，同时也要保证相对应得字符在子串中出现的次数大于等于在<code>t</code>中出现的次数</p>\n<p>这里可以使用两个哈希表分别记录两字符串中各字符出现的次数，tmap记录<code>t</code>的字符出现情况，smap维护的是当前窗口内的字符出现数的字典。当要添加的字符在smap中的值小于等于tmap，那么说明此次添加是有效的，那么将correct加一，而当相等出现冗余时，则要从前面对窗口进行缩小。(当出现与首字符相等的字符时，那么就实现了另一种情况的考虑，从而遍历所有可能的子串，然后通过比较各次的长度，最终得到最小子串)</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap, smap;\n        int left = 0, correct = 0;\n        string res = s+\"1\";//加上一个新的字符是为了防止s等于t的情况，利于下面最小值的比较\n        for (int i=0; i &lt; t.size(); i++) \n            tmap[t[i]]++;\n\n        for (int right = 0; right &lt; s.size(); ++right) {\n            // smap维护的是当前窗口内的字符出现数的字典\n            ++smap[s[right]];\n            // 当前right对应s的字符是在t中出现的，并且数量上还没有达到冗余，是一次有效添加\n            if (tmap[s[right]] &gt;= smap[s[right]])\n                ++correct;\n            // 字符串最短是空串 &amp;&amp; 如果left对应的字符是冗余，那么进行右移删除\n            while (left &lt; right &amp;&amp; smap[s[left]] &gt; tmap[s[left]])\n                --smap[s[left++]];\n            if (correct == t.size()){\n                // 窗口内已经满足t串的所有字符\n                if (right - left + 1 &lt; res.size())\n                    res = s.substr(left, right - left + 1);\n            }\n\n        }\n        return res==s+\"1\"?\"\":res;\n    }\n};\n</code></pre>\n",
            "tags": [
                "滑动窗口"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/d10e2ef2/",
            "url": "http://dpm12345.cn/posts/d10e2ef2/",
            "title": "无重复字符的最长字串",
            "date_published": "2022-03-18T12:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLw==\">无重复字符的最长字串</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size()==0)\n            return 0;\n        int ans = 1;\n        int left = 0;\n        unordered_set&lt;char&gt;temp;\n        for(int i=0;i&lt;s.size();i++)         // 遍历每个元素\n        {\n            while(temp.find(s[i])!=temp.end())          // 如果出现过了，由于求的是子串，故以此为开头的字符必不成立，故删去开头\n            {\n                temp.erase(s[left]);\n                left++;\n            }\n            temp.insert(s[i]);                         // 找到没有出现过的字符，加入\n            ans = max(ans,i-left+1);\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "滑动窗口",
                "哈希表",
                "字符串"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/ca7417e/",
            "url": "http://dpm12345.cn/posts/ca7417e/",
            "title": "三个无重叠子数组的最大和",
            "date_published": "2021-12-08T01:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdW0tb2YtMy1ub24tb3ZlcmxhcHBpbmctc3ViYXJyYXlzLw==\"> 三个无重叠子数组的最大和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.jpg\"></p>\n<p>该题为 2021-12-8 的每日一题，可解决该问题的方法涉及到前缀和，动态规划，滑动窗口知识</p>\n<p>思路: 题目要求求出某一数组三个长度为 k 的无重叠数组，使它们的元素之和为最大。</p>\n<p>看到这个个数为 k，很容易想到滑动窗口这一算法，只是在这里，需要同时存在三个滑动窗口，</p>\n<p>同样的，在这题，也可以用动态规划进行解决</p>\n<p>下面是我自己在解题时的过程</p>\n<h1 id=\"动态规划（劣质版）\"><a href=\"#动态规划（劣质版）\" class=\"headerlink\" title=\"动态规划（劣质版）\"></a>动态规划（劣质版）</h1><p>刚拿到题目时，我能想到，该题可以使用动态规划解决，但并无方向该从哪个地方下手将什么作为$dp[i]$所表达的意义，</p>\n<p>思考了大约20分钟后，我还是无从下手，于是打开了题解，第一眼看到的是”单个子数组的最大和“，顿时恍然大悟，我可以将不同个数的子数组作为一个$dp$，在计算个数加一时，便可以利用前面的$dp$，得到最优解。仔细思考，该方案的时间复杂度为$O(n)$。</p>\n<p>在以下的代码中，我是如此考虑的：</p>\n<p>先用$sum[i]$计算前缀和，为后续计算提供便利再分别使用$dp1$，$dp2$，$dp3$记录不同个数的子数组元素的最大值，其转移方程分别为：<br>$$<br>dp1[i]=max{dp1[i-1],sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>$$<br>dp2[i]=max{dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>$$<br>dp3[i]=max{dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>但这样并不能记录下标输出答案，所以这里我采用了，三个flag数组，用于记录下标，具体见代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n        vector&lt;int&gt;flag1(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag3(n);\n        vector&lt;int&gt;sum(n+1,0);\n        vector&lt;int&gt;ans;\n        for(int i=0;i&lt;n;i++)\n        {\n            sum[i+1]+=nums[i]+sum[i];           \n        }\n        for(int i=k-1;i&lt;n;i++)\n        {\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            {\n                flag1[i]=flag1[i-1];\n            }\n            else\n            {\n                flag1[i]=i-k+1;\n            }\n        }\n        for(int i=2*k-1;i&lt;n;i++)\n        {\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            {\n                flag2[i]=flag2[i-1];\n            }\n            else\n            {\n                flag2[i]={flag1[i-k],i-k+1};\n            }\n        }\n        for(int i=3*k-1;i&lt;n;i++)\n        {\n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            {\n                flag3[i]=flag3[i-1];\n            }\n            else\n            {\n                flag3[i]={flag2[i-k].second,i-k+1};\n            }\n        }\n        return {flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second};\n    }\n};\n</code></pre>\n<p>xxxxxxxxxx&nbsp;class Solution {public: &nbsp; &nbsp;int maxResult(vector<int>&amp; nums, int k) { &nbsp; &nbsp; &nbsp; &nbsp;int n = nums.size(); &nbsp; &nbsp; &nbsp; &nbsp;vector<int> dp(n); &nbsp; &nbsp; &nbsp; &nbsp;dp[0] = nums[0]; &nbsp; &nbsp; &nbsp; &nbsp;priority_queue&lt;pair&lt;int, int&gt;&gt; q; &nbsp; &nbsp; &nbsp; &nbsp;q.emplace(nums[0], 0); &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt; n; ++i) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (i - q.top().second &gt; k) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;q.pop(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i] = q.top().first + nums[i]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;q.emplace(dp[i], i); &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;return dp[n - 1]; &nbsp;  }};cpp 优先级队列2</int></int></p>\n<p><img data-src=\"/../../../post_images/%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF.png\"></p>\n<p>观察报错信息，可知，在我的代码中，并未考虑<code>k==1</code>的情况，因为代码中我是通过<code>for(int i=k-1;i&lt;n;i++)</code>实现循环的，k-1 就会为 0，至于后面 i-1 造成错误</p>\n<p>改进代码:</p>\n<pre><code class=\"cpp\">if(k==1)                      // 考虑 k==1 的情况\n    {\n        vector&lt;int&gt;ans(3);\n        for(int i=0;i&lt;3;i++)\n        {\n            ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n        }\n        sort(ans.begin(),ans.end());\n        return ans;\n    }\n</code></pre>\n<p>再次提交，发现答案出错，如下:</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0.png\"></p>\n<p>在这并不能看出什么，为此，我进行了多组数据的尝试，发现第一个大部分都不符合答案，但后两个一直都是正确的，说明<code>flag1</code>求解过程无误，而是输出出错</p>\n<p>对此，进行代码分析，最后输出时，我写的是</p>\n<p><code>return {flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second};</code></p>\n<p><code>[flag2[flag3[n-1].first].first</code>，因为我在<code>flag3.first</code>存入的是<code>flag2</code>的索引的第二个元素，以此来得到<code>flag1</code>明显是不可行的，因为对应<code>flag1</code>的下标与<code>flag2</code>的第二个元素并无关系，<code>flag1[i-k]</code>可能是前一个继承来的，与<code>flag2</code>的第二个元素无关，也有可能与其有关，总之该方法不一定正确</p>\n<p>那么我做以下修改</p>\n<ol>\n<li>重新定义<code>flag3</code>数组类型，为<code>&lt;pair&lt;pair&lt;int,int&gt;，int&gt;&gt;</code></li>\n<li>存入<code>flag3</code>时存入<code>{flag2 [i-k],i-k+1}</code></li>\n<li>读取第一个使用<code>flag3[n-1].first.first</code>，第二个使用<code>flag3[n-1].first.second</code></li>\n</ol>\n<p>以下为修改后的代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        if(k==1)                      // 考虑 k==1 的情况\n        {\n            vector&lt;int&gt;ans(3);\n            for(int i=0;i&lt;3;i++)\n            {\n                ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n            }\n            sort(ans.begin(),ans.end());\n            return ans;\n        }\n        //dp [i] 表示 0 到该位置所能得到的 x 个无重叠数组和的最大值\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n        \n        //flag1 记录某一位置 1 个最大无重叠数组的下标       \n        vector&lt;int&gt;flag1(n);\n        \n        //flag2 记录某一位置 2 个最大无重叠数组的下标    \n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n        \n        //flag3 记录某一位置 3 个最大无重叠数组的下标                  \n        vector&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt;flag3(n);              \n        \n        //sum [i] 表示前 i 个数之和\n        vector&lt;int&gt;sum(n+1,0); \n        \n        for(int i=0;i&lt;n;i++)                       // 计算前缀和\n        {\n            sum[i+1]+=nums[i]+sum[i];           \n        }\n        \n        // 计算从 k-1 开始 1 个无重叠子数组最大的值，用 flag1 记录下标值\n        for(int i=k-1;i&lt;n;i++)                      \n        {\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            {\n                flag1[i]=flag1[i-1];\n            }\n            else\n            {\n                flag1[i]=i-k+1;\n            }\n        }\n        \n        // 计算从 2*k-1 开始 2 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=2*k-1;i&lt;n;i++)                   \n        {\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            {\n                flag2[i]=flag2[i-1];\n            }\n            else\n            {\n                flag2[i]={flag1[i-k],i-k+1};\n            }\n        }\n        \n        // 计算从 3*k-1 位置开始 3 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=3*k-1;i&lt;n;i++)                        \n        { \n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            {\n                flag3[i]=flag3[i-1];\n            }\n            else\n            {\n                flag3[i]={flag2[i-k],i-k+1};\n            }\n        }\n        \n        // 根据 flag3 找寻下标\n        return {flag3[n-1].first.first,flag3[n-1].first.second,flag3[n-1].second};   \n    }\n};\n</code></pre>\n<h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><p>维护<code>sum1</code>，<code>sum2</code>，<code>sum3</code>，分别表示<code>n</code>个子数组的最大值，若大于原来的更新下标(代码中为<code>sum1maxid,sum2maxid1,sum2maxid2</code>) 当数组个数大于等于k时，那么需删去首个元素，更新窗口</p>\n<p>以下为代码实现</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        int sum1=0,sum2=0,sum3=0;\n        int sum1max=0,sum2max=0,sum3max=0;\n        int sum1maxid,sum2maxid1,sum2maxid2;\n        vector&lt;int&gt;ans;\n        for(int i=2*k;i&lt;n;i++)\n        {\n            sum1+=nums[i-2*k];\n            sum2+=nums[i-k];\n            sum3+=nums[i];\n            if(i&gt;=3*k-1)\n            {\n                if(sum1&gt;sum1max)\n                {\n                    sum1max=sum1;\n                    sum1maxid=i-3*k+1;          // 更新 1 个子数组最大值下标\n                }\n                if(sum1max+sum2&gt;sum2max)\n                {\n                    sum2max=sum1max+sum2;\n                    sum2maxid1=sum1maxid;       // 更新两个子数组中 1 个子数组最大值下标\n                    sum2maxid2=i-2*k+1;         // 更新 1 个子数组最大值下标\n                }\n                if(sum2max+sum3&gt;sum3max)\n                {\n                    sum3max=sum2max+sum3;\n                    ans={sum2maxid1,sum2maxid2,i-k+1};  // 更新答案\n                }\n                sum1-=nums[i-3*k+1];             // 删去首个\n                sum2-=nums[i-2*k+1];             // 删去首个\n                sum3-=nums[i-k+1];               // 删去首个\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "前缀和",
                "动态规划",
                "滑动窗口"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/6ba8ad80/",
            "url": "http://dpm12345.cn/posts/6ba8ad80/",
            "title": "整数拆分",
            "date_published": "2021-11-21T07:54:40.000Z",
            "content_html": "<p>[题目链接:]{.orange}<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay8=\">整数拆分</span></p>\n<p>[题目详情]{.orange}</p>\n<p><img data-src=\"/../../../post_images/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"整数拆分_1\"></p>\n<p>[数学方法可以证明乘积最大时，因子最终都可以分解为若干个3和若干个2，且3的个数尽可能多]{.blue}</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int integerBreak(int n) {\n        if (n == 2)return 1;\n        if (n == 3)return 2;\n        int num_3 = n / 3, num_2 = (n % 3) / 2;\n        if (n % 3 == 1)\n        {\n            num_3--;\n            num_2 += 2;\n        }\n        return pow(3, num_3)*pow(2, num_2);\n    }\n};\n</code></pre>\n",
            "tags": [
                "滑动窗口",
                "哈希表",
                "字符串"
            ]
        }
    ]
}