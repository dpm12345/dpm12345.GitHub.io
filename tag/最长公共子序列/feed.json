{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"最长公共子序列\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/9e6e8fdc/",
            "url": "http://dpm12345.cn/posts/9e6e8fdc/",
            "title": "子序列问题",
            "date_published": "2021-12-09T01:54:40.000Z",
            "content_html": "<h1 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\">最长公共子序列</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\"></p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\"></p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>我们可以用$dp [i][j]$表示字符串1$[0<del>i]$范围内和字符串2$ [0</del>i]$范围内的最长公共序列</p>\n<p>当$text1[i]=text2[j]$时，很明显 $dp [i][j]=dp [i-1][j-1]+2$</p>\n<p>当$text1[i]!=text2[j]$时，$dp[i][j]=max(dp[i][j-1],dp[i-1][j])$</p>\n<p>因为此时需要找个最长的子序列为然后连接上后面未知的字符，这样遍历到最后就能得到最大</p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.length(),n=text2.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1));\n        int ans=0;\n        for(int i=1;i&lt;=m;i++)\n        {\n            for(int j=1;j&lt;=n;j++)\n            {\n                if(text1[i-1]==text2[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"最长回文子序列\"><a href=\"#最长回文子序列\" class=\"headerlink\" title=\"最长回文子序列\"></a>最长回文子序列</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnNlcXVlbmNlL3N1Ym1pc3Npb25zLw==\">最长回文子序列</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.jpg\"></p>\n<h2 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h2><p>沿用求最长公共子序列的方法，我们可以先将字符串反转，得到一个新的字符串，再求这两个字符串的最长公共子序列的值，即为最长回文子序列</p>\n<p><strong>证明：</strong> 回文串的表现为成对称分布，从前往后遍历和从后往前遍历的结果是一样的，所以说如果求其与其本身的反转字符串的最长公共子序列，因为一个是正向，一个是反向，当求的该共同字符串时，那就说明该字符子序列在原字符串中为回文子序列，又由于在求解过程中记录的为最长，那么结果就能得到最长回文子序列</p>\n<p>下面为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        string re=s;\n        int ans=0;\n        reverse(re.begin(),re.end());\n        vector&lt;vector&lt;int&gt;&gt;dp(s.length()+1,vector&lt;int&gt;(s.length()+1));\n        for(int i=1;i&lt;=s.length();i++)\n        {\n            for(int j=1;j&lt;=re.length();j++)\n            {\n                if(s[i-1]==re[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        return ans;\n\n    }\n};\n</code></pre>\n<h2 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h2><p>根据回文串的特征，如果一段字符串是回文串，那么将其两边各删去一个字符后依然为回文串，所以我们可以用$dp[i][j]$来表示$i$到$j$最长回文子序列的长度，当遍历时，如果$s[i]=s[j]$，那么$dp[i]=dp[i+1][j-1]+2$，如果不相等，$dp[i][j]=max(dp[i+1][j],dp[i][j-1]$</p>\n<p>需要注意的是，回文串最短为其本身，所以在开始真正寻找前，可以先将$dp [i][i]=1$</p>\n<p>在这里，我们选择由后至前推导，根据上方思想，那么最后的值应为$dp [0][n-1]$($n$为字符串长度)</p>\n<p>下面为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n=s.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(n));\n        for(int i=n-1;i&gt;=0;i--)\n        {\n            dp[i][i]=1;\n            for(int j=i+1;j&lt;n;j++)\n            {\n                if(s[j]==s[i])\n                    dp[i][j]=dp[i+1][j-1]+2;\n                else\n                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n        return dp[0][n-1];\n    }\n};\n</code></pre>\n",
            "tags": [
                "动态规划",
                "子序列",
                "最长公共子序列",
                "最长回文子序列"
            ]
        }
    ]
}