{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"排列组合\" tag",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/47ade4a0/",
            "url": "http://dpm12345.cn/posts/47ade4a0/",
            "title": "爬楼梯与零钱兑换题目对比",
            "date_published": "2021-12-02T06:54:40.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==\">爬楼梯</span></p>\n<p><img data-src=\"/../../../post_images/%E7%88%AC%E6%A5%BC%E6%A2%AF.png\"></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2UtMi8=\">零钱兑换 II</span></p>\n<p><img data-src=\"/../../../post_images/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.png\"></p>\n<p>建立在做过题目的基础上，我们重新审视这几道题</p>\n<ol>\n<li><p>对于爬楼梯，由于一次只能爬一阶或两阶，故$dp[i]=dp[i-1]+dp[i-2]$<br>对于零钱兑换II，其限制因素为零钱的面额，故当$i&gt;=coin[j]$时，$dp[i]+=dp[i-coin[j]]$</p>\n<p>而现在我们将爬楼梯的限制由由只有一阶或两阶，改为一个数组$step[]={1,2}$；那么在做时，便要遍历一次$step [j]$, 当$i&gt;=step[j]$时，$dp[i]=dp[i]+dp[i-step[j]]$, 而$step[j]$便与前面的减去 1、2 相同。这样不难发现，如果将每次能跨越的楼梯阶数改为一个数组里的元素，那么爬楼梯与零钱兑换II的解题代码就十分相似了</p>\n</li>\n<li><p>接下来进行更深一层的讨论</p>\n<p>在爬楼梯题目中，我们要计算的是到达顶端的总数，每次只能一阶或两阶，由此可知，其为 若干个1和2排列，其对顺序有要求，也就是说，最后得到是排列数的结果</p>\n<p>而在零钱兑换II题目中，因为只是记录兑换一个金额的总数，先取小面额还是先取大面额是没有区别的，那么也就是说，该题求的是组合数。</p>\n<p>那么，该用什么方法区别这两种呢？</p>\n<p>下面给出两段代码</p>\n</li>\n</ol>\n<pre><code class=\"cpp\">//  amount 表示金额，n 表示硬币面额数，coin [i] 表示某个硬币\n    \n    // 第一段\n    for(int i=1;i&lt;=amount;i++)\n    {\n       for(int j=0;j&lt;n;j++)\n          {\n              if(i&gt;=coin[j])\n              {\n                  dp[i]+=dp[i-coin[j]];\n              }\n          }\n    }\n    \n    \n    // 第二段\n    for(int i=0;i&lt;n;i++)\n    {\n       for(int j=1;j&lt;=amount;j++)\n          {\n              if(j&gt;=coin[i])\n              {\n                  dp[j]+=dp[j-coin[i]];\n              }\n          }\n    }\n</code></pre>\n<p>经过代码观察，不难看出，第一段代码先枚举金额，然后嵌套<code>coin</code>硬币的循环； 第二段代码先枚举<code>coin</code>硬币面额，然后再枚举金额</p>\n<ol>\n<li><p>先看第一段代码：先枚举金额，再枚举硬币面额，也就是说每一个金额的<code>dp</code>计算都会涉及到每一种硬币,当$i&gt;=coin[j]$,意味着$i-coin[j]$后可以添加一个硬币元素$coin[j]$等于$i$,所以$dp[i]=dp[i]+dp[i-coin[j]]$,那么不难得出比如计算金额$3$时，如果硬币面额存在$1$和$2$，那么$dp[1]$和$dp[2]$的值都会加到$dp[3]$上，也,就是说首先$dp[3]+=dp[2]$,即$2，1$情况，然后$dp[3]+=dp[1]$,即$1，2$情况。很明显，”1,2”、”2,1”都计算的为排列数。</p>\n</li>\n<li><p>再看第二段代码：先枚举硬币面额，再枚举金额，也就是说每一个硬币面额都会在一种金额内计算一次，再根据循环的方式，从下标零开始遍历，知道结束，那么不难得出，$coin[i]$的值在$dp[i]$的每一种情况中，出现的顺序都是固定的，那么与上面分析相比，”1,2”、”2,1”只会出现一种，所以第二段代码计算的结果为组合数</p>\n</li>\n</ol>\n<p>下面进行代码实现</p>\n<p>注：为确保爬楼梯代码无误，增加了数组b进行检验，若正确，则应先输出34</p>\n<pre><code class=\"cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nclass Solution{\npublic:\n    int climb_stairs(int amount, vector&lt;int&gt;&amp;step)\n    {\n        vector&lt;int&gt;dp(amount + 1);\n        int n = step.size();\n        dp[0] = 1;\n        for (int i = 1; i &lt;= amount; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (i&gt;=step[j])\n                {\n                    dp[i] += dp[i - step[j]];\n                }\n            }\n        }\n        return dp[amount];\n    }\n    int change(int amount, vector&lt;int&gt;&amp;coin)\n    {\n        vector&lt;int&gt;dp(amount + 1);\n        int n = coin.size();\n        dp[0] = 1;   // 表示金额为零的情况，\n                     // 因为零钱面额也为零，故 dp [0]=1\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 1; j &lt;=amount; j++)\n            {\n                if (j&gt;=coin[i])\n                {\n                    dp[j] += dp[j - coin[i]];\n                }\n            }\n        }\n        return dp[amount];\n    }\n};\n\nint main()\n{\n    int amount = 8;\n    vector&lt;int&gt;a(3);\n    a[0] = 1; a[1] = 2; a[2] = 5;\n    vector&lt;int&gt;b(2);\n    b[0] = 1; b[1] = 2;\n    Solution A;\n    cout &lt;&lt; A.climb_stairs(amount, b) &lt;&lt; endl;      \n    cout &lt;&lt;A.climb_stairs(amount,a)  &lt;&lt; endl;\n    cout &lt;&lt; A.change(amount,a)&lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p><img data-src=\"/../../../post_images/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png\"></p>\n<p>将8，数组[1,2,5]分别输入leetcode控制器内检验，发现无误</p>\n<p>【2021-12-3 更新】</p>\n<p>类似的题目还有</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLWl2Lw==\">组合总数</span></p>\n<p><img data-src=\"/../../../post_images/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0IV.png\"></p>\n<p>方法类似，但需要注意题目要求不能超过32位整数范围，需添加限制，如图</p>\n<p><img data-src=\"/../../../post_images/%E5%8C%BA%E5%88%AB.png\"></p>\n",
            "tags": [
                "排列组合"
            ]
        }
    ]
}