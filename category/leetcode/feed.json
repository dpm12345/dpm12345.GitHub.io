{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"leetcode\" category",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.github.io",
    "items": [
        {
            "id": "http://dpm12345.github.io/posts/b6465ced/",
            "url": "http://dpm12345.github.io/posts/b6465ced/",
            "title": "两数相加",
            "date_published": "2022-03-18T15:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv\">两数相加</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"\" /></p>\n<h2 id=\"不带头节点\"><a class=\"anchor\" href=\"#不带头节点\">#</a> 不带头节点</h2>\n<pre><code class=\"language-c++\">/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        ListNode* ans = nullptr;               // 开始节点\n        ListNode* tail = nullptr;              // 尾节点\n        int add = 0;                           // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        &#123;\n            int m = l1? l1 -&gt;val : 0;\n            int n = l2? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;       // 个位数\n            add = (m + n + add)/10;            // 进位\n            if(!ans)                           \n            &#123;                                  \n                ans = tail = new ListNode(num);\n            &#125;\n            else\n            &#123;\n                tail -&gt; next = new ListNode(num);\n                tail = tail -&gt; next;\n            &#125;\n\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        &#125;\n        if(add)                                // 如果还有进位，那么应该再创建一个节点\n            tail -&gt;next = new ListNode(add);\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"带头结点-省去了无节点情况的考虑代码\"><a class=\"anchor\" href=\"#带头结点-省去了无节点情况的考虑代码\">#</a> 带头结点 (省去了无节点情况的考虑代码)</h2>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;\n        ListNode* ans = new ListNode(-1);       //ans-&gt;next 为答案\n        ListNode* cnode = ans;                  // 遍历节点指针\n        int add = 0;                            // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        &#123;\n            int m = l1 ? l1 -&gt;val : 0;\n            int n = l2 ? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;        // 个位数\n            add = (m + n + add)/10;             // 进位\n            cnode -&gt; next = new ListNode(num);  // 链接\n            cnode = cnode -&gt; next;              // 转移\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        &#125;\n        if(add)\n            cnode -&gt;next = new ListNode(add);\n        return ans-&gt;next;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/d98ef1d2/",
            "url": "http://dpm12345.github.io/posts/d98ef1d2/",
            "title": "两数之和",
            "date_published": "2022-03-18T14:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLw==\">两数之和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"\" /></p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;\n        unordered_map&lt;int,int&gt;temp;\n        for(int i=0;i&lt;nums.size();i++)\n        &#123;\n            int num = nums[i];\n            if(temp.find(target-num)!=temp.end())\n                return &#123;temp[target-num],i&#125;;\n            else\n                temp.insert(&#123;num,i&#125;);\n        &#125;\n        return &#123;&#125;;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "数组",
                "哈希表"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/d10e2ef2/",
            "url": "http://dpm12345.github.io/posts/d10e2ef2/",
            "title": "无重复字符的最长字串",
            "date_published": "2022-03-18T12:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLw==\">无重复字符的最长字串</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"\" /></p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int lengthOfLongestSubstring(string s) &#123;\n        if(s.size()==0)\n            return 0;\n        int ans = 1;\n        int left = 0;\n        unordered_set&lt;char&gt;temp;\n        for(int i=0;i&lt;s.size();i++)         // 遍历每个元素\n        &#123;\n            while(temp.find(s[i])!=temp.end())          // 如果出现过了，由于求的是子串，故以此为开头的字符必不成立，故删去开头\n            &#123;\n                temp.erase(s[left]);\n                left++;\n            &#125;\n            temp.insert(s[i]);                         // 找到没有出现过的字符，加入\n            ans = max(ans,i-left+1);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "滑动窗口",
                "哈希表",
                "字符串"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/5c639822/",
            "url": "http://dpm12345.github.io/posts/5c639822/",
            "title": "最小栈",
            "date_published": "2022-01-24T14:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluLXN0YWNrLw==\"> 最小栈</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%9C%80%E5%B0%8F%E6%A0%88.png\" alt=\"最小栈详情\" /></p>\n<p>要完成题目所要的功能，首先至少需要一个栈存储压入数据</p>\n<p>而对于该栈的使用方法有所不同</p>\n<h2 id=\"用一个栈存储数据使用-vector-数组存最小值\"><a class=\"anchor\" href=\"#用一个栈存储数据使用-vector-数组存最小值\">#</a> 用一个栈存储数据，使用 vector 数组存最小值</h2>\n<p>在该方法中，入栈时，用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">vector</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 存储最小值，当栈为空即可直接将要压入栈的值作为最小值，放入数组末尾，而如果栈不为空，那么根据压入值与最小值的比较，将较小值放入<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">vector</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 数组末尾，这样做的好处是在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">pop()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span> 操作时，不需判断<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">pop()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span> 的值是否为最小值，可直接<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>p</mi><mi mathvariant=\"normal\">_</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">pop\\_back()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.06em;vertical-align:-0.31em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">p</span><span class=\"mord\" style=\"margin-right:0.02778em;\">_</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span></span></span></span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow><annotation encoding=\"application/x-tex\">vector</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.61508em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span></span></span></span> 数组末尾值</p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class MinStack &#123;\nprivate:\n    stack&lt;int&gt;a;\n    vector&lt;int&gt;m;\npublic:\n    MinStack() &#123;\n\n    &#125;\n    \n    void push(int val) &#123;\n        if(a.empty())\n        &#123;\n            a.push(val);\n            m.push_back(val);\n        &#125;\n        else\n        &#123;\n            a.push(val);\n            if(val&lt;m.back())\n            &#123;\n                m.push_back(val);\n            &#125;\n            else\n            &#123;\n                m.push_back(m.back());\n            &#125;\n        &#125;\n    &#125;\n    \n    void pop() &#123;\n        a.pop();\n        m.pop_back();\n    &#125;\n    \n    int top() &#123;\n        return a.top();\n      \n    &#125;\n    \n    int getMin() &#123;\n       return m.back();\n    &#125;\n&#125;;\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj-&gt;push(val);\n * obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * int param_4 = obj-&gt;getMin();\n */\n</code></pre>\n<h2 id=\"栈不用于存储数据同时不需要额外空间存储\"><a class=\"anchor\" href=\"#栈不用于存储数据同时不需要额外空间存储\">#</a> 栈不用于存储数据，同时不需要额外空间存储</h2>\n<p>在该方法中，栈中存储的数值为压入栈值与当前最小值的差值</p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class MinStack &#123;\npublic:\n    stack&lt;long long&gt; st;   // 使用 long long 防止数据溢出\n    long long minv;\n\n    MinStack() &#123;\n        minv = -1;\n    &#125;\n\n    void push(int val) &#123;\n        if (!st.size()) &#123;\n            st.push(0);\n            minv = val;\n        &#125;\n        else &#123;// 这次的值减去已有的最小值\n            long long diff = val - minv;\n            st.push(diff);\n            minv = diff &lt; 0 ? val : minv;\n        &#125;\n    &#125;\n\n    void pop() &#123;\n        if (st.size()) &#123;\n            long long diff = st.top();\n            st.pop();\n            if (diff &lt; 0)\n                minv -= diff;\n        &#125;\n    &#125;\n\n    int top() &#123;\n        long long diff = st.top();\n        if (diff &lt; 0)\n            return minv;\n        else \n            return minv + diff;\n    &#125;\n    \n    int getMin() &#123;\n        return minv;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "vector",
                "栈"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/73645ce2/",
            "url": "http://dpm12345.github.io/posts/73645ce2/",
            "title": "丑数",
            "date_published": "2022-01-14T14:54:40.000Z",
            "content_html": "<p>丑数，其所有因数均属于所给的数字集合，如对于因数 2，3，5，</p>\n<p>2，6，10 均为满足条件的丑数</p>\n<p>以下为 leetcode 上丑数的相关问题</p>\n<h1 id=\"丑数\"><a class=\"anchor\" href=\"#丑数\">#</a> 丑数</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdWdseS1udW1iZXIvc29sdXRpb24v\"> 丑数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%91%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<p>根据丑数因数特点，我们可以依次不断除以所给因数集的各因数，如果其为丑数，结束后其必定变为数字 <code>1</code> ，如果不满足，其必不为 <code>1</code></p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isUgly(int n) &#123;\n        if(n&lt;=0)\n            return false;\n        int div[]=&#123;2,3,5&#125;;\n        for(int i=0;i&lt;3;i++)\n        &#123;\n            while(n % div[i] == 0)\n            &#123;\n                n /= div[i];\n            &#125;\n        &#125;\n        return n==1;\n\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"丑数-ii\"><a class=\"anchor\" href=\"#丑数-ii\">#</a> 丑数 II</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdWdseS1udW1iZXItaWkv\"> 丑数 II</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%91%E6%95%B0II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<p><strong>思路:</strong></p>\n<p>这一道题目的因数集与上题相同，但要求不同，求的是满足条件的第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个丑数</p>\n<p>仔细观察题目示例，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>12</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2,3,4,5,6,8,9,10,12]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span> 为前十个丑数组成的序列，结合丑数特点，每个数字最多只有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">2,3,5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span></span></span></span>，三个因数，也就是说我们可以利用动态规划的思想，在前面的基础上乘以因数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">2,3,5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span></span></span></span>​，得到的数必然为满足的丑数。由于要涵盖所有的数，那么前面的数都应要乘各项因数，因此可以为不同因数各设置一个记录应该乘第几个丑数的变量，并将所得乘积记录到数组中，在取时，只需取数组中的最小值即可，取出后相应的也需要更新该因数对应的最小数</p>\n<p>由于存在公倍数，因此在判断取出的数是哪个因数时需要对每个因素都进行判断一次，排除重复的情况</p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int nthUglyNumber(int n) &#123;\n        vector&lt;int&gt; dp(n + 1);  //dp [n] 表示第 n 个丑数\n        dp[1] = 1;              // 默认第一个为 1\n        int p2 = 1, p3 = 1, p5 = 1;   //p2,p3,p5 分别表示对应因数应乘的丑数下标\n        for (int i = 2; i &lt;= n; i++) &#123;\n            int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;   // 更新数组\n            dp[i] = min(min(num2, num3), num5);         // 找到最小值\n            if (dp[i] == num2) &#123;                        // 判断该最小值是否由因数 2 得到\n                p2++;\n            &#125;\n            if (dp[i] == num3) &#123;                        // 判断该最小值是否由因数 2 得到\n                p3++;\n            &#125;\n            if (dp[i] == num5) &#123;                        // 判断该最小值是否由因数 2 得到\n                p5++;\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"超级丑数\"><a class=\"anchor\" href=\"#超级丑数\">#</a> 超级丑数</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VwZXItdWdseS1udW1iZXIv\"> 超级丑数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"超级丑数_题目详情\" /></p>\n<p>这题与与丑数 II 十分相似，不同的是，因数集不在是固定为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[2,3,5]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">]</span></span></span></span>，而是由给定的数组决定。</p>\n<p>同样的沿用丑数 II 的思想，在丑数 II 中，首先需要存储丑数的数组 dp，同时用于实现动态规划思想，其次需要有记录各因数应乘丑数的下标和记录目前丑数集的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">num</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span></span></span></span></p>\n<p>因此需要的变量为：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span> 存储丑数</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">point[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 记录因数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">primes[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 应乘的丑数下标</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">nums[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 存储丑数集，其中下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应因数下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></li>\n</ul>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;\n        vector&lt;int&gt;point(primes.size(),0);\n\t\t// 使用 long 防止数据溢出，因为虽然题目保证第 n 各数不会超出 32-bit，\n\t\t// 但我们在使用该方法时是找已知丑数的最小值，因此可能超过 32-bit\n        vector&lt;long&gt;nums(primes.size(),1);\n        vector&lt;long&gt;dp(n+1);\n        for(int i=1;i&lt;=n;i++)\n        &#123;\n            long minn=INT_MAX;             // 用于找到丑数集中的最小数\n            for(int j=0;j&lt;nums.size();j++)\n            &#123;\n                minn=min(minn,nums[j]);\n            &#125;\n            dp[i]=minn;                   // 放入存储丑数的数组中\n            for(int j=0;j&lt;nums.size();j++)\n            &#123;\n                if(minn==nums[j])         // 表示目前找到的最小丑数可以有因数 primes [j] 得到\n                &#123;\n                    point[j]++;           // 对应丑数小标加 1\n                    nums[j]=dp[point[j]]*primes[j];     // 更新丑数集\n                &#125;\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/45daaf11/",
            "url": "http://dpm12345.github.io/posts/45daaf11/",
            "title": "环形链表",
            "date_published": "2021-12-31T11:54:40.000Z",
            "content_html": "<h1 id=\"环形链表\"><a class=\"anchor\" href=\"#环形链表\">#</a> 环形链表</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv\">环形链表</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<h2 id=\"利用哈希表\"><a class=\"anchor\" href=\"#利用哈希表\">#</a> 利用哈希表</h2>\n<p>** 方法详情：** 由于如果一个链表是环形链表，那么在不断地跳入下一个结点坐标时，其地址必然与前面 d 的某个地址相同，也就是说，我们可以把每个结点的地址存入哈希表中，当出现要存入结点地址已经在哈希表中存过之后，那么该链表必然是环形链表，否则不是。据此，时间方面，我们可知只需最长只需遍历链表结点一遍；空间方面，我们创建了一个哈希表，最多存入链表的总个数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool hasCycle(ListNode *head) &#123;\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        &#123;\n            if(a.count(head))\n            return true;\n            a.insert(&#123;head,0&#125;);\n            head=head-&gt;next;\n        &#125;\n        return false;\n        \n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"利用双指针快慢指针\"><a class=\"anchor\" href=\"#利用双指针快慢指针\">#</a> 利用双指针（快慢指针）</h2>\n<p>题目中的进阶要求我们使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的内存，该方案是可以实现的，具体涉及到双指针方法详情：我们可以创建两个指针，快指针 fast，每次走两步，慢指针 slow，每次走一步。那么就很容易得到如果该环形链表为环形链表，快指针必定会在环形结点的某一个结点与慢指针相遇 (或者说是追上慢指针)，那么只需判断最后两个指针是否指向同一个结点即可</p>\n<p>** 证明：** 在该方法中，使用了分别走一步和两步的指针。如果该链表是环形链表，当慢指针进入环形部分中，此时快指针也在某处，设他们相差<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个结点，而他们的速度之差为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mspace width=\"1em\"/><mi>m</mi><mi>o</mi><mi>d</mi><mspace width=\"1em\"/><mn>1</mn><mo>=</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">n\\quad mod\\quad1==0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:1em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 也就是说，必定存在某一时刻能够使两指针指向同一个地址据此，时间方面，在慢指针进入环形结点后，快慢指针初始相距最长为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo stretchy=\"false\">(</mo><mi>L</mi><mo>&lt;</mo><mo>=</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">L(L&lt;=N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span>, 而在此之前遍历次数也只和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span> 有关，如果没有环形链表，那么遍历次数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">⌊</span></span></span></span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{n}{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.040392em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\rfloor</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mclose\">⌋</span></span></span></span></p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool hasCycle(ListNode *head) &#123;\n        ListNode*fast=head,*slow=head;\n        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)\n        &#123;\n            fast=fast-&gt;next-&gt;next;\n            slow=slow-&gt;next;\n            if(fast==slow)\n                return true;\n        &#125;\n        return false;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"环形链表-ii求出环形链表开始结点位置\"><a class=\"anchor\" href=\"#环形链表-ii求出环形链表开始结点位置\">#</a> 环形链表 II（求出环形链表开始结点位置）</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv\">环形链表 II</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<p>该题与上面题目比较像，但在确定环的同时也要返回环开始结点</p>\n<h2 id=\"哈希表\"><a class=\"anchor\" href=\"#哈希表\">#</a> 哈希表</h2>\n<p>在上一个问题中，我们是找到重复就返回 true，那么同理在这里我们可以使用相同的代码，仅仅把返回值的 true 和 false 分别改成对应节点和 NULL 即可</p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        &#123;\n            if(a.count(head))\n               return head;\n            a.insert(&#123;head,1&#125;);\n            head=head-&gt;next;\n        &#125;\n        return NULL;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"双指针快慢指针\"><a class=\"anchor\" href=\"#双指针快慢指针\">#</a> 双指针（快慢指针）</h2>\n<p>为了降低内存我们同样也可以使用快慢指针，将空间复杂度降到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，这里涉及到一个证明</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E8%AF%81%E6%98%8E.jpg\" alt=\"\" /></p>\n<p>所以我们可以在双指针基础上，在他们相遇时新建两个指针 (或者直接用现成的 <code>head</code>  和 <code>slow/fast</code>  指针，不断往后面走，相遇时得到该位置</p>\n<ul>\n<li>时间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>空间复杂度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode *detectCycle(ListNode *head) &#123;\n        ListNode *slow=head,*fast=head;\n        while(fast&amp;&amp;fast-&gt;next)\n        &#123;\n            slow=slow-&gt;next;\n            fast=fast-&gt;next-&gt;next;\n            if(slow==fast)\n            &#123;\n                ListNode* start=head,*meet=slow;\n                while(start!=meet)\n                &#123;\n                    start=start-&gt;next;\n                    meet=meet-&gt;next;\n                &#125;\n                return meet;\n            &#125;\n        &#125;\n        return NULL;\n        \n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表",
                "双指针（快慢指针）"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/80d31d12/",
            "url": "http://dpm12345.github.io/posts/80d31d12/",
            "title": "leetcode 第 273 场周赛",
            "date_published": "2021-12-28T15:20:34.000Z",
            "content_html": "<p>【战绩】</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/leetcode%E7%AC%AC273%E5%9C%BA%E5%91%A8%E8%B5%9B_%E6%88%98%E7%BB%A9.png\" alt=\"leetcode第273场周赛_战绩\" /></p>\n<p>总结:</p>\n<p>此次周赛，成绩差，只做出来了两题，并且第一题还提交错误一次。总的来说题目看得不够清楚，对题目的 推导还比较欠缺</p>\n<p>总结到此，下面是题目解析</p>\n<h1 id=\"反转两次的数字\"><a class=\"anchor\" href=\"#反转两次的数字\">#</a> 反转两次的数字</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYS1udW1iZXItYWZ0ZXItYS1kb3VibGUtcmV2ZXJzYWwv\"> 反转两次的数字</span></p>\n<p>这道题比较简单，可以直接暴力进行两次数字反转得到答案</p>\n<p>但仔细想想会发现，如果一个数字反转两次后是元素，那么原数字末尾必不为 0 (0 除外) ，因为如果存在 0 时 在进行反转后 0 会被删去，数字总位数减少，从而再次进行反转得到的数字必然不会是原来的数字</p>\n<p>以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isSameAfterReversals(int num) &#123;\n        return num==0||num%10!=0;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"执行所有后缀指令\"><a class=\"anchor\" href=\"#执行所有后缀指令\">#</a> 执行所有后缀指令</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXhlY3V0aW9uLW9mLWFsbC1zdWZmaXgtaW5zdHJ1Y3Rpb25zLXN0YXlpbmctaW4tYS1ncmlkLw==\"> 执行所有后缀指令</span></p>\n<p>按照题目要求模拟即可，注意什么时候是行，什么时候是列即可</p>\n<p>代码如下</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; executeInstructions(int n, vector&lt;int&gt;&amp; startPos, string s) &#123;\n        vector&lt;int&gt;ans(s.size());\n        for(int i=0;i&lt;s.size();i++)\n        &#123;\n            int j=0,num=0;\n            vector&lt;int&gt;cur=startPos;\n            for(j=i;j&lt;s.size();j++)\n            &#123;\n                if(s[j]=='L'&amp;&amp;cur[1]&gt;0)\n                &#123;\n                    cur[1]--;\n                    num++;\n                &#125;\n                else if(s[j]=='R'&amp;&amp;cur[1]&lt;n-1)\n                &#123;\n                    cur[1]++;\n                    num++;\n                &#125;\n                else if(s[j]=='U'&amp;&amp;cur[0]&gt;0)\n                &#123;\n                    cur[0]--;\n                    num++;\n                &#125;   \n                else if(s[j]=='D'&amp;&amp;cur[0]&lt;n-1)\n                &#123;\n                    cur[0]++;\n                    num++;\n                &#125;\n                else\n                    break;\n            &#125;\n            ans[i]=num;\n            \n        &#125;\n        return ans;\n        \n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"相同元素的间隔之和\"><a class=\"anchor\" href=\"#相同元素的间隔之和\">#</a> 相同元素的间隔之和</h1>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.github.io/posts/274338ea/",
            "url": "http://dpm12345.github.io/posts/274338ea/",
            "title": "leetcode 第 68 场双周赛",
            "date_published": "2021-12-28T15:20:34.000Z",
            "content_html": "<p>【战绩】</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/leetcode%E7%AC%AC68%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B_%E6%88%98%E7%BB%A9.png\" alt=\"\" /></p>\n<p>总结:</p>\n<p>此次双周赛的成绩，看排名似乎还行，但事实上只在限定时间内做出了第一题，可以说是不太好。总的来说是，接触过的题目太少，知识储备不够造成的，因此之后的策略是涉及多方面的题目、知识与解法</p>\n<p>总结到此，下面是题目解析</p>\n<h1 id=\"句子中的最多单词数\"><a class=\"anchor\" href=\"#句子中的最多单词数\">#</a> 句子中的最多单词数</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1udW1iZXItb2Ytd29yZHMtZm91bmQtaW4tc2VudGVuY2VzLw==\"> 句子中的最多单词数</span></p>\n<p>这题非常简单，计算空格数即可</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int mostWordsFound(vector&lt;string&gt;&amp; sentences) &#123;\n        int ans=0;\n        for(int i=0;i&lt;sentences.size();i++)\n        &#123;\n            int cur=0;\n            for(int j=0;j&lt;sentences[i].size();j++)\n            &#123;\n                if(sentences[i][j]==' ')\n                    cur++;\n            &#125;\n            ans=max(ans,cur+1);\n        &#125;\n        return ans;\n        \n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"从给定原材料中找到所有可以做出的菜\"><a class=\"anchor\" href=\"#从给定原材料中找到所有可以做出的菜\">#</a> 从给定原材料中找到所有可以做出的菜</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1hbGwtcG9zc2libGUtcmVjaXBlcy1mcm9tLWdpdmVuLXN1cHBsaWVzLw==\"> 从给定原材料中找到所有可以做出的菜</span></p>\n<h2 id=\"暴力法\"><a class=\"anchor\" href=\"#暴力法\">#</a> 暴力法</h2>\n<p>根据题目要求，做好的菜可以作为原材料去做其他的菜，那么想法可以是先遍历一遍，如果发现有菜可以做出来，那么将该菜放入存有材料的哈希表中，重新开始循环，并且避免对已经做出来的菜重复计算，那么循环结束后便得到一个完整原材料的哈希表。最后再遍历一次食谱，得到的结果便是答案。</p>\n<p>以下为我自己写的代码 (原以为在周赛时间限制内，但是实际已经过了)</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    void tj(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies,unordered_map&lt;string,int&gt;&amp;a)\n    &#123;\n        int flag=1;       // 判断是否已经是否把所有情况遍历\n        while(flag)\n        &#123;\n            flag=0;      // 假设可以结束了\n            for(int i=0;i&lt;recipes.size();i++)\n            &#123;\n                int j;\n                for(j=0;j&lt;ingredients[i].size();j++)\n                &#123;\n                    if(!a.count(recipes[i])&amp;&amp;!a.count(ingredients[i][j]))   // 发现此菜品不能做出来\n                        break;\n                &#125;\n\t\t\t\t\n\t\t\t\t// 发现菜品没有统计过并且可以做出来，j==ingredients [i].size () 说明原材料都有\n                if(!a.count(recipes[i])&amp;&amp;j==ingredients[i].size())    \n                &#123;\n                    a[recipes[i]]=1;\n                    flag=1;         // 说明有新材料加入，那么重新遍历菜谱\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    vector&lt;string&gt; findAllRecipes(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies) &#123;\n        unordered_map&lt;string,int&gt;a;\n        vector&lt;string&gt;ans; \n        for(int i=0;i&lt;supplies.size();i++)\n        &#123;\n            a[supplies[i]]=1;         // 原材料放入哈希表\n        &#125;\n        tj(recipes,ingredients,supplies,a);         // 统计新的原材料哈希表\n        for(int i=0;i&lt;recipes.size();i++)\n        &#123;\n            int j;\n            for(j=0;j&lt;ingredients[i].size();j++)\n            &#123;\n                if(!a.count(ingredients[i][j]))\n                        break;\n            &#125;\n            if(j==ingredients[i].size())\n            &#123;\n                ans.push_back(recipes[i]);     // 将满足的菜品放入 ans 中\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"拓扑排序\"><a class=\"anchor\" href=\"#拓扑排序\">#</a> 拓扑排序</h2>\n<p>以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;string&gt; findAllRecipes(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies) &#123;\n        int n = recipes.size();\n        // 图\n        unordered_map&lt;string, vector&lt;string&gt;&gt; depend;\n        // 入度统计\n        unordered_map&lt;string, int&gt; cnt;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (const string&amp; ing: ingredients[i]) &#123;\n                depend[ing].push_back(recipes[i]);\n            &#125;\n            cnt[recipes[i]] = ingredients[i].size();\n        &#125;\n        \n        vector&lt;string&gt; ans;\n        queue&lt;string&gt; q;\n        // 把初始的原材料放入队列\n        for (const string&amp; sup: supplies) &#123;\n            q.push(sup);\n        &#125;\n        // 拓扑排序\n        while (!q.empty()) &#123;\n            string cur = q.front();\n            q.pop();\n            if (depend.count(cur)) &#123;\n                for (const string&amp; rec: depend[cur]) &#123;\n                    --cnt[rec];\n                    // 如果入度变为 0，说明可以做出这道菜\n                    if (cnt[rec] == 0) &#123;\n                        ans.push_back(rec);\n                        q.push(rec);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"判断一个括号字符串是否有效\"><a class=\"anchor\" href=\"#判断一个括号字符串是否有效\">#</a> 判断一个括号字符串是否有效</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2hlY2staWYtYS1wYXJlbnRoZXNlcy1zdHJpbmctY2FuLWJlLXZhbGlkLw==\">判断一个括号字符串是否有效</span></p>\n<h2 id=\"两次遍历正序遍历和逆序遍历\"><a class=\"anchor\" href=\"#两次遍历正序遍历和逆序遍历\">#</a> 两次遍历，正序遍历和逆序遍历。</h2>\n<p>首先排除奇数个数的情况，因为括号数为奇数时必不可能两两配对</p>\n<p>正序遍历时，用 count 记录此时不可修改的右括号数，在遍历时时候比对当前数目的右括号数与剩下的最多左括号数，如果后者小于前者，那么不可能经过改变得到有效的括号字符串</p>\n<p>逆序遍历时，同正序遍历时的方法，用 count 记录此时不可修改左括号数，在遍历时时候比对当前数目的右括号数与剩下的最多左括号数，如果后者小于前者，那么不可能经过改变得到有效的括号字符串</p>\n<p>两次遍历结束后若都不会返回 false，那么说明肯定存在一种情况使得左括号与右括号恰好两两配对</p>\n<p>因为一个是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>&gt;</mo><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L&gt;=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span> 另一个是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>L</mi><mo>&lt;</mo><mo>=</mo><mi>R</mi></mrow><annotation encoding=\"application/x-tex\">L&lt;=R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span></span></span></span>，如果两种都满足则会有相等使其配对的情况，所以最后能得到正确结果</p>\n<p>以下为参考代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool canBeValid(string s, string locked) &#123;\n        if(s.size()%2==1) return false;\n        int l=0,r=0;\n        for(int i=0;i&lt;s.size();i++)\n        &#123;\n            if(locked[i]=='1'&amp;&amp;s[i]==')')\n                r++;\n            if(i+1-r&lt;r)                  // 最大左括号数小于右括号数\n                return false;\n        &#125;\n        for(int i=s.size()-1;i&gt;=0;i--)\n        &#123;\n            if(locked[i]=='1'&amp;&amp;s[i]=='(')\n                l++;\n            if(s.size()-i-l&lt;l)           // 最大右括号数小于左括号数\n                return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"贪心算法一次遍历用-maxc-记录最大未匹配数minc-记录最小未匹配数\"><a class=\"anchor\" href=\"#贪心算法一次遍历用-maxc-记录最大未匹配数minc-记录最小未匹配数\">#</a> 贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数</h2>\n<p>首先排除奇数个数的情况，因为括号数为奇数时必不可能两两配对</p>\n<p>当遇到不可变的右 (左) 括号时， <code>maxc</code>  和 <code>minc</code>  都加一 (减一), 如果在此期间 <code>maxc&lt;0</code> ，那么证明有右括号不能被匹配那么这串字符串是无效的</p>\n<p>当遇到可变的位置时，由于既可以变也可以不变，那么 <code>maxc++</code> ， <code>minc−−</code> ，其中如果 <code>minc</code>  减之前如果是 0，那么 <code>minc</code>  就变为 1，因为会增加</p>\n<p>如果在遍历过程中， <code>minc&gt;maxc</code> ，那么证明该串是无效的</p>\n<p>最后如果该串是有效，那么 <code>minc</code>  必为 0，所以返回值为 <code>minc==0</code></p>\n<p>以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool canBeValid(string s, string locked) &#123;\n        if(s.size()%2==1)  return false;\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        &#123;\n            if(locked[i]=='1')\n            &#123;\n                if(s[i]=='(')\n                &#123;\n                    minc++;\n                    maxc++;\n                &#125;\n                if(s[i]==')')\n                &#123;\n                    maxc--;\n                    minc=minc==0?1:minc-1;\n                    if(maxc&lt;0)\n                        return false;\n                &#125;\n            &#125;\n            else\n            &#123;\n                minc=minc==0?1:minc-1;\n                maxc++;\n            &#125;\n            if(minc&gt;maxc)\n                return false;\n        &#125;\n        return minc==0;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"一个区间内所有数乘积的缩写\"><a class=\"anchor\" href=\"#一个区间内所有数乘积的缩写\">#</a> 一个区间内所有数乘积的缩写</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWJicmV2aWF0aW5nLXRoZS1wcm9kdWN0LW9mLWEtcmFuZ2Uv\">一个区间内所有数乘积的缩写</span></p>\n<p>目前学习中......</p>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.github.io/posts/4a8b7903/",
            "url": "http://dpm12345.github.io/posts/4a8b7903/",
            "title": "方法总结",
            "date_published": "2021-12-26T02:20:40.000Z",
            "content_html": "<h1 id=\"括号问题\"><a class=\"anchor\" href=\"#括号问题\">#</a> 括号问题</h1>\n<h2 id=\"是否为有效括号\"><a class=\"anchor\" href=\"#是否为有效括号\">#</a> 是否为有效括号</h2>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv\">有效的括号</span></p>\n<p>可采用栈的先入后出特性，一个个匹配</p>\n<h2 id=\"判断一段字符串经过部分修改后是否能够成为有效括号字符串可以修改的位置由-locked-存储\"><a class=\"anchor\" href=\"#判断一段字符串经过部分修改后是否能够成为有效括号字符串可以修改的位置由-locked-存储\">#</a> 判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由 locked 存储</h2>\n<p>如 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzaXMtc3RyaW5nLw==\">有效的括号字符串</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2hlY2staWYtYS1wYXJlbnRoZXNlcy1zdHJpbmctY2FuLWJlLXZhbGlkLw==\">判断一个括号字符串是否有效</span></p>\n<p>利用平衡值的方法，一个字符串是否为有效括号，那么在某个位置前的右括号之前必然有左括号相匹配，在某个某个位置的左括号之后必然有右括号相匹配</p>\n<p>以下为几种不同的具体方法</p>\n<h3 id=\"两次遍历正序遍历和逆序遍历\"><a class=\"anchor\" href=\"#两次遍历正序遍历和逆序遍历\">#</a> 两次遍历，正序遍历和逆序遍历。</h3>\n<p>正序遍历时，用 count 记录此时未匹配左括号数，其中如果 <code>locked[i]=′0′</code> ，那么以左括号来记，当匹配到不可变的右括号时， <code>count−−</code> ，如果 <code>count &lt; 0</code>  出现了，那么该字符串不是有效的括号字符串</p>\n<p>逆序遍历时，同正序遍历时的方法，用 count 记录此时未匹配右括号数，其中如果 <code>locked[i]=′0′</code> ，那么以右括号来记，当匹配到不可变的左括号时， <code>count−−</code> ，如果 <code>count &lt; 0</code>  出现了，那么该字符串不是有效的括号字符串</p>\n<p>以下为参考代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool checkValidString(string s) &#123;\n        int count=0;\n        for(int i=0;i&lt;s.size();i++)\n        &#123;\n            if(s[i]=='('||s[i]=='*')\n                count++;\n            else\n                count--;\n            if(count&lt;0)\n                return false;\n        &#125;\n        count=0;\n        for(int i=s.size()-1;i&gt;=0;i--)\n        &#123;\n            if(s[i]==')'||s[i]=='*')\n                count++;\n            else\n                count--;\n            if(count&lt;0)\n                return false;\n        &#125;\n        return true;\n    &#125;\n&#125;;\n</code></pre>\n<h3 id=\"贪心算法一次遍历用-maxc-记录最大未匹配数minc-记录最小未匹配数\"><a class=\"anchor\" href=\"#贪心算法一次遍历用-maxc-记录最大未匹配数minc-记录最小未匹配数\">#</a> 贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数</h3>\n<p>当遇到不可变的右 (左) 括号时 <code>maxc</code> ，和 <code>minc</code>  都加一 (减一), 如果在此期间， <code>maxc &lt; 0</code> ，那么证明有右括号不能被匹配那么这串字符串是无效的</p>\n<p>当遇到可变的位置时，由于既可以变也可以不变，那么 <code>maxc++</code> ， <code>minc--</code> ；其中如果 <code>minc</code>  减之前如果是 0，那么 <code>minc</code>  就变为 1，因为会增加 (如果是 <code>*</code>  可代表左右括号或者空字符，那么只需维护 <code>minc&gt;=0</code>  即可，因为 <code>*</code>  有三种状态)</p>\n<p>如果在遍历过程中， <code>minc &gt; maxc</code> ，那么证明该串是无效的</p>\n<p>最后如果该串是有效，那么 <code>minc</code>  必为 0，所以返回值为 <code>minc == 0</code></p>\n<p>代码示例</p>\n<h4 id=\"第一道\"><a class=\"anchor\" href=\"#第一道\">#</a> 第一道</h4>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool checkValidString(string s) &#123;\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        &#123;\n            if(s[i]=='(')\n            &#123;\n                minc++;\n                maxc++;\n            &#125;\n            else if(s[i]==')')\n            &#123;\n                minc=minc==0?0:minc-1;\n                maxc--;\n                if(maxc&lt;0)\n                    return false;\n            &#125;\n            else\n            &#123;\n                minc=minc==0?0:minc-1;\n                maxc++;\n            &#125;\n        &#125;\n        return minc==0;\n    &#125;\n&#125;;\n</code></pre>\n<h4 id=\"第二道\"><a class=\"anchor\" href=\"#第二道\">#</a> 第二道</h4>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool canBeValid(string s, string locked) &#123;\n        if(s.size()%2==1)  return false;\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        &#123;\n            if(locked[i]=='1')\n            &#123;\n                if(s[i]=='(')\n                &#123;\n                    minc++;\n                    maxc++;\n                &#125;\n                if(s[i]==')')\n                &#123;\n                    maxc--;\n                    minc=minc==0?1:minc-1;\n                    if(maxc&lt;0)\n                        return false;\n                &#125;\n            &#125;\n            else\n            &#123;\n                minc=minc==0?1:minc-1;\n                maxc++;\n            &#125;\n            if(minc&gt;maxc)\n                return false;\n        &#125;\n        return minc==0;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "贪心",
                "括号"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/12ad1f11/",
            "url": "http://dpm12345.github.io/posts/12ad1f11/",
            "title": "全排列",
            "date_published": "2021-12-24T01:54:40.000Z",
            "content_html": "<h1 id=\"无重复数字的全排列\"><a class=\"anchor\" href=\"#无重复数字的全排列\">#</a> 无重复数字的全排列</h1>\n<p>先考虑 2 个数的全排列，很明显就是只有两种，一种两个数字的顺序不改变，另一种改变两个数字的顺序</p>\n<p>然后再考虑 3 个数的全排列，比如 <code>1，2，3</code></p>\n<p>那么总共排列的种类总共为</p>\n<p>1，2，3<br />\n1，3，2<br />\n2，1，3<br />\n2，3，1<br />\n3，1，2<br />\n3，2，1</p>\n<p>由此不难发现，每一次的排列总个数（不同的数字开头）都可以看作是在前一种的基础上交换两个数的结果</p>\n<p>例如 <code>1，3，2</code>  是在 <code>1，2，3</code>  的基础上交换 2，3 位置后得到的。以此类推，4 个数，5 个数，n 个数也一样。那么在这里可以采用递归方法，与汉诺塔问题相似，我们将 n 个数划分为 1 和 n-1 个数，先交换两部分得到一种情况，然后以此为基础再进行交换，结束此种情况后将数字交换回来进入下一种情况</p>\n<p>因此我们可以构造 perm 函数，第一个形参为数组，第二个为未交换数，第三个为数组的末尾下标</p>\n<p>因此核心代码为:</p>\n<pre><code class=\"language-c++\">// 假设这里的递归函数为 perm，数组为 nums，交换的对象为 nums [i] 和 nums [k]\n\tfor(int i=k;i&lt;=m;i++)        // 这里用于把后面的数进行交换\n\t&#123;\n        swap(nums[i],nums[k]);            // 交换，创造新的情况\n\t    perm(nums,k+1,m);                 // 进入新的情况，k+1 为之后未交换的情况\n\t\tswap(nums[i],nums[k]);           // 交换回来\n\t&#125;\n</code></pre>\n<p>这里我们需要考虑原来的情况，也就是说此时不需要交换，所以为了保持代码的一致性，可以一开始使其与自身交换，因此为 <code>swap(nums[i],nums[k])</code></p>\n<p>代码如下</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    void swap(int*p,int*q)\n    &#123;\n        int temp=*p;\n        *p=*q;\n        *q=temp;\n    &#125;\n    void out(vector&lt;int&gt;&amp;nums,vector&lt;vector&lt;int&gt;&gt;&amp;ans,int k,int m)\n    &#123;\n        if(k==m)\n        &#123;\n            ans.push_back(nums);\n        &#125;\n        else\n        &#123;\n            for(int i=k;i&lt;=m;i++)\n            &#123;\n                swap(&amp;nums[i],&amp;nums[k]);\n                out(nums,ans,k+1,m);\n                swap(&amp;nums[i],&amp;nums[k]);\n            &#125;\n        &#125;\n    &#125;\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt;ans;\n        out(nums,ans,0,nums.size()-1);\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<p>该问题在 leetcode 也有题目</p>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==\">全排列</span></p>\n<h1 id=\"有重复数字的全排列\"><a class=\"anchor\" href=\"#有重复数字的全排列\">#</a> 有重复数字的全排列</h1>\n",
            "tags": [
                "递归"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/415dc2d2/",
            "url": "http://dpm12345.github.io/posts/415dc2d2/",
            "title": "leetcode 第 272 场周赛",
            "date_published": "2021-12-19T15:20:34.000Z",
            "content_html": "<p>【战绩】</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/leetcode%E7%AC%AC272%E5%9C%BA%E5%91%A8%E8%B5%9B_%E6%88%98%E7%BB%A9.png\" alt=\"\" /></p>\n<p>总结:</p>\n<p>第一场按时参与的 leetcode 周赛，总的来说，这次的题目并不是很难，思路会有，而自己却写不出来，最主要还是细节方面和一些算法的不熟悉，不能够做到完全吸收，就拿第四题说，我能想到解题方向为先将下</p>\n<p>标间隔为 k 的元素构成一个个数组，然后求这些数组各自内部的最长非严格上升子序列的长度，最后用数组原长度减去这一最长非严格上升子序列的长度即为这一数组的最少修改值，答案即为所有数组的最少修改值。</p>\n<p>但最后我并没有写出来，更加不好的是，我明白怎么去求最长非严格上升序列的动态规划求法，但脑中并未有其时间复杂度更小的贪心 + 二分查找解法，为此我还去搜求最长严格递增的贪心 + 二分查找解法，但自己并</p>\n<p>未理解该算法的核心，也并不知道怎么修改才能作为求最长非严格上升子序列的代码</p>\n<p>总结到此，下面进行题目解析</p>\n<h1 id=\"找出数组中的第一个回文字符串\"><a class=\"anchor\" href=\"#找出数组中的第一个回文字符串\">#</a> 找出数组中的第一个回文字符串</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1wYWxpbmRyb21pYy1zdHJpbmctaW4tdGhlLWFycmF5Lw==\">找出数组中的第一个回文字符串</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"找出数组中的第一个回文字符串_题目详情\" /></p>\n<p>思路：</p>\n<p>这题比较简单，只需写一个函数用于判断是否为回文串，若是则直接输出，结束程序</p>\n<p>以下为代码：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool if_hw(string &amp;s)\n    &#123;\n        for(int i=0;i&lt;s.length()/2;i++)\n        &#123;\n            if(s[i]!=s[s.length()-i-1])\n                return false;\n        &#125;\n        return true;\n    &#125;\n    string firstPalindrome(vector&lt;string&gt;&amp; words) &#123;\n        for(int i=0;i&lt;words.size();i++)\n        &#123;\n            if(if_hw(words[i]))\n                return words[i];\n        &#125;\n        return &quot;&quot;;\n    &#125;\n&#125;;\n</code></pre>\n<p>或者使用迭代器</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    string firstPalindrome(vector&lt;string&gt;&amp; a) &#123;\n        for(string s : a) &#123;\n            if(s == string(s.rbegin(), s.rend())) return s;\n        &#125;\n        return &quot;&quot;;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"向字符串添加空格\"><a class=\"anchor\" href=\"#向字符串添加空格\">#</a> 向字符串添加空格</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkaW5nLXNwYWNlcy10by1hLXN0cmluZy8=\">向字符串添加空格</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"向字符串添加空格_题目详情\" /></p>\n<p>思路:</p>\n<p>这题也比较简单，只需遍历时，在对应位置添上空格即可，可使用 if 解决</p>\n<p>以下为代码：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    string addSpaces(string s, vector&lt;int&gt;&amp; spaces) &#123;\n        int index=0;\n        string ans;\n        for(int i=0;i&lt;s.length();i++)\n        &#123;\n            if(index&lt;spaces.size()&amp;&amp;i==spaces[index])\n            &#123;\n                ans.push_back(' ');\n                index++;\n            &#125;\n            ans.push_back(s[i]);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"股票平滑下跌阶段的数目\"><a class=\"anchor\" href=\"#股票平滑下跌阶段的数目\">#</a> 股票平滑下跌阶段的数目</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLXNtb290aC1kZXNjZW50LXBlcmlvZHMtb2YtYS1zdG9jay8=\">股票平滑下跌阶段的数目</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E8%82%A1%E7%A5%A8%E5%B9%B3%E6%BB%91%E4%B8%8B%E8%B7%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%B0%E7%9B%AE_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"股票平滑下跌阶段的数目_题目详情\" /></p>\n<p>思路:</p>\n<p>观察可知，平滑下跌阶段即为公差为 <code>-1</code>  的等差数列，而要具体求出结果就可以为先求数组中的各个最长等差数列的长度，然后存入，最后只需加上各个等差数列长度的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>+</mo><mtext>・・・</mtext><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">n+(n-1)+n-1+・・・+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord cjk_fallback\">・</span><span class=\"mord cjk_fallback\">・</span><span class=\"mord cjk_fallback\">・</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<p>得到答案</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    long long cal(long long n)\n    &#123;\n        long long ans=0;\n        while(n!=0)\n        &#123;\n            ans+=n--;\n        &#125;\n        return ans;\n    &#125;\n    long long getDescentPeriods(vector&lt;int&gt;&amp; prices) &#123;\n        vector&lt;long long&gt;record;\n        long long sum=0;\n        for(int i=0;i&lt;prices.size();i++)\n        &#123;\n            if(sum==0)\n                sum++;\n            else\n            &#123;\n                if(prices[i]==prices[i-1]-1)\n                &#123;\n                    sum++;\n                &#125;\n                else\n                &#123;\n                    record.push_back(sum);\n                    sum=1;\n                &#125;\n            &#125;\n        &#125;\n        if(sum!=0)\n            record.push_back(sum);\n        long long ans=0;\n        for(int i=0;i&lt;record.size();i++)\n        &#123;\n            ans+=cal(record[i]);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<p>大佬的代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    long long getDescentPeriods(vector&lt;int&gt;&amp; a) &#123;\n        long long ans = 0;\n        for(int i = 0; i &lt; a.size(); ) &#123;\n            int j = i;\n            while(j &lt; a.size() &amp;&amp; a[j] - a[i] == i - j) ++j;\n            ans += (long long)(j - i) * (j - i + 1) / 2;\n            i = j;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<p>思路相同，但用来了更为简便的写法<br />\n相对于我的代码，我的显得过于繁琐，其实无需将个数存入新的数组，而是可以边得到边计算，而计算时用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>j</mi><mtext>−</mtext><mi>i</mi><mo stretchy=\"false\">)</mo><mtext>∗</mtext><mo stretchy=\"false\">(</mo><mi>j</mi><mtext>−</mtext><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">(j−i)∗(j−i+1)/2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord\">−</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mord\">∗</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mord\">−</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span></span></span></span><s> 我怎么就忘了呢</s></p>\n<h1 id=\"使数组-k-递增的最少操作次数\"><a class=\"anchor\" href=\"#使数组-k-递增的最少操作次数\">#</a> 使数组 K 递增的最少操作次数</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1vcGVyYXRpb25zLXRvLW1ha2UtdGhlLWFycmF5LWstaW5jcmVhc2luZy8=\">使数组 K 递增的最少操作次数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%BD%BF%E6%95%B0%E7%BB%84K%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"使数组K递增的最少操作次数_题目详情\" /></p>\n<p>思路：在总结中我差不多讲过，这里简略讲一下</p>\n<p>题目要求求使数组 K 递增的最少操作次数，我们将相差 k 下标的元素排列在一起，若想要让其非严格递增，求最少修改数，不难得到此结论，若想在花最少次数得到非严格递增数列，那么该次数一定为该数列里的最长非严格递增子序列的长度与该序列长度的差值</p>\n<p>而求最长非严格递增子序列的长度的方法有两种，一种动态规划，另一种是贪心 + 二分。</p>\n<p>在这道题里，因为动态规划时间复杂度较高，很容易超出时间限制，故这题采用贪心 + 二分</p>\n<p>【相关题目】:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==\">【最长递增子序列】</span></p>\n<p>所以说接下来所要做的事为：</p>\n<ol>\n<li>将下标相差 k 的元素放在一起，构成新的数组</li>\n<li>求出该数组的最长非严格递增子序列的长度与数组长度的差值</li>\n<li>将各差值相加</li>\n</ol>\n<p>该方法具体原理</p>\n<p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>\n<p>基于上面的贪心思路，我们维护一个数组 <code>d[i]</code> ，表示长度为 <code>i</code>  的最长上升子序列的末尾元素的最小值， 用 <code>len</code>  记录目前最长上升子序列的长度，起始时 <code>len</code>  为 <code>1</code> ， <code>d[1]=nums[0]</code> 。</p>\n<p>同时我们可以注意到 <code>d[i]</code>  是关于 <code>i</code>  单调递增的。因为如果 <code>d[j]≥d[i]</code>  且 <code>j &lt; i</code> ，我们考虑从长度为 <code>i</code>  的最长上升子序列的末尾删除 <code>i-j</code>  个元素，那么这个序列长度变为 <code>j</code> ，且第 <code>j</code>  个元素 <code>x</code> （末尾元素）必然小于 <code>d[i]</code> ，也就小于 <code>d[j]</code> 。那么我们就找到了一个长度为 <code>j</code>  的最长上升子序列，并且末尾元素比 <code>d[j]</code>  小， 从而产生了矛盾。因此数组 <code>d</code>  的单调性得证。</p>\n<p>我们依次遍历数组 <code>nums</code>  中的每个元素，并更新数组 <code>d</code>  和 <code>len</code>  的值。如果 <code>nums [i]&gt;d [len]</code>  则更新 <code>len = len + 1</code> ，否则在 <code>d[1…len]</code>  中找满足 <code>d[i−1] &lt; nums[j] &lt; d[i]</code>  的下标 <code>i</code> ，并更新 <code>d[i] = nums[j]</code></p>\n<p>根据 d 数组的单调性，我们可以使用二分查找寻找下标 <code>i</code> ，优化时间复杂度。</p>\n<p>最后整个算法流程为：</p>\n<p>设当前已求出的最长上升子序列的长度为 <code>len</code>  初始时为 1），从前往后遍历数组 <code>nums</code> ，在遍历到 <code>nums[i]</code>  时：</p>\n<p>如果 <code>nums [i]&gt;d [len]</code> ，则直接加入到 d 数组末尾，并更新 <code>len = len + 1</code></p>\n<p>否则，在 d 数组中二分查找，找到第一个比 <code>nums[i]</code>  小的数 <code>d[k]</code> ，并更新 <code>d[k+1]=nums[i]</code> 。</p>\n<p>以输入序列 <code>[0, 8, 4, 12, 2]</code>  为例：</p>\n<p>第一步插入 0，d = [0];</p>\n<p>第二步插入 8，d = [0, 8];</p>\n<p>第三步插入 4，d = [0, 4];</p>\n<p>第四步插入 12，d = [0, 4, 12];</p>\n<p>第五步插入 2，d = [0, 2, 12];</p>\n<p>最终得到最大递增子序列长度为 3。</p>\n<p>-- 摘自 leetcode 官方题解 (最长递增子序列)</p>\n<p>与本题区别： 上面的解析是针对严格递增的，不能有重复元素，而在本题中，是有重复元素，即不严格递增，所以在找寻 插入位置时会有所不同，当发现有数大于等于末位数时，直接接在后面，若小于，那么找出大于这个数的第一个数</p>\n<p>以下为代码：</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int search(vector&lt;int&gt;&amp;nums)\n    &#123;\n        int n=nums.size();\n        int index=1;\n        vector&lt;int&gt;dp(n+1);\n        dp[index]=nums[0];\n        for(int i=1;i&lt;n;i++)\n        &#123;\n            if(nums[i]&gt;=dp[index])\n            &#123;\n                dp[++index]=nums[i];\n            &#125;\n            else\n            &#123;\n                int left=1,right=index;\n                while(left&lt;=right)\n                &#123;\n                    int mid=(left+right)/2;\n                    if(nums[i]&gt;=dp[mid])\n                    &#123;\n                        left=mid+1;\n                    &#125;\n                    else\n                    &#123;\n                        right=mid-1;\n                    &#125; \n                &#125;\n                dp[left]=nums[i];\n            &#125;\n        &#125;\n        return index;\n    &#125;\n    int kIncreasing(vector&lt;int&gt;&amp; arr, int k) &#123;\n        vector&lt;int&gt;sum(arr.size());\n        for(int i=0;i&lt;k;i++)\n            sum[i]=i;\n        for(int i=k;i&lt;arr.size();i++)\n        &#123;\n            sum[i]=sum[i-k];\n        &#125;\n        vector&lt;vector&lt;int&gt;&gt;record(k,vector&lt;int&gt;(0));\n        for(int i=0;i&lt;arr.size();i++)\n        &#123;\n            record[sum[i]].push_back(arr[i]);\n        &#125;\n        int ans=0;\n        for(int i=0;i&lt;record.size();i++)\n        &#123;\n            ans+=record[i].size()-search(record[i]);\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.github.io/posts/3b3e846/",
            "url": "http://dpm12345.github.io/posts/3b3e846/",
            "title": "换酒问题",
            "date_published": "2021-12-17T06:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2F0ZXItYm90dGxlcy8=\"> 换酒问题</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<h1 id=\"模拟\"><a class=\"anchor\" href=\"#模拟\">#</a> 模拟</h1>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numWaterBottles(int numBottles, int numExchange) &#123;\n        int ans=0,have=numBottles,empty=0;\n        while(have!=0)\n        &#123;\n            ans+=have;\n            empty+=have;\n            have=empty/numExchange;\n            empty=empty%numExchange;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"数学\"><a class=\"anchor\" href=\"#数学\">#</a> 数学</h1>\n<p>假设开始有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个酒瓶，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span></span></span></span> 个空酒瓶换一瓶酒，那么每次消耗的酒瓶数为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">m-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，所以答案即为</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mfrac><mi>n</mi><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo stretchy=\"false\">⌋</mo></mrow><annotation encoding=\"application/x-tex\">\\lfloor \\frac{n}{m-1} \\rfloor\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.8768900000000002em;vertical-align:-0.7693300000000001em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.10756em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7693300000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span></span></span></span></span></p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numWaterBottles(int numBottles, int numExchange) &#123;\n        return numBottles &gt;= numExchange ? (numBottles - numExchange) / (numExchange - 1) + 1 + numBottles : numBottles;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.github.io/posts/d8bfa4d3/",
            "url": "http://dpm12345.github.io/posts/d8bfa4d3/",
            "title": "leetcode 第 271 场周赛",
            "date_published": "2021-12-12T15:20:34.000Z",
            "content_html": "<p>写在前面：这次是自己报名的第一场周赛，但最后忘记了有这一回事了，所以要记得给自己设个闹钟，提醒自己</p>\n<p>弥补：虽然错过了，但题目不能不做</p>\n<p>以下是之后做的</p>\n<h1 id=\"环和杆\"><a class=\"anchor\" href=\"#环和杆\">#</a> 环和杆</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmluZ3MtYW5kLXJvZHMv\">环和杆</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%853.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%854.png\" alt=\"\" /></p>\n<p>该题是明显的计数题，记录每一条杆上不同颜色的环的数量，当三种颜色数量都不为零时，总个数加一</p>\n<h2 id=\"解法一\"><a class=\"anchor\" href=\"#解法一\">#</a> 解法一</h2>\n<p>利用数组</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countPoints(string rings) &#123;\n        vector&lt;vector&lt;int&gt;&gt;a(10,vector&lt;int&gt;(3));     // 总共最多有 10 个杆，a [i][0],a [i][1],a [i][2]\n\t\t                                             // 分别记录 R、G、B 的个数\n        for(int i=0;i&lt;rings.length();i+=2)\n        &#123;\n            if(rings[i]=='R')\n            &#123;\n                a[rings[i+1]-48][0]++;\n            &#125;\n            else if(rings[i]=='G')\n            &#123;\n                a[rings[i+1]-48][1]++;\n            &#125;\n            else if(rings[i]=='B')\n            &#123;\n                a[rings[i+1]-48][2]++;\n            &#125;\n        &#125;\n        int ans=0;\n        for(int i=0;i&lt;=9;i++)\n        &#123;\n            if(a[i][0]&amp;&amp;a[i][1]&amp;&amp;a[i][2])     // 当三种杆数量都不为 0 时，ans 加一\n            ans++;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"解法二\"><a class=\"anchor\" href=\"#解法二\">#</a> 解法二</h2>\n<p>下面为周赛用时最少的 Aoxiang Cui 的代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int countPoints(string s) &#123;\n        map&lt;char, int&gt; A;\n        A['R'] = 0;\n        A['G'] = 1;\n        A['B'] = 2;\n        vector&lt;int&gt; cnt(10);\n        for (int i = 0; i &lt; (int)s.size(); i += 2) &#123;\n            int x = A[s[i]];\n            int y = s[i + 1] - '0';\n            cnt[y] |= 1 &lt;&lt; x;\n        &#125;\n        int ret = 0;\n        for (int k = 0; k &lt; 10; ++k) &#123;\n            if (cnt[k] == 7) ++ret;\n        &#125;\n        return ret;\n        \n    &#125;\n&#125;;\n</code></pre>\n<p>借鉴经验：</p>\n<p>在该题中我的方法中的若找到某个字母，则在对应的数组位置加一，最后需判断三个代表 环的元素是否大于零，需要用 <code>if</code>  来判断，缺点是单判断的个数变多是，代码则会显得冗长 而在其所用的是二进制的计数法，</p>\n<p>因为二进制的特点为 <code>0，1</code>  组合，那么这样可以把不同的位看作是一个一个的容器，当存储某个东西时，可将该容器值变为 <code>1</code></p>\n<p>该方法中的核心代码便是：</p>\n<pre><code class=\"language-c++\">int x = A[s[i]];\nint y = s[i + 1] - '0';\ncnt[y] |= 1 &lt;&lt; x;\n</code></pre>\n<p>这几行代码表示的意思分别为</p>\n<p>第一行：对读到的环进行判断，依据之前的 map，找到对应容器</p>\n<p>第二行：对读到的杆编号转化为 int 类型</p>\n<p>第三行：将该环存入，1&lt;&lt;x 表示的为环所在位置</p>\n<p>那么当所有环都存完后，那么如果三个环都存入，那么 <code>cnt[i]</code>  的值必然是 <code>7</code> ，</p>\n<p>因为在该方法中，由 map，R、G、B 对应的位置分别为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>1</mn></msup><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>2</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^0,2^1,2^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.008548em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span>, 如果都存入，三个</p>\n<p>位置显示都为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，那么<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>7</mn></mrow><annotation encoding=\"application/x-tex\">cnt[i]=2^0+2^1+2^2=7</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">7</span></span></span></span></p>\n<p>所以结尾处代码为</p>\n<pre><code class=\"language-c++\">for (int k = 0; k &lt; 10; ++k) \n&#123;\n     if (cnt[k] == 7) ++ret;\n&#125;\n</code></pre>\n<h1 id=\"子数组范围和\"><a class=\"anchor\" href=\"#子数组范围和\">#</a> 子数组范围和</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LXJhbmdlcy8=\">子数组范围和</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\" alt=\"\" /></p>\n<p>方法：滑动窗口 (暴力)</p>\n<p><code>i</code>  遍历每一个数组开头，开始增加窗口长度之前，先更新 <code>MAX</code>  和 <code>MIN</code>  的值，之后 <code>j</code>  从 <code>i+1</code>  开始不断增加 增加的过程中不断更新 <code>MAX</code> ， <code>MIN</code>  的值，更新完后加上最大值减去最小值的值，如此，循环结束后 自然能够得到答案</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    long long subArrayRanges(vector&lt;int&gt;&amp; nums) &#123;\n        long long MAX,MIN,ans=0;\n        for(int i=0;i&lt;nums.size();i++)\n        &#123;\n            MAX=MIN=nums[i];\n            for(int j=i+1;j&lt;nums.size();j++)\n            &#123;\n                MAX=fmax(MAX,nums[j]);\n                MIN=fmin(MIN,nums[j]);\n                ans+=MAX-MIN;      \n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"给植物浇水-ii\"><a class=\"anchor\" href=\"#给植物浇水-ii\">#</a> 给植物浇水 II</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2F0ZXJpbmctcGxhbnRzLWlpLw==\">给植物浇水 II</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%853.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%854.png\" alt=\"\" /></p>\n<h2 id=\"方法一\"><a class=\"anchor\" href=\"#方法一\">#</a> 方法一</h2>\n<p>我的思路：题目中要求求重新灌满水的次数，由题可知，两人浇水过程的位置是对称的， 所以说浇完后两人的次数要么相等要么相差 <code>1</code>  ，那么每一位置的浇水量必然不大于该人的水罐容量，也就不需要考虑某人浇不了水要等另一个人浇 (这样就明显变为另一个题目了)</p>\n<p>(或许可以有这样的题目: &quot;如果两人分别从两边开始浇水，若可以浇水，则浇，若水量不够则重新灌水，若还是不够，则选择原地等待，等另一个人浇。请返回以下值，若可以全浇完，返回重新灌水次数，若不行，返回 - 1&quot;)</p>\n<p>接上面思路：</p>\n<p>这样我们可以知道，每个人浇水次数至少是植物数整除 2 的结果，所以我们可以用循环循环这一次数，结束时，根据提示， <code>plants[i]&gt;0</code> ，所以可在浇完水后将浇完水的植物 <code>plant[i]</code>  赋值 <code>0</code> ，最后只需判断最中间</p>\n<p>的 <code>plants[i]</code>  是否为 <code>0</code> ，若不为 <code>0</code> ，则还需再浇一次，因此判断两人剩余量的最大值是否可行，不可行则灌水次数加一</p>\n<p>据上面分析，我们所需要的变量为： <code>curA</code>  记录 Alice 剩余水量， <code>curB</code>  记录 <code>Bob</code>  剩余水量， <code>ans</code>  记录总灌水次数， <code>time</code>  记录最少浇水次数</p>\n<p>以下为代码:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minimumRefill(vector&lt;int&gt;&amp; plants, int capacityA, int capacityB) &#123;\n        int times=plants.size()/2;\n        int curA=capacityA,curB=capacityB;\n        int ans=0;\n        for(int i=0;i&lt;times;i++)\n        &#123;\n            if(curA&gt;=plants[i])\n            &#123;\n                curA-=plants[i];\n                plants[i]=0;\n            &#125;\n            else\n            &#123;\n                ans++;\n                curA=capacityA-plants[i];\n                plants[i]=0;\n            &#125;\n            if(curB&gt;=plants[plants.size()-1-i])\n            &#123;\n                curB-=plants[plants.size()-1-i];\n                plants[plants.size()-1-i]=0;\n            &#125;\n            else\n            &#123;\n                ans++;\n                curB=capacityB-plants[plants.size()-1-i];\n                plants[plants.size()-1-i]=0;\n            &#125;\n        &#125;\n        if(plants[times])\n        &#123;\n            if(max(curA,curB)&lt;plants[times])\n            ans++;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minimumRefill(vector&lt;int&gt;&amp; plants, int capacityA, int capacityB) &#123;\n        int n = plants.size(), ans = 0, a = capacityA, b = capacityB;\n        for (int i = 0, j = n - 1; i &lt; j; ++i, --j) &#123;\n            if (a &lt; plants[i]) a = capacityA, ++ans;\n            a -= plants[i];\n            if (b &lt; plants[j]) b = capacityB, ++ans;\n            b -= plants[j];\n        &#125;\n        if (n &amp; 1 &amp;&amp; max(a, b) &lt; plants[n / 2]) ++ans;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"方法二\"><a class=\"anchor\" href=\"#方法二\">#</a> 方法二</h2>\n<h1 id=\"摘水果\"><a class=\"anchor\" href=\"#摘水果\">#</a> 摘水果</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1mcnVpdHMtaGFydmVzdGVkLWFmdGVyLWF0LW1vc3Qtay1zdGVwcy8=\">摘水果</span></p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) &#123;\n        int n = fruits.size();\n        \n        // 前缀和，用于求区间 [l, r] 共有多少水果\n        vector&lt;int&gt; sum;\n        sum.push_back(0);\n        for (int i = 1; i &lt;= n; ++ i)\n            sum.push_back(fruits[i - 1][1] + sum[i - 1]);\n\n        vector&lt;int&gt; pos;\n        for (int i = 0; i &lt; n; ++ i)\n            pos.push_back(fruits[i][0]);\n\n        // 枚举可能抵达的区间\n        int ans = 0;\n        for (int x = k; x &gt;= 0; -- x)\n        &#123;\n            int y = (k - x) / 2;\n            int l, r;\n            // x + 2y = k\n            l = startPos - x, r = startPos + y;\n            auto pl = lower_bound(pos.begin(), pos.end(), l) - pos.begin(), pr = upper_bound(pos.begin(), pos.end(), r) - pos.begin();\n            ans = max(ans, sum[pr] - sum[pl]);\n            // 2y + x = k\n            l = startPos - y, r = startPos + x;\n            pl = lower_bound(pos.begin(), pos.end(), l) - pos.begin(), pr = upper_bound(pos.begin(), pos.end(), r) - pos.begin();\n            ans = max(ans, sum[pr] - sum[pl]);\n        &#125;\n        \n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.github.io/posts/9e6e8fdc/",
            "url": "http://dpm12345.github.io/posts/9e6e8fdc/",
            "title": "子序列问题",
            "date_published": "2021-12-09T01:54:40.000Z",
            "content_html": "<h1 id=\"最长公共子序列\"><a class=\"anchor\" href=\"#最长公共子序列\">#</a> 最长公共子序列</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\"> 最长公共子序列</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\" alt=\"\" /></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\" alt=\"\" /></p>\n<h2 id=\"动态规划\"><a class=\"anchor\" href=\"#动态规划\">#</a> 动态规划</h2>\n<p>我们可以用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp [i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 表示字符串 1<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mtext> </mtext><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0~i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mspace nobreak\"> </span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 范围内和字符串 2$ [0~i]$ 范围内的最长公共序列</p>\n<p>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mn>1</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mn>2</mn><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">text1[i]=text2[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mord\">1</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mord\">2</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 时，很明显 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">dp [i][j]=dp [i-1][j-1]+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span></p>\n<p>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mn>1</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">!</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mn>2</mn><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">text1[i]!=text2[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mord\">1</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">!</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">x</span><span class=\"mord mathnormal\">t</span><span class=\"mord\">2</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dp[i][j]=max(dp[i][j-1],dp[i-1][j])</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></p>\n<p>因为此时需要找个最长的子序列为然后连接上后面未知的字符，这样遍历到最后就能得到最大</p>\n<p>以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestCommonSubsequence(string text1, string text2) &#123;\n        int m=text1.length(),n=text2.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1));\n        int ans=0;\n        for(int i=1;i&lt;=m;i++)\n        &#123;\n            for(int j=1;j&lt;=n;j++)\n            &#123;\n                if(text1[i-1]==text2[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"最长回文子序列\"><a class=\"anchor\" href=\"#最长回文子序列\">#</a> 最长回文子序列</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnNlcXVlbmNlL3N1Ym1pc3Npb25zLw==\"> 最长回文子序列</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.jpg\" alt=\"\" /></p>\n<h2 id=\"解法一\"><a class=\"anchor\" href=\"#解法一\">#</a> 解法一</h2>\n<p>沿用求最长公共子序列的方法，我们可以先将字符串反转，得到一个新的字符串，再求这两个字符串的最长公共子序列的值，即为最长回文子序列</p>\n<p><strong>证明：</strong> 回文串的表现为成对称分布，从前往后遍历和从后往前遍历的结果是一样的，所以说如果求其与其本身的反转字符串的最长公共子序列，因为一个是正向，一个是反向，当求的该共同字符串时，那就说明该字符子序列在原字符串中为回文子序列，又由于在求解过程中记录的为最长，那么结果就能得到最长回文子序列</p>\n<p>下面为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestPalindromeSubseq(string s) &#123;\n        string re=s;\n        int ans=0;\n        reverse(re.begin(),re.end());\n        vector&lt;vector&lt;int&gt;&gt;dp(s.length()+1,vector&lt;int&gt;(s.length()+1));\n        for(int i=1;i&lt;=s.length();i++)\n        &#123;\n            for(int j=1;j&lt;=re.length();j++)\n            &#123;\n                if(s[i-1]==re[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            &#125;\n        &#125;\n        return ans;\n\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"解法二\"><a class=\"anchor\" href=\"#解法二\">#</a> 解法二</h2>\n<p>根据回文串的特征，如果一段字符串是回文串，那么将其两边各删去一个字符后依然为回文串，所以我们可以用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 来表示<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 最长回文子序列的长度，当遍历时，如果<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>s</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">s[i]=s[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>，那么<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">dp[i]=dp[i+1][j-1]+2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>，如果不相等，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i][j]=max(dp[i+1][j],dp[i][j-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></p>\n<p>需要注意的是，回文串最短为其本身，所以在开始真正寻找前，可以先将<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">dp [i][i]=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<p>在这里，我们选择由后至前推导，根据上方思想，那么最后的值应为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp [0][n-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>(<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 为字符串长度)</p>\n<p>下面为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int longestPalindromeSubseq(string s) &#123;\n        int n=s.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(n));\n        for(int i=n-1;i&gt;=0;i--)\n        &#123;\n            dp[i][i]=1;\n            for(int j=i+1;j&lt;n;j++)\n            &#123;\n                if(s[j]==s[i])\n                    dp[i][j]=dp[i+1][j-1]+2;\n                else\n                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);\n            &#125;\n        &#125;\n        return dp[0][n-1];\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "动态规划",
                "子序列",
                "最长公共子序列",
                "最长回文子序列"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/ca7417e/",
            "url": "http://dpm12345.github.io/posts/ca7417e/",
            "title": "三个无重叠子数组的最大和",
            "date_published": "2021-12-09T01:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWZ1bmN0aW9uLw==\">旋转函数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0.jpg\" alt=\"\" /></p>\n<p>解题思路:</p>\n<p>由题目中的旋转函数形式</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn><mo>∗</mo><msub><mi>B</mi><mi>k</mi></msub><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo>∗</mo><msub><mi>B</mi><mi>k</mi></msub><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>+</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>∗</mo><msub><mi>B</mi><mi>k</mi></msub><mo stretchy=\"false\">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">F(k) = 0 * B_k[0] + 1 * B_k[1] + ... + (n-1) * B_k[n-1]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p>以题目示例为例</p>\n<blockquote>\n<p>A = [4, 3, 2, 6]</p>\n</blockquote>\n<blockquote>\n<p>F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25</p>\n<p>F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</p>\n</blockquote>\n<p>即</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>3</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(0) = (0 * A [0]) + (1 * A [1]) + (2 * A [2]) + (3 * A [3])\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>3</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(1) = (0 * A[3]) + (1 * A[0]) + (2 * A[1]) + (3 * A[2])\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>3</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(2) = (0 * A[2]) + (1 * A[3]) + (2 * A[0]) + (3 * A[1])\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mn>3</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(3) = (0 * A[1]) + (1 * A[2]) + (2 * A[3]) + (3 * A[0])\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>将相邻两个函数相减，可以发现</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mn>4</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">F(1)-F(0)=A[0]+A[1]+A[2]+A[3]-4*A[3]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mn>4</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">F(2)-F(1)=A[0]+A[1]+A[2]+A[3]-4*A[2]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>3</mn><mo stretchy=\"false\">)</mo><mo>−</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mn>4</mn><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">F(3)-F(2)=A[0]+A[1]+A[2]+A[3]-4*A[1]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">3</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p>那么可以发现一般规律</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>F</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mo separator=\"true\">⋅</mo><mo separator=\"true\">⋅</mo><mo separator=\"true\">⋅</mo><mo>+</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mi>n</mi><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">F(k)-F(k-1)=A[0]+A[1]+A[2]+A[3]+···+A[n-1]-n*A[n-k];\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mord\">+</span><span class=\"mpunct\">⋅</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">⋅</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">⋅</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">+</span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n<p>形式为数组 A 元素之和减去<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">n*A[n-k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span></p>\n<p>由此我们可以维护一个<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">dp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span></span></span></span> 数组，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 表示<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mi>k</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">F(k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">)</span></span></span></span>; 一个<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span></span></span></span> 表示<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span></span></span></span> 的元素之和。</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>n</mi><mo>∗</mo><mi>A</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]=dp[i-1]+sum-n*A[n-i];\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n<p>特别的，当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">i=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">dp[i]=sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span></span></span></span>。</p>\n<p>最后输出<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 的最大值</p>\n<p>因此，代码如下</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxRotateFunction(vector&lt;int&gt;&amp; nums) &#123;\n        int n=nums.size();\n        int sum=0;\n        vector&lt;int&gt;dp(n);\n        for(int i=0;i&lt;n;i++)\n        &#123;\n            sum+=nums[i];\n            dp[0]+=i*nums[i];\n        &#125;\n        for(int i=1;i&lt;n;i++)\n        &#123;\n            dp[i]=dp[i-1]+sum-n*nums[n-i];\n        &#125;\n        return *max_element(dp.begin(),dp.end());\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/ca7417e/",
            "url": "http://dpm12345.github.io/posts/ca7417e/",
            "title": "三个无重叠子数组的最大和",
            "date_published": "2021-12-08T01:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdW0tb2YtMy1ub24tb3ZlcmxhcHBpbmctc3ViYXJyYXlzLw==\"> 三个无重叠子数组的最大和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.jpg\" alt=\"\" /></p>\n<p>该题为 2021-12-8 的每日一题，可解决该问题的方法涉及到前缀和，动态规划，滑动窗口知识</p>\n<p>思路：题目要求求出某一数组三个长度为 k 的无重叠数组，使它们的元素之和为最大。</p>\n<p>看到这个个数为 k，很容易想到滑动窗口这一算法，只是在这里，需要同时存在三个滑动窗口，</p>\n<p>同样的，在这题，也可以用动态规划进行解决</p>\n<p>下面是我自己在解题时的过程</p>\n<h1 id=\"动态规划劣质版\"><a class=\"anchor\" href=\"#动态规划劣质版\">#</a> 动态规划（劣质版）</h1>\n<p>刚拿到题目时，我能想到，该题可以使用动态规划解决，但并无方向该从哪个地方下手将什么作为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 所表达的意义，</p>\n<p>思考了大约 20 分钟后，我还是无从下手，于是打开了题解，第一眼看到的是” 单个子数组的最大和 “，顿时恍然大悟，我可以将不同个数的子数组作为一个<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">dp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span></span></span></span>，在计算个数加一时，便可以利用前面的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding=\"application/x-tex\">dp</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span></span></span></span>，得到最优解。仔细思考，该方案的时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>在以下的代码中，我是如此考虑的：</p>\n<p>先用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">sum[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 计算前缀和，为后续计算提供便利再分别使用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">dp1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">1</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">dp2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">2</span></span></span></span>，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">dp3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">3</span></span></span></span> 记录不同个数的子数组元素的最大值，其转移方程分别为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mn>1</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">{</mo><mi>d</mi><mi>p</mi><mn>1</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">dp1[i]=max\\{dp1[i-1],sum[i+1]-sum[i-k+1]\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">1</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">1</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mn>2</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">{</mo><mi>d</mi><mi>p</mi><mn>2</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mn>1</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">dp2[i]=max\\{dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">2</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">2</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">1</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mn>3</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">{</mo><mi>d</mi><mi>p</mi><mn>3</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mn>2</mn><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">dp3[i]=max\\{dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">3</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">3</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mord\">2</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span></span></p>\n<p>但这样并不能记录下标输出答案，所以这里我采用了，三个 flag 数组，用于记录下标，具体见代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n=nums.size();\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n        vector&lt;int&gt;flag1(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag3(n);\n        vector&lt;int&gt;sum(n+1,0);\n        vector&lt;int&gt;ans;\n        for(int i=0;i&lt;n;i++)\n        &#123;\n            sum[i+1]+=nums[i]+sum[i];           \n        &#125;\n        for(int i=k-1;i&lt;n;i++)\n        &#123;\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            &#123;\n                flag1[i]=flag1[i-1];\n            &#125;\n            else\n            &#123;\n                flag1[i]=i-k+1;\n            &#125;\n        &#125;\n        for(int i=2*k-1;i&lt;n;i++)\n        &#123;\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            &#123;\n                flag2[i]=flag2[i-1];\n            &#125;\n            else\n            &#123;\n                flag2[i]=&#123;flag1[i-k],i-k+1&#125;;\n            &#125;\n        &#125;\n        for(int i=3*k-1;i&lt;n;i++)\n        &#123;\n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            &#123;\n                flag3[i]=flag3[i-1];\n            &#125;\n            else\n            &#123;\n                flag3[i]=&#123;flag2[i-k].second,i-k+1&#125;;\n            &#125;\n        &#125;\n        return &#123;flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second&#125;;\n    &#125;\n&#125;;\n</code></pre>\n<p>xxxxxxxxxx class Solution {public:    int maxResult(vector&lt;int&gt;&amp; nums, int k) {        int n = nums.size();        vector&lt;int&gt; dp(n);        dp[0] = nums[0];        priority_queue&lt;pair&lt;int, int&gt;&gt; q;        q.emplace(nums[0], 0);        for (int i = 1; i &lt; n; <ins>i) {            while (i - q.top().second &gt; k) {                q.pop();            }            dp[i] = q.top().first + nums[i];            q.emplace(dp[i], i);        }        return dp[n - 1];    }};c</ins> 优先级队列 2</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF.png\" alt=\"\" /></p>\n<p>观察报错信息，可知，在我的代码中，并未考虑 <code>k==1</code>  的情况，因为代码中我是通过 <code>for(int i=k-1;i&lt;n;i++)</code>  实现循环的，k-1 就会为 0，至于后面 i-1 造成错误</p>\n<p>改进代码:</p>\n<pre><code class=\"language-c++\">if(k==1)                      // 考虑 k==1 的情况\n    &#123;\n        vector&lt;int&gt;ans(3);\n        for(int i=0;i&lt;3;i++)\n        &#123;\n            ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n        &#125;\n        sort(ans.begin(),ans.end());\n        return ans;\n    &#125;\n</code></pre>\n<p>再次提交，发现答案出错，如下:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0.png\" alt=\"\" /></p>\n<p>在这并不能看出什么，为此，我进行了多组数据的尝试，发现第一个大部分都不符合答案，但后两个一直都是正确的，说明 <code>flag1</code>  求解过程无误，而是输出出错</p>\n<p>对此，进行代码分析，最后输出时，我写的是</p>\n<p><code>return &#123;flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second&#125;;</code></p>\n<p><code>[flag2[flag3[n-1].first].first</code> ，因为我在 <code>flag3.first</code>  存入的是 <code>flag2</code>  的索引的第二个元素，以此来得到 <code>flag1</code>  明显是不可行的，因为对应 <code>flag1</code>  的下标与 <code>flag2</code>  的第二个元素并无关系， <code>flag1[i-k]</code>  可能是前一个继承来的，与 <code>flag2</code>  的第二个元素无关，也有可能与其有关，总之该方法不一定正确</p>\n<p>那么我做以下修改</p>\n<ol>\n<li>重新定义 <code>flag3</code>  数组类型，为 <code>&lt;pair&lt;pair&lt;int,int&gt;，int&gt;&gt;</code></li>\n<li>存入 <code>flag3</code>  时存入 <code>&#123;flag2 [i-k],i-k+1&#125;</code></li>\n<li>读取第一个使用 <code>flag3[n-1].first.first</code> ，第二个使用 <code>flag3[n-1].first.second</code></li>\n</ol>\n<p>以下为修改后的代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n=nums.size();\n        if(k==1)                      // 考虑 k==1 的情况\n        &#123;\n            vector&lt;int&gt;ans(3);\n            for(int i=0;i&lt;3;i++)\n            &#123;\n                ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n            &#125;\n            sort(ans.begin(),ans.end());\n            return ans;\n        &#125;\n\t\t//dp [i] 表示 0 到该位置所能得到的 x 个无重叠数组和的最大值\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n\t\t\n\t\t//flag1 记录某一位置 1 个最大无重叠数组的下标       \n        vector&lt;int&gt;flag1(n);\n\t\t\n\t\t//flag2 记录某一位置 2 个最大无重叠数组的下标    \n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n\t\t\n\t\t//flag3 记录某一位置 3 个最大无重叠数组的下标                  \n        vector&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt;flag3(n);              \n        \n\t\t//sum [i] 表示前 i 个数之和\n\t\tvector&lt;int&gt;sum(n+1,0); \n\t\t\n        for(int i=0;i&lt;n;i++)                       // 计算前缀和\n        &#123;\n            sum[i+1]+=nums[i]+sum[i];           \n        &#125;\n\t\t\n\t\t// 计算从 k-1 开始 1 个无重叠子数组最大的值，用 flag1 记录下标值\n        for(int i=k-1;i&lt;n;i++)                      \n        &#123;\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            &#123;\n                flag1[i]=flag1[i-1];\n            &#125;\n            else\n            &#123;\n                flag1[i]=i-k+1;\n            &#125;\n        &#125;\n\t\t\n\t\t// 计算从 2*k-1 开始 2 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=2*k-1;i&lt;n;i++)                   \n        &#123;\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            &#123;\n                flag2[i]=flag2[i-1];\n            &#125;\n            else\n            &#123;\n                flag2[i]=&#123;flag1[i-k],i-k+1&#125;;\n            &#125;\n        &#125;\n\t\t\n\t\t// 计算从 3*k-1 位置开始 3 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=3*k-1;i&lt;n;i++)                        \n        &#123; \n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            &#123;\n                flag3[i]=flag3[i-1];\n            &#125;\n            else\n            &#123;\n                flag3[i]=&#123;flag2[i-k],i-k+1&#125;;\n            &#125;\n        &#125;\n\t\t\n\t\t// 根据 flag3 找寻下标\n        return &#123;flag3[n-1].first.first,flag3[n-1].first.second,flag3[n-1].second&#125;;   \n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"滑动窗口\"><a class=\"anchor\" href=\"#滑动窗口\">#</a> 滑动窗口</h1>\n<p>维护 <code>sum1</code> ， <code>sum2</code> ， <code>sum3</code> ，分别表示 <code>n</code>  个子数组的最大值，若大于原来的更新下标 (代码中为 <code>sum1maxid,sum2maxid1,sum2maxid2</code> ) 当数组个数大于等于 k 时，那么需删去首个元素，更新窗口</p>\n<p>以下为代码实现</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n=nums.size();\n        int sum1=0,sum2=0,sum3=0;\n        int sum1max=0,sum2max=0,sum3max=0;\n        int sum1maxid,sum2maxid1,sum2maxid2;\n        vector&lt;int&gt;ans;\n        for(int i=2*k;i&lt;n;i++)\n        &#123;\n            sum1+=nums[i-2*k];\n            sum2+=nums[i-k];\n            sum3+=nums[i];\n            if(i&gt;=3*k-1)\n            &#123;\n                if(sum1&gt;sum1max)\n                &#123;\n                    sum1max=sum1;\n                    sum1maxid=i-3*k+1;          // 更新 1 个子数组最大值下标\n                &#125;\n                if(sum1max+sum2&gt;sum2max)\n                &#123;\n                    sum2max=sum1max+sum2;\n                    sum2maxid1=sum1maxid;       // 更新两个子数组中 1 个子数组最大值下标\n                    sum2maxid2=i-2*k+1;         // 更新 1 个子数组最大值下标\n                &#125;\n                if(sum2max+sum3&gt;sum3max)\n                &#123;\n                    sum3max=sum2max+sum3;\n                    ans=&#123;sum2maxid1,sum2maxid2,i-k+1&#125;;  // 更新答案\n                &#125;\n                sum1-=nums[i-3*k+1];             // 删去首个\n                sum2-=nums[i-2*k+1];             // 删去首个\n                sum3-=nums[i-k+1];               // 删去首个\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "动态规划",
                "前缀和",
                "滑动窗口"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/65c00a51/",
            "url": "http://dpm12345.github.io/posts/65c00a51/",
            "title": "边界着色 岛屿数量",
            "date_published": "2021-12-07T07:54:40.000Z",
            "content_html": "<h1 id=\"边界着色\"><a class=\"anchor\" href=\"#边界着色\">#</a> 边界着色</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29sb3JpbmctYS1ib3JkZXIv\">边界着色</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2.jpg\" alt=\"\" /></p>\n<p>思路：与 200. 岛屿数量题相类似，可以使用深度优先搜索或广度优先搜索进行解题。先找出满足连通分量的位置，再判断是否为边界</p>\n<h2 id=\"深度优先搜索\"><a class=\"anchor\" href=\"#深度优先搜索\">#</a> 深度优先搜索</h2>\n<p><strong>以下为代码</strong></p>\n<pre><code class=\"language-c++\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n        vector&lt;pair&lt;int, int&gt;&gt; borders;\n        int originalColor = grid[row][col];\n        visited[row][col] = true;\n        dfs(grid, row, col, visited, borders, originalColor);\n        for (auto &amp; [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, vector&lt;vector&lt;bool&gt;&gt; &amp; visited, vector&lt;pii&gt; &amp; borders, int originalColor) {\n        int m = grid.size(), n = grid[0].size();\n        bool isBorder = false;\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int i = 0; i &lt; 4; i++) {\n            int nx = direc[i][0] + x, ny = direc[i][1] + y;\n            if (!(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == originalColor)) {\n                isBorder = true;\n            } else if (!visited[nx][ny]) {\n                visited[nx][ny] = true;\n                dfs(grid, nx, ny, visited, borders, originalColor);\n            }                \n        }\n        if (isBorder) {\n            borders.emplace_back(x, y);\n        }\n    }\n};\n</code></pre>\n<h2 id=\"广度优先搜索\"><a class=\"anchor\" href=\"#广度优先搜索\">#</a> 广度优先搜索</h2>\n<pre><code class=\"language-c++\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n        vector&lt;pair&lt;int, int&gt;&gt; borders;\n        int originalColor = grid[row][col];\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.emplace(row, col);\n        visited[row][col] = true;\n        while (!q.empty()) {\n            pair&lt;int, int&gt; &amp; node = q.front();\n            q.pop();\n            int x = node.first, y = node.second;\n\n            bool isBorder = false;\n            for (int i = 0; i &lt; 4; i++) {\n                int nx = direc[i][0] + x, ny = direc[i][1] + y;\n                if (!(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == originalColor)) {\n                    isBorder = true;\n                } else if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.emplace(nx, ny);\n                }         \n            }\n            if (isBorder) {\n                borders.emplace_back(x, y);\n            }\n        }\n        for (auto &amp; [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n};\n</code></pre>\n<h1 id=\"岛屿数量\"><a class=\"anchor\" href=\"#岛屿数量\">#</a> 岛屿数量</h1>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLWlzbGFuZHMv\">岛屿数量</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.png\" alt=\"\" /></p>\n<h2 id=\"深度优先搜索-2\"><a class=\"anchor\" href=\"#深度优先搜索-2\">#</a> 深度优先搜索</h2>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int r,int c)\n        &#123;\n            int m=grid.size(),n=grid[0].size();\n            grid[r][c]='0';\n            if(r-1&gt;=0&amp;&amp;grid[r-1][c]=='1')  dfs(grid,r-1,c);\n            if(r+1&lt;m&amp;&amp;grid[r+1][c]=='1')  dfs(grid,r+1,c);\n            if(c-1&gt;=0&amp;&amp;grid[r][c-1]=='1')  dfs(grid,r,c-1);\n            if(c+1&lt;n&amp;&amp;grid[r][c+1]=='1')  dfs(grid,r,c+1);\n        &#125;\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        int m=grid.size(),n=grid[0].size();\n        if(m==0)return 0;\n        int ans=0;\n        for(int i=0;i&lt;m;i++)\n        &#123;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                if(grid[i][j]=='1')\n                &#123;\n                    ans++;\n                    dfs(grid,i,j);\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h2 id=\"广度优先搜索-2\"><a class=\"anchor\" href=\"#广度优先搜索-2\">#</a> 广度优先搜索</h2>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;\n        int m=grid.size(),n=grid[0].size();\n        if(m==0)  \n            return 0;\n        int ans=0;\n        for(int i=0;i&lt;m;i++)\n        &#123;\n            for(int j=0;j&lt;n;j++)\n            &#123;\n                if(grid[i][j]=='1')\n                &#123;\n                    ans++;\n                    grid[i][j]='0';\n                    queue&lt;pair&lt;int,int&gt;&gt;s;\n                    s.push(&#123;i,j&#125;);\n                    while(!s.empty())\n                    &#123;\n                        auto [r,c]=s.front();\n                        s.pop();\n                        if(r-1&gt;=0&amp;&amp;grid[r-1][c]=='1')\n                        &#123;\n                            grid[r-1][c]='0';\n                            s.push(&#123;r-1,c&#125;);\n                        &#125;\n                        if(r+1&lt;m&amp;&amp;grid[r+1][c]=='1')\n                        &#123;\n                            grid[r+1][c]='0';\n                            s.push(&#123;r+1,c&#125;);\n                        &#125;\n                        if(c-1&gt;=0&amp;&amp;grid[r][c-1]=='1')\n                        &#123;    \n                            grid[r][c-1]='0';\n                            s.push(&#123;r,c-1&#125;);\n                        &#125;\n                        if(c+1&lt;n&amp;&amp;grid[r][c+1]=='1')\n                        &#123;\n                            grid[r][c+1]='0';\n                            s.push(&#123;r,c+1&#125;);\n                        &#125;\n\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "深度优先搜索",
                "广度优先搜索"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/5beb97b2/",
            "url": "http://dpm12345.github.io/posts/5beb97b2/",
            "title": "无重叠区间",
            "date_published": "2021-12-06T11:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy8=\">无重叠区间</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.png\" alt=\"\" /></p>\n<p>思路：在这道题中，我们可以把题目要求所解问题换一种说法，找删去最少区间使剩下成为无重叠区间，即包含区间最多数。</p>\n<p>我们注意到，当其为无重叠区间时，前一个区间的末端必然小于等于后一个区间首端，那么我们便可以将这一组的无重叠区间的端点看作为一组不严格单调递增的序列。这样便与求 &quot;最长上升序列&quot; 的序列的问题相同了。</p>\n<h1 id=\"动态规划\"><a class=\"anchor\" href=\"#动态规划\">#</a> 动态规划</h1>\n<p>我们维护一个数组<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 以该位置为末尾区间的，所能得到的数量最多的无重叠区间的值。那么很容易得到，先分别枚举末尾区间位置，再从 0 开始遍历，寻找最长，转移方程即为： <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]=max(dp[j]+1,dp[i])</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mclose\">)</span></span></span></span>（当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>&lt;</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">intervals[j][1]&lt;intervals[i][0]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mclose\">]</span></span></span></span> 时)</p>\n<p>以下为代码:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        sort(intervals.begin(),intervals.end());\n        int n=intervals.size();\n        vector&lt;int&gt;dp(n,1);\n        for(int i=0;i&lt;intervals.size();i++)\n        &#123;\n            for(int j=0;j&lt;i;j++)\n            &#123;\n                if(intervals[j][1]&lt;=intervals[i][0])\n                &#123;\n                    dp[i]=max(dp[j]+1,dp[i]);\n                &#125;\n            &#125;\n        &#125;\n        return n-*max_element(dp.begin(),dp.end());\n\n    &#125;\n&#125;;\n</code></pre>\n<p>提交后很不幸，超时了，时间复杂度为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>, 为此我们需要将时间优化。</p>\n<h1 id=\"贪心方案\"><a class=\"anchor\" href=\"#贪心方案\">#</a> 贪心方案</h1>\n<p>上面的动态规划方案中，枚举末尾，再从 0 开始遍历，寻找最长，这是无法避免的，为此难以优化，这样，我们可以使用贪心方案，将时间复杂度降低</p>\n<p>实现思想：我们要想得到最多数量的无重叠区间，那么我们需要尽可能地将区间长度较小地放入这一无重叠区间内，因此我们可以设想，如果我们将各个区间地右端点按升序排序，设一个变量 <code>right</code>  为目前无重叠区间的右端点，如果下一个区间的左端大于 <code>right</code> ，区间加一， <code>right</code>  更新，这样以此类推， 最终可以得到答案</p>\n<p>证明：由于我们是将右端点降序排序，那么当两段区间相同时，实际上无论选择哪段结果都是一样的，因为不管该区间的左端点为多少，后面的区间只要左区间不大于 <code>right</code> ，那么该区间必会被删。而当之后区间的左端点大于 <code>right</code>  时，那么此时所选取的区间的右端点必然是满足条件的最小值，也因此能够得到最多数量的无重叠区间</p>\n<p>以下为实现代码:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;\n        if (intervals.empty()) &#123;\n            return 0;\n        &#125;\n        \n        sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) &#123;\n            return u[1] &lt; v[1];\n        &#125;);\n\n        int n = intervals.size();\n        int right = intervals[0][1];\n        int ans = 1;\n        for (int i = 1; i &lt; n; ++i) &#123;\n            if (intervals[i][0] &gt;= right) &#123;\n                ++ans;\n                right = intervals[i][1];\n            &#125;\n        &#125;\n        return n - ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/6f1a75f/",
            "url": "http://dpm12345.github.io/posts/6f1a75f/",
            "title": "跳跃游戏 VI",
            "date_published": "2021-12-05T06:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLXZpLw==\">跳跃游戏 VI</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/1696%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI.jpg\" alt=\"\" /></p>\n<h1 id=\"初期想法\"><a class=\"anchor\" href=\"#初期想法\">#</a> 初期想法</h1>\n<p>看到题目，很容易想到使用动态规划算法，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 表示跳到位置<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 能取到的最大的值，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">]</mo><mo>…</mo><mo>…</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]=min{dp[i-1],dp[i-2]……,dp[i-k]}+nums[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord\"><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"minner\">…</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>, 那么很容易写出代码 如图</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI_%E5%88%9D%E5%A7%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png\" alt=\"\" /></p>\n<p>但是已提交便发现，超时了，也就是说纯纯动态规划不能完成题目要求。</p>\n<h1 id=\"反思\"><a class=\"anchor\" href=\"#反思\">#</a> 反思</h1>\n<p>思考初期想法的代码，哪里造成了代码超时呢？</p>\n<p>不难发现，在确定<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 位置前的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[i-k,i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 范围内的最小值时，每一个都比较了一次，而当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 加一时，除去上次的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">i-k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span></span></span></span>，和新增的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，其他位置又比较了一次，如果最大值，即比较过后仍然比较，其原因是缺少记录最大值的渠道。那么是否可以在循环时加上一个变量 MAX 记录<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[i-k,i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 的最大值，当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 时，将 MAX 与<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 比较呢？</p>\n<p>其结果是只能解决一部分，因为假设<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>M</mi><mi>A</mi><mi>X</mi><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">MAX=dp[i-k]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.07847em;\">X</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span>，当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 时，MAX 的值明显不在之后的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[i-k,i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 范围之内了，因此要将原来范围内的次大值与<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 比较，这样我们又多了个任务，求次大值，所以单纯增加一个变量并不能解决问题。</p>\n<p>下面为解决方案：</p>\n<h1 id=\"优化单调队列\"><a class=\"anchor\" href=\"#优化单调队列\">#</a> 优化（单调队列）</h1>\n<p>经过上面的分析，我们需要存储<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[i-k,i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 内的最大值，同时要在最大值被删去时能快速得到之后的最大值那么，队列无非是我们的选择</p>\n<p>方法：为方便，我们将元素下标存入队列中队列内的元素按降序排序，即队首为最大元素的下标，队列第二个元素即为次大值循环时，首先先确保队首元素满足在下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>k</mi><mo separator=\"true\">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[i-k,i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 范围内，如不满足则删除队首，然后再进行<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 的计算<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>q</mi><mi mathvariant=\"normal\">.</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]=dp[q.front()]+nums[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord\">.</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>，最后向队列中存入元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>（若<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>&gt;</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>q</mi><mi mathvariant=\"normal\">.</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy=\"false\">(</mo><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]&gt;dp[q.back()]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span></span></span></span>, 便可将队尾元素删除，直到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>&lt;</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>q</mi><mi mathvariant=\"normal\">.</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]&lt;=dp[q.back]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord\">.</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mclose\">]</span></span></span></span> 或队列为空），这样便为后面取最大值做准备。</p>\n<p>因此，代码如下</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n=nums.size();\n        vector&lt;int&gt;dp(n);\n        dp[0]=nums[0];\n        deque&lt;int&gt;q;\n        q.push_back(0);\n        for(int i=1;i&lt;n;i++)\n        &#123;\n            while(q.size()&amp;&amp;i-q.front()&gt;k)\n            &#123;\n                q.pop_front();\n            &#125;\n            dp[i]=dp[q.front()]+nums[i];\n            while(q.size()&amp;&amp;dp[i]&gt;dp[q.back()])\n            &#123;\n                q.pop_back();\n            &#125;\n            q.push_back(i);\n        &#125;\n        return dp[n-1];\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"优化优先级队列\"><a class=\"anchor\" href=\"#优化优先级队列\">#</a> 优化（优先级队列）</h1>\n<p>与单调队列思想相同，只是优先级队列不用进行排序</p>\n<p>以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) &#123;\n        int n = nums.size();\n        vector&lt;int&gt; dp(n);\n        dp[0] = nums[0];\n        priority_queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.emplace(nums[0], 0);\n        for (int i = 1; i &lt; n; ++i) &#123;\n            while (i - q.top().second &gt; k) &#123;\n                q.pop();\n            &#125;\n            dp[i] = q.top().first + nums[i];\n            q.emplace(dp[i], i);\n        &#125;\n        return dp[n - 1];\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/20c47d09/",
            "url": "http://dpm12345.github.io/posts/20c47d09/",
            "title": "快速幂",
            "date_published": "2021-12-05T02:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcG93eC1uLw==\">快速幂</span></p>\n<p>题目详情：实现 Pow (x,n)</p>\n<h1 id=\"递归\"><a class=\"anchor\" href=\"#递归\">#</a> 递归</h1>\n<p>思路：要实现<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mi>o</mi><mi>w</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo separator=\"true\">,</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Pow(x,n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span>，显然不可能用 for 或 while 循环进行一个一个<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span> 相乘，这样时间相对较长，那么可以做以下简化，若要求<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span>，当 n 为奇数时，那么<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 就等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding=\"application/x-tex\">x^{\\frac{n}{2}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84708em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.84708em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6915428571428572em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span></span></span></span></span></span></span></span></span> 次方的的平方再乘一个<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">x</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">x</span></span></span></span>；当 n 为偶数时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mfrac><mi>n</mi><mn>2</mn></mfrac></msup></mrow><annotation encoding=\"application/x-tex\">x^{\\frac{n}{2}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.84708em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.84708em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6915428571428572em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span></span></span></span></span></span></span></span></span> 的平方，以此类推，递归方程就可写出以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    double quickMul(double x, long long N) &#123;\n        if (N == 0) &#123;\n            return 1.0;\n        &#125;\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    &#125;\n\n    double myPow(double x, int n) &#123;\n        long long N = n;\n        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    &#125;\n&#125;;\n</code></pre>\n<p>注意：代码中递归结束条件为 <code>N==0</code> ，而不是 <code>N==1</code> ；原因为考虑一开始 <code>N==0</code>  的情况</p>\n<h1 id=\"迭代优化\"><a class=\"anchor\" href=\"#迭代优化\">#</a> 迭代优化</h1>\n<p>在递归方法中，我们是通过倒序来进行判断什么时候乘 x，什么时候不乘 x 的，而要实现迭代优化，那么必然要正序遍历，所以现在的目的便是要找到怎样正序遍历的方法。</p>\n<p>我们再仔细想一下第一种确定乘 x 和不乘 x 的方法，是偶数不乘，是奇数则乘 x，倒序遍历，或许这样说还不够明白，那么换一种说法，偶数乘 x 的零次方 (和不乘结果相同), 而奇数乘 x 的 1 次方，倒序排列，换成这样的说法，我们很容易得到，这便是 n 的二进制形式，它的二进制的每一位表示着乘 x 的权，而每次计算时又会平方，那么也就是幂的二进制乘 2，若偶数末尾即零，奇数末尾即 1，如此继续下去，最后得到的值便为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">x^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 的值，因此这样便可得到迭代优化后的程序</p>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    double myPow(double x, int n) &#123;\n        double ans=1;\n        int flag=n;\n        double xc=x;         // 记录每一位如果为 1 应乘的 x 次方\n        while(n!=0)\n        &#123;\n            if(n%2)\n                ans*=xc;\n            xc=xc*xc;               // 每进一位则平方一次 xc\n            n/=2;\n        &#125;\n        return flag&gt;0?ans:1.0/ans;\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "递归"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/47ade4a0/",
            "url": "http://dpm12345.github.io/posts/47ade4a0/",
            "title": "爬楼梯与零钱兑换题目对比",
            "date_published": "2021-12-02T06:54:40.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==\">爬楼梯</span></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%88%AC%E6%A5%BC%E6%A2%AF.png\" alt=\"\" /></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2UtMi8=\">零钱兑换 II</span></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.png\" alt=\"\" /></p>\n<p>建立在做过题目的基础上，我们重新审视这几道题</p>\n<ol>\n<li>\n<p>对于爬楼梯，由于一次只能爬一阶或两阶，故<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]=dp[i-1]+dp[i-2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span><br />\n 对于零钱兑换 II，其限制因素为零钱的面额，故当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">i&gt;=coin[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]+=dp[i-coin[j]]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mord\">+</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mclose\">]</span></span></span></span></p>\n<p>而现在我们将爬楼梯的限制由由只有一阶或两阶，改为一个数组<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mo stretchy=\"false\">]</mo><mo>=</mo><mrow><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn></mrow></mrow><annotation encoding=\"application/x-tex\">step[]={1,2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span></span></span></span></span>；那么在做时，便要遍历一次<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">step [j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>, 当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">i&gt;=step[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]=dp[i]+dp[i-step[j]]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mclose\">]</span></span></span></span>, 而<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>t</mi><mi>e</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">step[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 便与前面的减去 1、2 相同。这样不难发现，如果将每次能跨越的楼梯阶数改为一个数组里的元素，那么爬楼梯与零钱兑换 II 的解题代码就十分相似了</p>\n</li>\n<li>\n<p>接下来进行更深一层的讨论</p>\n<p>在爬楼梯题目中，我们要计算的是到达顶端的总数，每次只能一阶或两阶，由此可知，其为 若干个 1 和 2 排列，其对顺序有要求，也就是说，最后得到是排列数的结果</p>\n<p>而在零钱兑换 II 题目中，因为只是记录兑换一个金额的总数，先取小面额还是先取大面额是没有区别的，那么也就是说，该题求的是组合数。</p>\n<p>那么，该用什么方法区别这两种呢？</p>\n<p>下面给出两段代码</p>\n</li>\n</ol>\n<pre><code class=\"language-c++\">//  amount 表示金额，n 表示硬币面额数，coin [i] 表示某个硬币\n\t\n\t// 第一段\n\tfor(int i=1;i&lt;=amount;i++)\n    &#123;\n\t   for(int j=0;j&lt;n;j++)\n\t\t  &#123;\n\t\t\t  if(i&gt;=coin[j])\n\t\t\t  &#123;\n\t\t\t\t  dp[i]+=dp[i-coin[j]];\n\t\t\t  &#125;\n\t\t  &#125;\n\t&#125;\n\t\n\t\n\t// 第二段\n\tfor(int i=0;i&lt;n;i++)\n    &#123;\n\t   for(int j=1;j&lt;=amount;j++)\n\t\t  &#123;\n\t\t\t  if(j&gt;=coin[i])\n\t\t\t  &#123;\n\t\t\t\t  dp[j]+=dp[j-coin[i]];\n\t\t\t  &#125;\n\t\t  &#125;\n\t&#125;\n</code></pre>\n<p>经过代码观察，不难看出，第一段代码先枚举金额，然后嵌套 <code>coin</code>  硬币的循环； 第二段代码先枚举 <code>coin</code>  硬币面额，然后再枚举金额</p>\n<ol>\n<li>\n<p>先看第一段代码：先枚举金额，再枚举硬币面额，也就是说每一个金额的 <code>dp</code>  计算都会涉及到每一种硬币，当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">i&gt;=coin[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span>, 意味着<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">i-coin[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 后可以添加一个硬币元素<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">coin[j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>, 所以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]=dp[i]+dp[i-coin[j]]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mclose\">]</span></span></span></span>, 那么不难得出比如计算金额<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span> 时，如果硬币面额存在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span></span></span></span>，那么<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 和<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span> 的值都会加到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[3]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span></span></span></span> 上，也，就是说首先<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[3]+=dp[2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mord\">+</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span>, 即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mtext>，</mtext><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2，1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\">1</span></span></span></span> 情况，然后<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>3</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[3]+=dp[1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">3</span><span class=\"mclose\">]</span><span class=\"mord\">+</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>, 即<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mtext>，</mtext><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">1，2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord\">2</span></span></span></span> 情况。很明显，&quot;1,2&quot;、&quot;2,1&quot; 都计算的为排列数。</p>\n</li>\n<li>\n<p>再看第二段代码：先枚举硬币面额，再枚举金额，也就是说每一个硬币面额都会在一种金额内计算一次，再根据循环的方式，从下标零开始遍历，知道结束，那么不难得出，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>o</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">coin[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 的值在<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 的每一种情况中，出现的顺序都是固定的，那么与上面分析相比，&quot;1,2&quot;、&quot;2,1&quot; 只会出现一种，所以第二段代码计算的结果为组合数</p>\n</li>\n</ol>\n<p>下面进行代码实现</p>\n<p>注：为确保爬楼梯代码无误，增加了数组 b 进行检验，若正确，则应先输出 34</p>\n<pre><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nclass Solution&#123;\npublic:\n\tint climb_stairs(int amount, vector&lt;int&gt;&amp;step)\n\t&#123;\n\t\tvector&lt;int&gt;dp(amount + 1);\n\t\tint n = step.size();\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i &lt;= amount; i++)\n\t\t&#123;\n\t\t\tfor (int j = 0; j &lt; n; j++)\n\t\t\t&#123;\n\t\t\t\tif (i&gt;=step[j])\n\t\t\t\t&#123;\n\t\t\t\t\tdp[i] += dp[i - step[j]];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn dp[amount];\n\t&#125;\n\tint change(int amount, vector&lt;int&gt;&amp;coin)\n\t&#123;\n\t\tvector&lt;int&gt;dp(amount + 1);\n\t\tint n = coin.size();\n\t\tdp[0] = 1;   // 表示金额为零的情况，\n\t\t             // 因为零钱面额也为零，故 dp [0]=1\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t&#123;\n\t\t\tfor (int j = 1; j &lt;=amount; j++)\n\t\t\t&#123;\n\t\t\t\tif (j&gt;=coin[i])\n\t\t\t\t&#123;\n\t\t\t\t\tdp[j] += dp[j - coin[i]];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn dp[amount];\n\t&#125;\n&#125;;\n\nint main()\n&#123;\n\tint amount = 8;\n\tvector&lt;int&gt;a(3);\n\ta[0] = 1; a[1] = 2; a[2] = 5;\n\tvector&lt;int&gt;b(2);\n\tb[0] = 1; b[1] = 2;\n\tSolution A;\n\tcout &lt;&lt; A.climb_stairs(amount, b) &lt;&lt; endl;      \n\tcout &lt;&lt;A.climb_stairs(amount,a)  &lt;&lt; endl;\n\tcout &lt;&lt; A.change(amount,a)&lt;&lt; endl;\n\treturn 0;\n&#125;\n</code></pre>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png\" alt=\"\" /></p>\n<p>将 8，数组 [1,2,5] 分别输入 leetcode 控制器内检验，发现无误</p>\n<p>【2021-12-3 更新】</p>\n<p>类似的题目还有</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLWl2Lw==\">组合总数</span></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0IV.png\" alt=\"\" /></p>\n<p>方法类似，但需要注意题目要求不能超过 32 位整数范围，需添加限制，如图</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%8C%BA%E5%88%AB.png\" alt=\"\" /></p>\n",
            "tags": [
                "排列组合"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/308e5841/",
            "url": "http://dpm12345.github.io/posts/308e5841/",
            "title": "有效的括号",
            "date_published": "2021-11-29T12:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LTJkLWltbXV0YWJsZS8=\">二维区域和检索 - 矩阵不可变</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/304%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98.jpg\" alt=\"\" /></p>\n<p>思路：该题考查了矩形的相关知识，同时涉及到前缀和。那么必须知道矩形的前缀和如何求。这里给出两种解法：</p>\n<ol>\n<li>\n<p>以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">sum [i][j+1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 表示<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi></mrow><annotation encoding=\"application/x-tex\">matrix</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">x</span></span></span></span> 第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 行从下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 到下标为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi></mrow><annotation encoding=\"application/x-tex\">j</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span></span></span></span> 元素的和，那么计算左上端点为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>1</mn><mo separator=\"true\">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[row1,col1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>, 右下端点为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>2</mn><mo separator=\"true\">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[row2,col2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span> 的矩形区域内元素总和，就可以将每一行每一行加起来代码形式为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">sum [i][col2+1]-sum [i][col1+1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></p>\n</li>\n<li>\n<p>以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">sum [i][j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 表示以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,0]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">]</span></span></span></span> 为左上端点，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[i,j]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span> 为右上端点的矩形区域内元素总和，那么计算左上端点为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>1</mn><mo separator=\"true\">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[row1,col1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>, 右下端点为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>2</mn><mo separator=\"true\">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>2</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[row2,col2]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span> 的矩形区域内元素总和时<br />\n可试着画图</p>\n</li>\n</ol>\n<p>&lt;img src=&quot;/ 素材 / 二维数组前缀和第二种解法.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;</p>\n<p>那么由此可以推得解法代码为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>2</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>2</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>2</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mn>2</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mn>1</mn><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">sum[row2][col2]-sum[row2][col1-1]-sum[row1-1][col2]+sum[row1-1][col-1]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">2</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p>但为了防止<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mn>1</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">col1-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi><mn>1</mn><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">row1-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 越界，在创建数组时可以顺便将其行列各增加一行，排除越界情况具体代码只需下标加一即可</p>\n<p>以下为代码</p>\n<h1 id=\"解法一\"><a class=\"anchor\" href=\"#解法一\">#</a> 解法一</h1>\n<pre><code class=\"language-c++\">class NumMatrix &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt;sum;\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int m=matrix.size();\n        if(m&gt;0)\n        &#123;\n            sum.resize(m,vector&lt;int&gt;(matrix[0].size()+1));\n            for(int i=0;i&lt;m;i++)\n            &#123;\n                for(int j=0;j&lt;matrix[0].size();j++)\n                &#123;\n                    sum[i][j+1]=sum[i][j]+matrix[i][j];\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    int sumRegion(int row1, int col1, int row2, int col2) &#123;\n        int ans=0;\n        for(int i=row1;i&lt;=row2;i++)\n        &#123;\n            ans+=sum[i][col2+1]-sum[i][col1];\n        &#125;\n        return ans;\n    &#125;\n&#125;;\n</code></pre>\n<h1 id=\"解法二\"><a class=\"anchor\" href=\"#解法二\">#</a> 解法二</h1>\n<pre><code class=\"language-c++\">class NumMatrix &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt;sum;\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n        int m=matrix.size();\n        if(m&gt;0)\n        &#123;\n            int n=matrix[0].size();\n            sum.resize(m+1,vector&lt;int&gt;(n+1));\n            for(int i=1;i&lt;m+1;i++)\n            &#123;\n                for(int j=1;j&lt;n+1;j++)\n                &#123;\n                    sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+matrix[i-1][j-1];\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    \n    int sumRegion(int row1, int col1, int row2, int col2) &#123;\n        return sum[row2+1][col2+1]-sum[row2+1][col1]-sum[row1][col2+1]+sum[row1][col1];\n\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "矩阵"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/308e5841/",
            "url": "http://dpm12345.github.io/posts/308e5841/",
            "title": "有效的括号",
            "date_published": "2021-11-28T13:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv\">有效的括号</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"\" /></p>\n<p>思路：因为相同括号只能连续出现，那么我们可以利用栈的特性，当找到一个左括号时，压入栈；当找到一个右括号时，判断栈顶是不是与其相配对的括号，若不是，则返回 <code>false</code> ，是则去除栈顶元素，到最后，因为有一直压入栈顶的情况，故不能直接 <code>return true</code> ，而是可以返回 <code>empty()</code></p>\n<p>代码如下</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    bool isValid(string s) &#123;\n        if(s.length()&lt;2)return false;\n        unordered_map&lt;char,char&gt;dict=&#123;\n            &#123;')', '('&#125;,\n            &#123;']', '['&#125;,\n            &#123;'&#125;', '&#123;'&#125;\n        &#125;;\n        stack&lt;char&gt;a;\n        for(int i=0;i&lt;s.size();i++)\n        &#123;\n            if(dict.count(s[i]))\n            &#123;\n                if(a.empty()||a.top()!=dict[s[i]])\n                return false;\n                a.pop();\n            &#125;\n            else \n                a.push(s[i]);\n        &#125;\n        return a.empty();\n    &#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "栈"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/b115b06a/",
            "url": "http://dpm12345.github.io/posts/b115b06a/",
            "title": "加油站",
            "date_published": "2021-11-27T06:20:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi8=\">加油站</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E5%8A%A0%E6%B2%B9%E7%AB%99_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"\" /></p>\n<p>算法思路：贪心算法</p>\n<h1 id=\"pos-数组记录每个位置的剩余油量\"><a class=\"anchor\" href=\"#pos-数组记录每个位置的剩余油量\">#</a> pos 数组记录每个位置的剩余油量</h1>\n<ol>\n<li>\n<p>使用另一个数组<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">pos</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span></span></span></span>，其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>g</mi><mi>a</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>−</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">pos[i]=gas[i]-cost[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>, 从下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 开始遍历，若<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">pos[i]&lt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, 则必不以此为起点；若 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">pos[i]&gt;=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, 则以其为起点，</p>\n<p>用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">res</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span></span></span></span> 存储当前剩余油量，之后以此为起点遍历之后位置<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>，若<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>r</mi><mi>e</mi><mi>s</mi><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">pos[n]+res&lt;0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, 此起点不满足题意，若 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">&gt;=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>, 则更新<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">res</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span></span></span></span>，并使</p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n=(n+1)%pos.size()</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，继续遍历若正常结束循环，则可以返回<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 的值</p>\n</li>\n</ol>\n<p>以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;\n        if(gas.size()==1)return (gas[0]&lt;cost[0])?-1:0;\n        vector&lt;int&gt;pos(gas.size());\n        for(int i=0;i&lt;pos.size();i++)\n        &#123;\n            pos[i]=gas[i]-cost[i];\n        &#125;\n        for(int i=0;i&lt;pos.size();i++)\n        &#123;\n            if(pos[i]&gt;0)\n            &#123;\n                int res=pos[i],n=(i+1)%pos.size();\n                while(n!=i)\n                &#123;\n                    if(pos[n]+res&lt;0)\n                    break;\n                    res+=pos[n];\n                    n=(n+1)%pos.size();\n                &#125;\n                if(n==i)return i;\n            &#125;\n            \n        &#125;\n        return -1;\n    &#125;\n&#125;;\n</code></pre>\n<ol start=\"2\">\n<li>\n<p>优化：由上代码，当不满足<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>r</mi><mi>e</mi><mi>s</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">pos[n]+res&gt;=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span> 时，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 即为以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 为起点不可能到达的位置，那么这两个位置之间的位置都不可能到达<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 因为以<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 为起点，当它到两者中间位置时，初始油量大于等于零，而从<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 位置到达不了，更别说两者其中位置了由此，可增加一个变量记录每次前进的长度<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">num</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span></span></span></span>，当以某一起点得不到答案时，使<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mi>i</mi><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i=i+num+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 更新<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>，提高效率</p>\n<p>代码如下</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;\n        int n=gas.size();\n        int i=0;\n        while(i&lt;n)\n        &#123;\n            int num=0,total_gas=0,total_cost=0;\n            while(num&lt;n)\n            &#123;\n                int j=(i+num)%n;\n                total_gas+=gas[j];\n                total_cost+=cost[j];\n                if(total_gas&lt;total_cost)\n                break;\n                num++;\n            &#125;\n            if(num==n)return i;\n            else\n            &#123;\n                i=i+num+1;\n            &#125;\n        &#125;\n        return -1;\n\n    &#125;\n&#125;;\n</code></pre>\n</li>\n</ol>\n",
            "tags": [
                "贪心"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/ccc6bc8a/",
            "url": "http://dpm12345.github.io/posts/ccc6bc8a/",
            "title": "下降路径最小和",
            "date_published": "2021-11-26T07:20:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1mYWxsaW5nLXBhdGgtc3VtLw==\">下降路径最小和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"\" /></p>\n<p>思路：由题意知，到达某一位置只能有在上一行中与它纵坐标相差 1 内 的位置到达，那么显然这题使用动态规划 其转移方程在一般情况下，为</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">dp[i][j] = \\{min(dp[i - 1][j], dp[i - 1][j - 1], dp[i - 1][j + 1]\\} + matrix[i][j];\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n<p>而当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">i=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span>，</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">dp[i][j] = matrix[i][j];\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">j=0</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">dp[i][j] = \\{min(dp[i - 1][j], dp[i - 1][j + 1]\\} + matrix[i][j];\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>j</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">j = n - 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo separator=\"true\">;</mo></mrow><annotation encoding=\"application/x-tex\">dp[i][j] = \\{min(dp[i - 1][j], dp[i - 1][j - 1]\\} + matrix[i][j];\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mpunct\">;</span></span></span></span></span></p>\n<h1 id=\"原始\"><a class=\"anchor\" href=\"#原始\">#</a> 原始</h1>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n\tint minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n\t\tint m = matrix.size(), n = matrix[0].size();\n\t\tvector&lt;vector&lt;int&gt;&gt;dp(m, vector&lt;int&gt;(n));\n\t\tfor (int i = 0; i&lt;m; i++)\n\t\t&#123;\n\t\t\tfor (int j = 0; j&lt;n; j++)\n\t\t\t&#123;\n\t\t\t\tif (i == 0)\n\t\t\t\t&#123;\n\t\t\t\t\tdp[i][j] = matrix[i][j];\n\t\t\t\t&#125;\n\t\t\t\telse if (j == 0)\n\t\t\t\t&#123;\n\t\t\t\t\tdp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];\n\t\t\t\t&#125;\n\t\t\t\telse if (j == n - 1)\n\t\t\t\t&#123;\n\t\t\t\t\tdp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j];\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\tdp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i - 1][j + 1])) + matrix[i][j];\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn *min_element(dp[m - 1].begin(), dp[m - 1].end());\n\n\t&#125;\n&#125;;\n</code></pre>\n<h1 id=\"空间优化\"><a class=\"anchor\" href=\"#空间优化\">#</a> 空间优化</h1>\n<p>使用一个一维数组</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n\tint minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;\n\t\tint m = matrix.size(), n = matrix[0].size();\n\t\tvector&lt;int&gt;dp(n + 2);              // 确保每个位置都是 min &#123;dp [i-1],dp [i],dp [i+1]&#125;;\n\t\tint last;                        //last 记录上一个变换的 dp [i];\n\t\tfor (int i = 0; i&lt;m; i++)\n\t\t&#123;\n\t\t\tdp[0] = dp[n + 1] = INT_MAX;\n\t\t\tlast = dp[0];\n\t\t\tfor (int j = 0; j&lt;n; j++)\n\t\t\t&#123;\n\t\t\t\tint temp = dp[j + 1];\n\t\t\t\tdp[j + 1] = min(last, min(dp[j + 1], dp[j + 2])) + matrix[i][j];             \n\t\t\t\t// 由于把原来数组增加了两个位置，\n\t\t\t    // 所以记录 dp 时只需更新下标 1~n+1 的 dp 值\n\t\t\t\tlast = temp;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn *min_element(dp.begin(), dp.end());\n\n\t&#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/723dcd0c/",
            "url": "http://dpm12345.github.io/posts/723dcd0c/",
            "title": "摆动序列",
            "date_published": "2021-11-26T02:20:40.000Z",
            "content_html": "<p><span class=\"orange\">题目链接:</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlLw==\"> 摆动序列</span></p>\n<p><span class=\"orange\">题目详情:</span></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"摆动序列_题目详情\" /></p>\n<h1 id=\"动态规划\"><a class=\"anchor\" href=\"#动态规划\">#</a> 动态规划</h1>\n<h2 id=\"原始\"><a class=\"anchor\" href=\"#原始\">#</a> 原始</h2>\n<p>思路：关键点在于，当增添一个数成为摆动序列中的一个元素时，那么这个数要么小于，要么大于其前面的一个数 其大于或小于取决于前面一个数与再前面一个数之间的大小关系 就此，可利用动态规划的思想，分别用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">up[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">down[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 记录前<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 个数的最长摆动序列。(其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">up[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 记录末尾为上升的，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">down[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 记录下降的)</p>\n<p>将题目解决方法转换为三方面：</p>\n<ol>\n<li>\n<p>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">nums[i]&lt;nums[i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 时，该元素不可添加到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">up[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 中，而对于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">down[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>，取<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">down[i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>(不加上该数),<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">up[i-1]+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> (加上该数) 中的最大值，即</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">{</mo><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">down[i] = max\\{up[i-1]+1, down[i-1]\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mclose\">}</span></span></span></span></span></p>\n</li>\n<li>\n<p>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">nums[i]&gt;nums[i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 时，该元素不可添加到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">down[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 中，而对于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">up[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>, 取<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">up[i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>(不加上该数),<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">down[i-1]+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> (加上该数) 中的最大值，即</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\"false\">{</mo><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo separator=\"true\">,</mo><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mo>+</mo><mn>1</mn><mo stretchy=\"false\">}</mo></mrow><annotation encoding=\"application/x-tex\">up[i] = max\\{up[i-1], down[i-1]+1\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">x</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span></span></p>\n</li>\n<li>\n<p>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">nums[i]=nums[i-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span> 时，都不能加上，故</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">up[i]=up[i-1]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>m</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dowm[i]=down[i-1]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">m</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span></span></p>\n</li>\n</ol>\n<p>以下为代码</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n\tint wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n\t\tint n = nums.size();\n\t\tif (n == 1) return n;\n\t\tvector&lt;int&gt;up(n), down(n);\n\t\tup[0] = down[0] = 1;\n\t\tfor (int i = 1; i&lt;n; i++)\n\t\t&#123;\n\t\t\tif (nums[i]&lt;nums[i - 1])\n\t\t\t&#123;\n\t\t\t\tup[i] = up[i - 1];\n\t\t\t\tdown[i] = max(down[i - 1], up[i - 1] + 1);\n\t\t\t&#125;\n\t\t\telse if (nums[i]&gt;nums[i - 1])\n\t\t\t&#123;\n\t\t\t\tup[i] = max(up[i - 1], down[i - 1] + 1);\n\t\t\t\tdown[i] = down[i - 1];\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tup[i] = up[i - 1];\n\t\t\t\tdown[i] = down[i - 1];\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn max(up[n - 1], down[n - 1]);\n\t&#125;\n&#125;;\n</code></pre>\n<h3 id=\"动态规划的空间优化\"><a class=\"anchor\" href=\"#动态规划的空间优化\">#</a> 动态规划的空间优化</h3>\n<p>由于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>u</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">up[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span>,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>o</mi><mi>w</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">down[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 只与下标为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">i-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span> 的值有关，那么可以用两个变量代替数组，最后取这两个变量的最大值</p>\n<p>优化代码如下:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n\tint wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n\t\tint n = nums.size();\n\t\tif (n == 1) return n;\n\t\tint up = 1, down = 1;\n\t\tfor (int i = 1; i&lt;n; i++)\n\t\t&#123;\n\t\t\tif (nums[i]&lt;nums[i - 1])\n\t\t\t&#123;\n\t\t\t\tdown = max(down, up + 1);\n\t\t\t&#125;\n\t\t\telse if (nums[i]&gt;nums[i - 1])\n\t\t\t&#123;\n\t\t\t\tup = max(up, down + 1);\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn max(up, down);\n\t&#125;\n&#125;;\n</code></pre>\n<h1 id=\"贪心算法\"><a class=\"anchor\" href=\"#贪心算法\">#</a> 贪心算法</h1>\n<p>代码如下:</p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n\tint wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123;\n\t\tint n = nums.size();\n\t\tif (n &lt; 2) &#123;\n\t\t\treturn n;\n\t\t&#125;\n\t\tint prevdiff = nums[1] - nums[0];\n\t\tint num = prevdiff != 0 ? 2 : 1;\n\t\tfor (int i = 2; i &lt; n; i++) &#123;\n\t\t\tint diff = nums[i] - nums[i - 1];\n\t\t\tif ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) &#123;\n\t\t\t\tnum++;\n\t\t\t\tprevdiff = diff;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn num;\n\t&#125;\n&#125;;\n</code></pre>\n<p>一开始本身的疑点：其代码行只要有 <code>(diff&gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)</code>  情况出现，则 <code>num++</code> ,<br />\n 不会导致因为所选数不是最佳方案而造成答案错误吗？<br />\n// 经过思考：正因为代码段</p>\n<pre><code class=\"language-c++\">int diff = nums[i] - nums[i - 1];\nif ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) &#123;\n    num++;\n    prevdiff = diff;\n&#125;\n</code></pre>\n<p>每次都会更新 diff 的值，也就是说每次都会更新 “峰” 或 “谷” 的值，从而使得为最佳方案</p>\n",
            "tags": [
                "动态规划",
                "贪心"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/80d626cb/",
            "url": "http://dpm12345.github.io/posts/80d626cb/",
            "title": "等差数列划分",
            "date_published": "2021-11-22T07:20:40.000Z",
            "content_html": "<p><span class=\"orange\">题目链接:</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMv\"> 等差数列划分</span></p>\n<p><span class=\"orange\">题目详情</span></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\" /></p>\n<p><span class=\"blue\">【思想】数学方法 </span></p>\n<p><span class=\"blue\">主要在于明白，数列从长度 3 开始，每增加一个元素，其个数从 2 开始加，一次加 2，3，4...</span></p>\n<p><span class=\"orange\">代码如下</span></p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n\tint numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123;\n\t\tif (nums.size()&lt;3)return 0;\n\t\tint count = 1, ans = 0;\n\t\tfor (int i = 1; i&lt;nums.size() - 1; i++)\n\t\t&#123;\n\t\t\tif (nums[i] * 2 == nums[i - 1] + nums[i + 1])\n\t\t\t\tans += count++;\n\t\t\telse count = 1;\n\t\t&#125;\n\t\treturn ans;\n\t&#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "等差数列"
            ]
        },
        {
            "id": "http://dpm12345.github.io/posts/6ba8ad80/",
            "url": "http://dpm12345.github.io/posts/6ba8ad80/",
            "title": "整数拆分",
            "date_published": "2021-11-21T07:54:40.000Z",
            "content_html": "<p><span class=\"orange\">题目链接:</span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay8=\"> 整数拆分</span></p>\n<p><span class=\"orange\">题目详情</span></p>\n<p><img data-src=\"/%E7%B4%A0%E6%9D%90/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"整数拆分_1\" /></p>\n<p><span class=\"blue\">数学方法可以证明乘积最大时，因子最终都可以分解为若干个 3 和若干个 2，且 3 的个数尽可能多</span></p>\n<pre><code class=\"language-c++\">class Solution &#123;\npublic:\n\tint integerBreak(int n) &#123;\n\t\tif (n == 2)return 1;\n\t\tif (n == 3)return 2;\n\t\tint num_3 = n / 3, num_2 = (n % 3) / 2;\n\t\tif (n % 3 == 1)\n\t\t&#123;\n\t\t\tnum_3--;\n\t\t\tnum_2 += 2;\n\t\t&#125;\n\t\treturn pow(3, num_3)*pow(2, num_2);\n\t&#125;\n&#125;;\n</code></pre>\n",
            "tags": [
                "滑动窗口",
                "哈希表",
                "字符串"
            ]
        }
    ]
}