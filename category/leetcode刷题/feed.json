{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"leetcode刷题\" category",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/1c771f88/",
            "url": "http://dpm12345.cn/posts/1c771f88/",
            "title": "最小覆盖子串",
            "date_published": "2023-04-15T02:20:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXdpbmRvdy1zdWJzdHJpbmcv\">最小覆盖子串</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<p>这道题是一道滑动窗口，根据题目意思，要保证查找到的子串既包含<code>t</code>中所有出现的字符，同时也要保证相对应得字符在子串中出现的次数大于等于在<code>t</code>中出现的次数</p>\n<p>这里可以使用两个哈希表分别记录两字符串中各字符出现的次数，tmap记录<code>t</code>的字符出现情况，smap维护的是当前窗口内的字符出现数的字典。当要添加的字符在smap中的值小于等于tmap，那么说明此次添加是有效的，那么将correct加一，而当相等出现冗余时，则要从前面对窗口进行缩小。(当出现与首字符相等的字符时，那么就实现了另一种情况的考虑，从而遍历所有可能的子串，然后通过比较各次的长度，最终得到最小子串)</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map&lt;char, int&gt; tmap, smap;\n        int left = 0, correct = 0;\n        string res = s+\"1\";//加上一个新的字符是为了防止s等于t的情况，利于下面最小值的比较\n        for (int i=0; i &lt; t.size(); i++) \n            tmap[t[i]]++;\n\n        for (int right = 0; right &lt; s.size(); ++right) {\n            // smap维护的是当前窗口内的字符出现数的字典\n            ++smap[s[right]];\n            // 当前right对应s的字符是在t中出现的，并且数量上还没有达到冗余，是一次有效添加\n            if (tmap[s[right]] &gt;= smap[s[right]])\n                ++correct;\n            // 字符串最短是空串 &amp;&amp; 如果left对应的字符是冗余，那么进行右移删除\n            while (left &lt; right &amp;&amp; smap[s[left]] &gt; tmap[s[left]])\n                --smap[s[left++]];\n            if (correct == t.size()){\n                // 窗口内已经满足t串的所有字符\n                if (right - left + 1 &lt; res.size())\n                    res = s.substr(left, right - left + 1);\n            }\n\n        }\n        return res==s+\"1\"?\"\":res;\n    }\n};\n</code></pre>\n",
            "tags": [
                "滑动窗口"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/b6465ced/",
            "url": "http://dpm12345.cn/posts/b6465ced/",
            "title": "两数相加",
            "date_published": "2022-03-18T15:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hZGQtdHdvLW51bWJlcnMv\">两数相加</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<h2 id=\"不带头节点\"><a href=\"#不带头节点\" class=\"headerlink\" title=\"不带头节点\"></a>不带头节点</h2><pre><code class=\"cpp\">/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* ans = nullptr;               // 开始节点\n        ListNode* tail = nullptr;              // 尾节点\n        int add = 0;                           // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        {\n            int m = l1? l1 -&gt;val : 0;\n            int n = l2? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;       // 个位数\n            add = (m + n + add)/10;            // 进位\n            if(!ans)                           \n            {                                  \n                ans = tail = new ListNode(num);\n            }\n            else\n            {\n                tail -&gt; next = new ListNode(num);\n                tail = tail -&gt; next;\n            }\n\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        }\n        if(add)                                // 如果还有进位，那么应该再创建一个节点\n            tail -&gt;next = new ListNode(add);\n        return ans;\n    }\n};\n</code></pre>\n<h2 id=\"带头结点-省去了无节点情况的考虑代码\"><a href=\"#带头结点-省去了无节点情况的考虑代码\" class=\"headerlink\" title=\"带头结点 (省去了无节点情况的考虑代码)\"></a>带头结点 (省去了无节点情况的考虑代码)</h2><pre><code class=\"cpp\">class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* ans = new ListNode(-1);       //ans-&gt;next 为答案\n        ListNode* cnode = ans;                  // 遍历节点指针\n        int add = 0;                            // 进位\n        while(l1!=nullptr||l2!=nullptr)\n        {\n            int m = l1 ? l1 -&gt;val : 0;\n            int n = l2 ? l2 -&gt;val : 0;\n            int num = (m + n + add) %10;        // 个位数\n            add = (m + n + add)/10;             // 进位\n            cnode -&gt; next = new ListNode(num);  // 链接\n            cnode = cnode -&gt; next;              // 转移\n            if(l1)\n                l1 = l1 -&gt; next;\n            if(l2)\n                l2 = l2 -&gt; next;\n        }\n        if(add)\n            cnode -&gt;next = new ListNode(add);\n        return ans-&gt;next;\n    }\n};\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/d98ef1d2/",
            "url": "http://dpm12345.cn/posts/d98ef1d2/",
            "title": "两数之和",
            "date_published": "2022-03-18T14:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtLw==\">两数之和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<pre><code class=\"c++\">class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int,int&gt;temp;\n        for(int i=0;i&lt;nums.size();i++)\n        {\n            int num = nums[i];\n            if(temp.find(target-num)!=temp.end())\n                return {temp[target-num],i};\n            else\n                temp.insert({num,i});\n        }\n        return {};\n    }\n};\n</code></pre>\n",
            "tags": [
                "数组",
                "哈希表"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/d10e2ef2/",
            "url": "http://dpm12345.cn/posts/d10e2ef2/",
            "title": "无重复字符的最长字串",
            "date_published": "2022-03-18T12:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzLw==\">无重复字符的最长字串</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size()==0)\n            return 0;\n        int ans = 1;\n        int left = 0;\n        unordered_set&lt;char&gt;temp;\n        for(int i=0;i&lt;s.size();i++)         // 遍历每个元素\n        {\n            while(temp.find(s[i])!=temp.end())          // 如果出现过了，由于求的是子串，故以此为开头的字符必不成立，故删去开头\n            {\n                temp.erase(s[left]);\n                left++;\n            }\n            temp.insert(s[i]);                         // 找到没有出现过的字符，加入\n            ans = max(ans,i-left+1);\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "滑动窗口",
                "哈希表",
                "字符串"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/5c639822/",
            "url": "http://dpm12345.cn/posts/5c639822/",
            "title": "最小栈",
            "date_published": "2022-01-24T14:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluLXN0YWNrLw==\">最小栈</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E6%9C%80%E5%B0%8F%E6%A0%88.png\" alt=\"最小栈详情\"></p>\n<p>要完成题目所要的功能，首先至少需要一个栈存储压入数据</p>\n<p>而对于该栈的使用方法有所不同</p>\n<h2 id=\"用一个栈存储数据，使用-vector-数组存最小值\"><a href=\"#用一个栈存储数据，使用-vector-数组存最小值\" class=\"headerlink\" title=\"用一个栈存储数据，使用 vector 数组存最小值\"></a>用一个栈存储数据，使用 vector 数组存最小值</h2><p>在该方法中，入栈时，用$vector$存储最小值，当栈为空即可直接将要压入栈的值作为最小值，放入数组末尾，而如果栈不为空，那么根据压入值与最小值的比较，将较小值放入$vector$数组末尾，这样做的好处是在$pop()$操作时，不需判断$pop()$的值是否为最小值，可直接$pop_back()$$vector$数组末尾值</p>\n<p>代码如下:</p>\n<pre><code class=\"cpp\">class MinStack {\nprivate:\n    stack&lt;int&gt;a;\n    vector&lt;int&gt;m;\npublic:\n    MinStack() {\n\n    }\n    \n    void push(int val) {\n        if(a.empty())\n        {\n            a.push(val);\n            m.push_back(val);\n        }\n        else\n        {\n            a.push(val);\n            if(val&lt;m.back())\n            {\n                m.push_back(val);\n            }\n            else\n            {\n                m.push_back(m.back());\n            }\n        }\n    }\n    \n    void pop() {\n        a.pop();\n        m.pop_back();\n    }\n    \n    int top() {\n        return a.top();\n      \n    }\n    \n    int getMin() {\n       return m.back();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj-&gt;push(val);\n * obj-&gt;pop();\n * int param_3 = obj-&gt;top();\n * int param_4 = obj-&gt;getMin();\n */\n</code></pre>\n<h2 id=\"栈不用于存储数据，同时不需要额外空间存储\"><a href=\"#栈不用于存储数据，同时不需要额外空间存储\" class=\"headerlink\" title=\"栈不用于存储数据，同时不需要额外空间存储\"></a>栈不用于存储数据，同时不需要额外空间存储</h2><p>在该方法中，栈中存储的数值为压入栈值与当前最小值的差值</p>\n<p>代码如下:</p>\n<pre><code class=\"cpp\">class MinStack {\npublic:\n    stack&lt;long long&gt; st;   // 使用 long long 防止数据溢出\n    long long minv;\n\n    MinStack() {\n        minv = -1;\n    }\n\n    void push(int val) {\n        if (!st.size()) {\n            st.push(0);\n            minv = val;\n        }\n        else {// 这次的值减去已有的最小值\n            long long diff = val - minv;\n            st.push(diff);\n            minv = diff &lt; 0 ? val : minv;\n        }\n    }\n\n    void pop() {\n        if (st.size()) {\n            long long diff = st.top();\n            st.pop();\n            if (diff &lt; 0)\n                minv -= diff;\n        }\n    }\n\n    int top() {\n        long long diff = st.top();\n        if (diff &lt; 0)\n            return minv;\n        else \n            return minv + diff;\n    }\n    \n    int getMin() {\n        return minv;\n    }\n};\n</code></pre>\n",
            "tags": [
                "vector",
                "栈"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/73645ce2/",
            "url": "http://dpm12345.cn/posts/73645ce2/",
            "title": "丑数",
            "date_published": "2022-01-14T14:54:40.000Z",
            "content_html": "<p>丑数，其所有因数均属于所给的数字集合，如对于因数 2，3，5，</p>\n<p>2，6，10 均为满足条件的丑数</p>\n<p>以下为 leetcode 上丑数的相关问题</p>\n<h1 id=\"丑数\"><a class=\"anchor\" href=\"#丑数\">#</a> 丑数</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdWdseS1udW1iZXIvc29sdXRpb24v\"> 丑数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"../../../post_images/%E4%B8%91%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\"></p>\n<p>根据丑数因数特点，我们可以依次不断除以所给因数集的各因数，如果其为丑数，结束后其必定变为数字 <code>1</code> ，如果不满足，其必不为 <code>1</code></p>\n<p>代码如下:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>丑数</span></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">bool</span> <span class=\"token function\">isUgly</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">int</span> div<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">%</span> div<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                n <span class=\"token operator\">/=</span> div<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">return</span> n<span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr></tbody></table></figure><h1 id=\"丑数-ii\"><a class=\"anchor\" href=\"#丑数-ii\">#</a> 丑数 II</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdWdseS1udW1iZXItaWkv\"> 丑数 II</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"../../../post_images/%E4%B8%91%E6%95%B0II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"\"></p>\n<p><strong>思路:</strong></p>\n<p>这一道题目的因数集与上题相同，但要求不同，求的是满足条件的第<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 个丑数</p>\n<p>仔细观察题目示例，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>4</mn><mo separator=\"true\">,</mo><mn>5</mn><mo separator=\"true\">,</mo><mn>6</mn><mo separator=\"true\">,</mo><mn>8</mn><mo separator=\"true\">,</mo><mn>9</mn><mo separator=\"true\">,</mo><mn>10</mn><mo separator=\"true\">,</mo><mn>12</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2,3,4,5,6,8,9,10,12]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">4</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">6</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">8</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">9</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mclose\">]</span></span></span></span> 为前十个丑数组成的序列，结合丑数特点，每个数字最多只有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">2,3,5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span></span></span></span>，三个因数，也就是说我们可以利用动态规划的思想，在前面的基础上乘以因数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn></mrow><annotation encoding=\"application/x-tex\">2,3,5</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span></span></span></span>​，得到的数必然为满足的丑数。由于要涵盖所有的数，那么前面的数都应要乘各项因数，因此可以为不同因数各设置一个记录应该乘第几个丑数的变量，并将所得乘积记录到数组中，在取时，只需取数组中的最小值即可，取出后相应的也需要更新该因数对应的最小数</p>\n<p>由于存在公倍数，因此在判断取出的数是哪个因数时需要对每个因素都进行判断一次，排除重复的情况</p>\n<p>代码如下:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>丑数II</span></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token function\">nthUglyNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span> <span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//dp [n] 表示第 n 个丑数</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        dp<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">// 默认第一个为 1</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token keyword\">int</span> p2 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> p3 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> p5 <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//p2,p3,p5 分别表示对应因数应乘的丑数下标</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>            <span class=\"token keyword\">int</span> num2 <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>p2<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> num3 <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>p3<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> num5 <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span>p5<span class=\"token punctuation\">]</span> <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 更新数组</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">min</span><span class=\"token punctuation\">(</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>num2<span class=\"token punctuation\">,</span> num3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> num5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 找到最小值</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> num2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                        <span class=\"token comment\">// 判断该最小值是否由因数 2 得到</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>                p2<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> num3<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                        <span class=\"token comment\">// 判断该最小值是否由因数 2 得到</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                p3<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> num5<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>                        <span class=\"token comment\">// 判断该最小值是否由因数 2 得到</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>                p5<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr></tbody></table></figure><h1 id=\"xxxxxxxxxx49-1class-solution-2public3-int-numislandsvectorvectorchar-grid-4-int-mgridsizengrid0size5-ifm0-6-return-07-int-ans08-forint-i0imi9-10-forint-j0jnj11-12-ifgridij113-14-ans15-gridij016-queuepairintints17-spushij18-whilesempty19-20-auto-rcsfront21-spop22-ifr-10gridr-1c123-24-gridr-1c025-spushr-1c26-27-ifr1mgridr1c128-29-gridr1c030-spushr1c31-32-ifc-10gridrc-1133-34-gridrc-1035-spushrc-136-37-ifc1ngridrc1138-39-gridrc1040-spushrc141-4243-44-45-46-47-return-ans48-49cpp-广度优先搜索4\"><a class=\"anchor\" href=\"#xxxxxxxxxx49-1class-solution-2public3-int-numislandsvectorvectorchar-grid-4-int-mgridsizengrid0size5-ifm0-6-return-07-int-ans08-forint-i0imi9-10-forint-j0jnj11-12-ifgridij113-14-ans15-gridij016-queuepairintints17-spushij18-whilesempty19-20-auto-rcsfront21-spop22-ifr-10gridr-1c123-24-gridr-1c025-spushr-1c26-27-ifr1mgridr1c128-29-gridr1c030-spushr1c31-32-ifc-10gridrc-1133-34-gridrc-1035-spushrc-136-37-ifc1ngridrc1138-39-gridrc1040-spushrc141-4243-44-45-46-47-return-ans48-49cpp-广度优先搜索4\">#</a> xxxxxxxxxx49&nbsp;1class Solution {2public:3 &nbsp; &nbsp;int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {4 &nbsp; &nbsp; &nbsp; &nbsp;int m=grid.size(),n=grid[0].size();5 &nbsp; &nbsp; &nbsp; &nbsp;if(m<mark>0) &nbsp;6 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return 0;7 &nbsp; &nbsp; &nbsp; &nbsp;int ans=0;8 &nbsp; &nbsp; &nbsp; &nbsp;for(int i=0;i&lt;m;i++)9 &nbsp; &nbsp; &nbsp;  {10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for(int j=0;j&lt;n;j++)11 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {12 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(grid[i][j]</mark>'1')13 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {14 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ans++;15 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[i][j]='0';16 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;queue&lt;pair&lt;int,int&gt;&gt;s;17 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({i,j});18 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while(!s.empty())19 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;auto [r,c]=s.front();21 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.pop();22 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(r-1&gt;=0&amp;&amp;grid[r-1][c]<mark>'1')23 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {24 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[r-1][c]='0';25 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({r-1,c});26 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }27 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(r+1&lt;m&amp;&amp;grid[r+1][c]</mark>'1')28 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {29 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[r+1][c]='0';30 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({r+1,c});31 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }32 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(c-1&gt;=0&amp;&amp;grid[r][c-1]<mark>'1')33 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  { &nbsp; &nbsp;34 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid[r][c-1]='0';35 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push({r,c-1});36 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }37 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(c+1&lt;n&amp;&amp;grid[r][c+1]</mark>'1') 38 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  {39 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;grid [r][c+1]='0';40 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;s.push ({r,c+1});41 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 42​43 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 44 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 45 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } 46 &nbsp; &nbsp; &nbsp;  } 47 &nbsp; &nbsp; &nbsp; &nbsp;return ans;48 &nbsp;  } 49};cpp  广度优先搜索 4</h1>\n<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VwZXItdWdseS1udW1iZXIv\"> 超级丑数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"../../../post_images/%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"超级丑数_题目详情\"></p>\n<p>这题与与丑数 II 十分相似，不同的是，因数集不在是固定为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>2</mn><mo separator=\"true\">,</mo><mn>3</mn><mo separator=\"true\">,</mo><mn>5</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[2,3,5]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">2</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">]</span></span></span></span>，而是由给定的数组决定。</p>\n<p>同样的沿用丑数 II 的思想，在丑数 II 中，首先需要存储丑数的数组 dp，同时用于实现动态规划思想，其次需要有记录各因数应乘丑数的下标和记录目前丑数集的<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">num</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span></span></span></span></p>\n<p>因此需要的变量为：</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy=\"false\">[</mo><mi>n</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">dp[n]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">p</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">]</span></span></span></span> 存储丑数</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>o</mi><mi>i</mi><mi>n</mi><mi>t</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">point[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">t</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 记录因数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">primes[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 应乘的丑数下标</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">nums[i]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">s</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">]</span></span></span></span> 存储丑数集，其中下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span> 对应因数下标<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span></li>\n</ul>\n<p>代码如下:</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"><span>超级丑数</span></figcaption><table><tbody><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">public</span><span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">int</span> <span class=\"token function\">nthSuperUglyNumber</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span><span class=\"token operator\">&amp;</span> primes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token operator\">&gt;</span><span class=\"token function\">point</span><span class=\"token punctuation\">(</span>primes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t<span class=\"token comment\">// 使用 long 防止数据溢出，因为虽然题目保证第 n 各数不会超出 32-bit，</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t<span class=\"token comment\">// 但我们在使用该方法时是找已知丑数的最小值，因此可能超过 32-bit</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">long</span><span class=\"token operator\">&gt;</span><span class=\"token function\">nums</span><span class=\"token punctuation\">(</span>primes<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        vector<span class=\"token operator\">&lt;</span><span class=\"token keyword\">long</span><span class=\"token operator\">&gt;</span><span class=\"token function\">dp</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span>n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>            <span class=\"token keyword\">long</span> minn<span class=\"token operator\">=</span>INT_MAX<span class=\"token punctuation\">;</span>             <span class=\"token comment\">// 用于找到丑数集中的最小数</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>                minn<span class=\"token operator\">=</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>minn<span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>minn<span class=\"token punctuation\">;</span>                   <span class=\"token comment\">// 放入存储丑数的数组中</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;</span>nums<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>minn<span class=\"token operator\">==</span>nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>         <span class=\"token comment\">// 表示目前找到的最小丑数可以有因数 primes [j] 得到</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>                <span class=\"token punctuation\">{</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>                    point<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 对应丑数小标加 1</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>                    nums<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>dp<span class=\"token punctuation\">[</span>point<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token operator\">*</span>primes<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 更新丑数集</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>                <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token punctuation\">}</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></pre></td></tr></tbody></table></figure>",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/45daaf11/",
            "url": "http://dpm12345.cn/posts/45daaf11/",
            "title": "环形链表",
            "date_published": "2021-12-31T11:54:40.000Z",
            "content_html": "<h1 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv\">环形链表</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<h2 id=\"利用哈希表\"><a href=\"#利用哈希表\" class=\"headerlink\" title=\"利用哈希表\"></a>利用哈希表</h2><p><strong>方法详情：</strong>由于如果一个链表是环形链表，那么在不断地跳入下一个结点坐标时，其地址必然与前面d的某个地址相同，也就是说，我们可以把每个结点的地址存入哈希表中，当出现要存入结点地址已经在哈希表中存过之后，那么该链表必然是环形链表，否则不是。据此，时间方面，我们可知只需最长只需遍历链表结点一遍；空间方面，我们创建了一个哈希表，最多存入链表的总个数$n$</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(n)$</li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        {\n            if(a.count(head))\n            return true;\n            a.insert({head,0});\n            head=head-&gt;next;\n        }\n        return false;\n        \n    }\n};\n</code></pre>\n<h2 id=\"利用双指针（快慢指针）\"><a href=\"#利用双指针（快慢指针）\" class=\"headerlink\" title=\"利用双指针（快慢指针）\"></a>利用双指针（快慢指针）</h2><p>题目中的进阶要求我们使用$O(1)$的内存，该方案是可以实现的，具体涉及到双指针方法详情：我们可以创建两个指针，快指针fast，每次走两步，慢指针slow，每次走一步。那么就很容易得到如果该环形链表为环形链表，快指针必定会在环形结点的某一个结点与慢指针相遇(或者说是追上慢指针)，那么只需判断最后两个指针是否指向同一个结点即可</p>\n<p><strong>证明：</strong>在该方法中，使用了分别走一步和两步的指针。如果该链表是环形链表，当慢指针进入环形部分中，此时快指针也在某处，设他们相差$n$个结点，而他们的速度之差为$1$，$n\\quad mod\\quad1==0$ 也就是说，必定存在某一时刻能够使两指针指向同一个地址据此，时间方面，在慢指针进入环形结点后，快慢指针初始相距最长为$L(L&lt;=N)$, 而在此之前遍历次数也只和$N$有关，如果没有环形链表，那么遍历次数为$\\lfloor$$\\frac{n}{2}$$\\rfloor$</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(1)$</li>\n</ul>\n<p>以下为代码：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode*fast=head,*slow=head;\n        while(fast!=NULL&amp;&amp;fast-&gt;next!=NULL)\n        {\n            fast=fast-&gt;next-&gt;next;\n            slow=slow-&gt;next;\n            if(fast==slow)\n                return true;\n        }\n        return false;\n    }\n};\n</code></pre>\n<h1 id=\"环形链表-II（求出环形链表开始结点位置）\"><a href=\"#环形链表-II（求出环形链表开始结点位置）\" class=\"headerlink\" title=\"环形链表 II（求出环形链表开始结点位置）\"></a>环形链表 II（求出环形链表开始结点位置）</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUtaWkv\">环形链表 II</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<p>该题与上面题目比较像，但在确定环的同时也要返回环开始结点</p>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><p>在上一个问题中，我们是找到重复就返回true，那么同理在这里我们可以使用相同的代码，仅仅把返回值的true和false分别改成对应节点和NULL即可</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(n)$</li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_map&lt;ListNode*,int&gt;a;\n        while(head!=NULL)\n        {\n            if(a.count(head))\n               return head;\n            a.insert({head,1});\n            head=head-&gt;next;\n        }\n        return NULL;\n    }\n};\n</code></pre>\n<h2 id=\"双指针（快慢指针）\"><a href=\"#双指针（快慢指针）\" class=\"headerlink\" title=\"双指针（快慢指针）\"></a>双指针（快慢指针）</h2><p>为了降低内存我们同样也可以使用快慢指针，将空间复杂度降到$O(1)$，这里涉及到一个证明</p>\n<p><img data-src=\"/../../../post_images/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II_%E8%AF%81%E6%98%8E.jpg\"></p>\n<p>所以我们可以在双指针基础上，在他们相遇时新建两个指针 (或者直接用现成的<code>head</code>和<code>slow/fast</code>指针，不断往后面走，相遇时得到该位置</p>\n<ul>\n<li>时间复杂度$O(n)$</li>\n<li>空间复杂度$O(1)$</li>\n</ul>\n<p>代码如下：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head,*fast=head;\n        while(fast&amp;&amp;fast-&gt;next)\n        {\n            slow=slow-&gt;next;\n            fast=fast-&gt;next-&gt;next;\n            if(slow==fast)\n            {\n                ListNode* start=head,*meet=slow;\n                while(start!=meet)\n                {\n                    start=start-&gt;next;\n                    meet=meet-&gt;next;\n                }\n                return meet;\n            }\n        }\n        return NULL;\n        \n    }\n};\n</code></pre>\n",
            "tags": [
                "哈希表",
                "链表",
                "双指针（快慢指针）"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/4a8b7903/",
            "url": "http://dpm12345.cn/posts/4a8b7903/",
            "title": "方法总结",
            "date_published": "2021-12-26T02:20:40.000Z",
            "content_html": "<h1 id=\"括号问题\"><a href=\"#括号问题\" class=\"headerlink\" title=\"括号问题\"></a>括号问题</h1><h2 id=\"是否为有效括号\"><a href=\"#是否为有效括号\" class=\"headerlink\" title=\"是否为有效括号\"></a>是否为有效括号</h2><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv\">有效的括号</span></p>\n<p>可采用栈的先入后出特性，一个个匹配</p>\n<h2 id=\"判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由-locked-存储\"><a href=\"#判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由-locked-存储\" class=\"headerlink\" title=\"判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由 locked 存储\"></a>判断一段字符串经过部分修改后是否能够成为有效括号字符串，可以修改的位置由 locked 存储</h2><p>如 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzaXMtc3RyaW5nLw==\">有效的括号字符串</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2hlY2staWYtYS1wYXJlbnRoZXNlcy1zdHJpbmctY2FuLWJlLXZhbGlkLw==\">判断一个括号字符串是否有效</span></p>\n<p>利用平衡值的方法，一个字符串是否为有效括号，那么在某个位置前的右括号之前必然有左括号相匹配，在某个某个位置的左括号之后必然有右括号相匹配</p>\n<p>以下为几种不同的具体方法</p>\n<h3 id=\"两次遍历，正序遍历和逆序遍历。\"><a href=\"#两次遍历，正序遍历和逆序遍历。\" class=\"headerlink\" title=\"两次遍历，正序遍历和逆序遍历。\"></a>两次遍历，正序遍历和逆序遍历。</h3><p>正序遍历时，用 count 记录此时未匹配左括号数，其中如果<code>locked[i]=′0′</code>，那么以左括号来记，当匹配到不可变的右括号时，<code>count−−</code>，如果<code>count &lt; 0</code>出现了，那么该字符串不是有效的括号字符串</p>\n<p>逆序遍历时，同正序遍历时的方法，用 count 记录此时未匹配右括号数，其中如果<code>locked[i]=′0′</code>，那么以右括号来记，当匹配到不可变的左括号时，<code>count−−</code>，如果<code>count &lt; 0</code>出现了，那么该字符串不是有效的括号字符串</p>\n<p>以下为参考代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool checkValidString(string s) {\n        int count=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(s[i]=='('||s[i]=='*')\n                count++;\n            else\n                count--;\n            if(count&lt;0)\n                return false;\n        }\n        count=0;\n        for(int i=s.size()-1;i&gt;=0;i--)\n        {\n            if(s[i]==')'||s[i]=='*')\n                count++;\n            else\n                count--;\n            if(count&lt;0)\n                return false;\n        }\n        return true;\n    }\n};\n</code></pre>\n<h3 id=\"贪心算法：一次遍历，用-maxc-记录最大未匹配数，minc-记录最小未匹配数\"><a href=\"#贪心算法：一次遍历，用-maxc-记录最大未匹配数，minc-记录最小未匹配数\" class=\"headerlink\" title=\"贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数\"></a>贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数</h3><p>当遇到不可变的右(左)括号时<code>maxc</code>，和<code>minc</code>都加一 (减一), 如果在此期间，<code>maxc &lt; 0</code>，那么证明有右括号不能被匹配那么这串字符串是无效的</p>\n<p>当遇到可变的位置时，由于既可以变也可以不变，那么<code>maxcpp</code>，<code>minc--</code>；其中如果<code>minc</code>减之前如果是0，那么<code>minc</code>就变为1，因为会增加(如果是<code>*</code>可代表左右括号或者空字符，那么只需维护<code>minc&gt;=0</code>即可，因为<code>*</code>有三种状态)</p>\n<p>如果在遍历过程中，<code>minc &gt; maxc</code>，那么证明该串是无效的</p>\n<p>最后如果该串是有效，那么<code>minc</code>必为0，所以返回值为<code>minc == 0</code></p>\n<p>代码示例</p>\n<h4 id=\"第一道\"><a href=\"#第一道\" class=\"headerlink\" title=\"第一道\"></a>第一道</h4><pre><code class=\"cpp\">class Solution {\npublic:\n    bool checkValidString(string s) {\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(s[i]=='(')\n            {\n                mincpp;\n                maxcpp;\n            }\n            else if(s[i]==')')\n            {\n                minc=minc==0?0:minc-1;\n                maxc--;\n                if(maxc&lt;0)\n                    return false;\n            }\n            else\n            {\n                minc=minc==0?0:minc-1;\n                maxcpp;\n            }\n        }\n        return minc==0;\n    }\n};\n</code></pre>\n<h4 id=\"第二道\"><a href=\"#第二道\" class=\"headerlink\" title=\"第二道\"></a>第二道</h4><pre><code class=\"cpp\">class Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        if(s.size()%2==1)  return false;\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(locked[i]=='1')\n            {\n                if(s[i]=='(')\n                {\n                    mincpp;\n                    maxcpp;\n                }\n                if(s[i]==')')\n                {\n                    maxc--;\n                    minc=minc==0?1:minc-1;\n                    if(maxc&lt;0)\n                        return false;\n                }\n            }\n            else\n            {\n                minc=minc==0?1:minc-1;\n                maxcpp;\n            }\n            if(minc&gt;maxc)\n                return false;\n        }\n        return minc==0;\n    }\n};\n</code></pre>\n",
            "tags": [
                "贪心",
                "括号"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/12ad1f11/",
            "url": "http://dpm12345.cn/posts/12ad1f11/",
            "title": "全排列",
            "date_published": "2021-12-24T01:54:40.000Z",
            "content_html": "<h1 id=\"无重复数字的全排列\"><a href=\"#无重复数字的全排列\" class=\"headerlink\" title=\"无重复数字的全排列\"></a>无重复数字的全排列</h1><p>先考虑 2 个数的全排列，很明显就是只有两种，一种两个数字的顺序不改变，另一种改变两个数字的顺序</p>\n<p>然后再考虑 3 个数的全排列，比如<code>1，2，3</code></p>\n<p>那么总共排列的种类总共为</p>\n<p>1，2，3<br>1，3，2<br>2，1，3<br>2，3，1<br>3，1，2<br>3，2，1</p>\n<p>由此不难发现，每一次的排列总个数（不同的数字开头）都可以看作是在前一种的基础上交换两个数的结果</p>\n<p>例如<code>1，3，2</code>是在<code>1，2，3</code>的基础上交换 2，3 位置后得到的。以此类推，4 个数，5 个数，n 个数也一样。那么在这里可以采用递归方法，与汉诺塔问题相似，我们将 n 个数划分为 1 和 n-1 个数，先交换两部分得到一种情况，然后以此为基础再进行交换，结束此种情况后将数字交换回来进入下一种情况</p>\n<p>因此我们可以构造 perm 函数，第一个形参为数组，第二个为未交换数，第三个为数组的末尾下标</p>\n<p>因此核心代码为:</p>\n<pre><code class=\"cpp\">// 假设这里的递归函数为 perm，数组为 nums，交换的对象为 nums [i] 和 nums [k]\n    for(int i=k;i&lt;=m;i++)        // 这里用于把后面的数进行交换\n    {\n        swap(nums[i],nums[k]);            // 交换，创造新的情况\n        perm(nums,k+1,m);                 // 进入新的情况，k+1 为之后未交换的情况\n        swap(nums[i],nums[k]);           // 交换回来\n    }\n</code></pre>\n<p>这里我们需要考虑原来的情况，也就是说此时不需要交换，所以为了保持代码的一致性，可以一开始使其与自身交换，因此为<code>swap(nums[i],nums[k])</code></p>\n<p>代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    void swap(int*p,int*q)\n    {\n        int temp=*p;\n        *p=*q;\n        *q=temp;\n    }\n    void out(vector&lt;int&gt;&amp;nums,vector&lt;vector&lt;int&gt;&gt;&amp;ans,int k,int m)\n    {\n        if(k==m)\n        {\n            ans.push_back(nums);\n        }\n        else\n        {\n            for(int i=k;i&lt;=m;i++)\n            {\n                swap(&amp;nums[i],&amp;nums[k]);\n                out(nums,ans,k+1,m);\n                swap(&amp;nums[i],&amp;nums[k]);\n            }\n        }\n    }\n    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {\n        vector&lt;vector&lt;int&gt;&gt;ans;\n        out(nums,ans,0,nums.size()-1);\n        return ans;\n    }\n};\n</code></pre>\n<p>该问题在 leetcode 也有题目</p>\n<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==\">全排列</span></p>\n<h1 id=\"有重复数字的全排列\"><a href=\"#有重复数字的全排列\" class=\"headerlink\" title=\"有重复数字的全排列\"></a>有重复数字的全排列</h1>",
            "tags": [
                "递归"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/3b3e846/",
            "url": "http://dpm12345.cn/posts/3b3e846/",
            "title": "换酒问题",
            "date_published": "2021-12-17T06:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2F0ZXItYm90dGxlcy8=\">换酒问题</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<h1 id=\"模拟\"><a href=\"#模拟\" class=\"headerlink\" title=\"模拟\"></a>模拟</h1><pre><code class=\"cpp\">class Solution {\npublic:\n    int numWaterBottles(int numBottles, int numExchange) {\n        int ans=0,have=numBottles,empty=0;\n        while(have!=0)\n        {\n            ans+=have;\n            empty+=have;\n            have=empty/numExchange;\n            empty=empty%numExchange;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"数学\"><a href=\"#数学\" class=\"headerlink\" title=\"数学\"></a>数学</h1><p>假设开始有$n$个酒瓶，$m$个空酒瓶换一瓶酒，那么每次消耗的酒瓶数为$m-1$，所以答案即为<br>$$<br>\\lfloor \\frac{n}{m-1} \\rfloor<br>$$</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int numWaterBottles(int numBottles, int numExchange) {\n        return numBottles &gt;= numExchange ? (numBottles - numExchange) / (numExchange - 1) + 1 + numBottles : numBottles;\n    }\n};\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.cn/posts/9e6e8fdc/",
            "url": "http://dpm12345.cn/posts/9e6e8fdc/",
            "title": "子序列问题",
            "date_published": "2021-12-09T01:54:40.000Z",
            "content_html": "<h1 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1jb21tb24tc3Vic2VxdWVuY2Uv\">最长公共子序列</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\"></p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\"></p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><p>我们可以用$dp [i][j]$表示字符串1$[0<del>i]$范围内和字符串2$ [0</del>i]$范围内的最长公共序列</p>\n<p>当$text1[i]=text2[j]$时，很明显 $dp [i][j]=dp [i-1][j-1]+2$</p>\n<p>当$text1[i]!=text2[j]$时，$dp[i][j]=max(dp[i][j-1],dp[i-1][j])$</p>\n<p>因为此时需要找个最长的子序列为然后连接上后面未知的字符，这样遍历到最后就能得到最大</p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.length(),n=text2.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1));\n        int ans=0;\n        for(int i=1;i&lt;=m;i++)\n        {\n            for(int j=1;j&lt;=n;j++)\n            {\n                if(text1[i-1]==text2[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"最长回文子序列\"><a href=\"#最长回文子序列\" class=\"headerlink\" title=\"最长回文子序列\"></a>最长回文子序列</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXBhbGluZHJvbWljLXN1YnNlcXVlbmNlL3N1Ym1pc3Npb25zLw==\">最长回文子序列</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.jpg\"></p>\n<h2 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h2><p>沿用求最长公共子序列的方法，我们可以先将字符串反转，得到一个新的字符串，再求这两个字符串的最长公共子序列的值，即为最长回文子序列</p>\n<p><strong>证明：</strong> 回文串的表现为成对称分布，从前往后遍历和从后往前遍历的结果是一样的，所以说如果求其与其本身的反转字符串的最长公共子序列，因为一个是正向，一个是反向，当求的该共同字符串时，那就说明该字符子序列在原字符串中为回文子序列，又由于在求解过程中记录的为最长，那么结果就能得到最长回文子序列</p>\n<p>下面为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        string re=s;\n        int ans=0;\n        reverse(re.begin(),re.end());\n        vector&lt;vector&lt;int&gt;&gt;dp(s.length()+1,vector&lt;int&gt;(s.length()+1));\n        for(int i=1;i&lt;=s.length();i++)\n        {\n            for(int j=1;j&lt;=re.length();j++)\n            {\n                if(s[i-1]==re[j-1])\n                    dp[i][j]=dp[i-1][j-1]+1;\n                else\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        return ans;\n\n    }\n};\n</code></pre>\n<h2 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h2><p>根据回文串的特征，如果一段字符串是回文串，那么将其两边各删去一个字符后依然为回文串，所以我们可以用$dp[i][j]$来表示$i$到$j$最长回文子序列的长度，当遍历时，如果$s[i]=s[j]$，那么$dp[i]=dp[i+1][j-1]+2$，如果不相等，$dp[i][j]=max(dp[i+1][j],dp[i][j-1]$</p>\n<p>需要注意的是，回文串最短为其本身，所以在开始真正寻找前，可以先将$dp [i][i]=1$</p>\n<p>在这里，我们选择由后至前推导，根据上方思想，那么最后的值应为$dp [0][n-1]$($n$为字符串长度)</p>\n<p>下面为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n=s.length();\n        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(n));\n        for(int i=n-1;i&gt;=0;i--)\n        {\n            dp[i][i]=1;\n            for(int j=i+1;j&lt;n;j++)\n            {\n                if(s[j]==s[i])\n                    dp[i][j]=dp[i+1][j-1]+2;\n                else\n                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);\n            }\n        }\n        return dp[0][n-1];\n    }\n};\n</code></pre>\n",
            "tags": [
                "动态规划",
                "子序列",
                "最长公共子序列",
                "最长回文子序列"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/ca7417e/",
            "url": "http://dpm12345.cn/posts/ca7417e/",
            "title": "三个无重叠子数组的最大和",
            "date_published": "2021-12-09T01:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWZ1bmN0aW9uLw==\">旋转函数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0.jpg\"></p>\n<p>解题思路:</p>\n<p>由题目中的旋转函数形式<br>$$<br>F(k) = 0 * B_k[0] + 1 * B_k[1] + … + (n-1) * B_k[n-1]<br>$$<br>以题目示例为例</p>\n<blockquote>\n<p>A = [4, 3, 2, 6]</p>\n</blockquote>\n<blockquote>\n<p>F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25 </p>\n<p>F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16 F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23 F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26</p>\n</blockquote>\n<p>即<br>$$<br>F(0) = (0 * A [0]) + (1 * A [1]) + (2 * A [2]) + (3 * A [3])<br>$$</p>\n<p>$$<br>F(1) = (0 * A[3]) + (1 * A[0]) + (2 * A[1]) + (3 * A[2])<br>$$</p>\n<p>$$<br>F(2) = (0 * A[2]) + (1 * A[3]) + (2 * A[0]) + (3 * A[1])<br>$$</p>\n<p>$$<br>F(3) = (0 * A[1]) + (1 * A[2]) + (2 * A[3]) + (3 * A[0])<br>$$</p>\n<p>将相邻两个函数相减，可以发现<br>$$<br>F(1)-F(0)=A[0]+A[1]+A[2]+A[3]-4*A[3]<br>$$</p>\n<p>$$<br>F(2)-F(1)=A[0]+A[1]+A[2]+A[3]-4*A[2]<br>$$</p>\n<p>$$<br>F(3)-F(2)=A[0]+A[1]+A[2]+A[3]-4*A[1]<br>$$</p>\n<p>那么可以发现一般规律<br>$$<br>F(k)-F(k-1)=A[0]+A[1]+A[2]+A[3]+···+A[n-1]-n<em>A[n-k];<br>$$<br>形式为数组A元素之和减去$n</em>A[n-k]$</p>\n<p>由此我们可以维护一个$dp$数组，$dp[i]$表示$F(k)$; 一个$sum$表示$A$的元素之和。<br>$$<br>dp[i]=dp[i-1]+sum-n*A[n-i];<br>$$<br>特别的，当$i=0$时，$dp[i]=sum$。</p>\n<p>最后输出$dp[i]$的最大值</p>\n<p>因此，代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxRotateFunction(vector&lt;int&gt;&amp; nums) {\n        int n=nums.size();\n        int sum=0;\n        vector&lt;int&gt;dp(n);\n        for(int i=0;i&lt;n;i++)\n        {\n            sum+=nums[i];\n            dp[0]+=i*nums[i];\n        }\n        for(int i=1;i&lt;n;i++)\n        {\n            dp[i]=dp[i-1]+sum-n*nums[n-i];\n        }\n        return *max_element(dp.begin(),dp.end());\n    }\n};\n</code></pre>\n",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/ca7417e/",
            "url": "http://dpm12345.cn/posts/ca7417e/",
            "title": "三个无重叠子数组的最大和",
            "date_published": "2021-12-08T01:54:40.000Z",
            "content_html": "<p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1zdW0tb2YtMy1ub24tb3ZlcmxhcHBpbmctc3ViYXJyYXlzLw==\"> 三个无重叠子数组的最大和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.jpg\"></p>\n<p>该题为 2021-12-8 的每日一题，可解决该问题的方法涉及到前缀和，动态规划，滑动窗口知识</p>\n<p>思路: 题目要求求出某一数组三个长度为 k 的无重叠数组，使它们的元素之和为最大。</p>\n<p>看到这个个数为 k，很容易想到滑动窗口这一算法，只是在这里，需要同时存在三个滑动窗口，</p>\n<p>同样的，在这题，也可以用动态规划进行解决</p>\n<p>下面是我自己在解题时的过程</p>\n<h1 id=\"动态规划（劣质版）\"><a href=\"#动态规划（劣质版）\" class=\"headerlink\" title=\"动态规划（劣质版）\"></a>动态规划（劣质版）</h1><p>刚拿到题目时，我能想到，该题可以使用动态规划解决，但并无方向该从哪个地方下手将什么作为$dp[i]$所表达的意义，</p>\n<p>思考了大约20分钟后，我还是无从下手，于是打开了题解，第一眼看到的是”单个子数组的最大和“，顿时恍然大悟，我可以将不同个数的子数组作为一个$dp$，在计算个数加一时，便可以利用前面的$dp$，得到最优解。仔细思考，该方案的时间复杂度为$O(n)$。</p>\n<p>在以下的代码中，我是如此考虑的：</p>\n<p>先用$sum[i]$计算前缀和，为后续计算提供便利再分别使用$dp1$，$dp2$，$dp3$记录不同个数的子数组元素的最大值，其转移方程分别为：<br>$$<br>dp1[i]=max{dp1[i-1],sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>$$<br>dp2[i]=max{dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>$$<br>dp3[i]=max{dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]}<br>$$</p>\n<p>但这样并不能记录下标输出答案，所以这里我采用了，三个flag数组，用于记录下标，具体见代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n        vector&lt;int&gt;flag1(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n        vector&lt;pair&lt;int,int&gt;&gt;flag3(n);\n        vector&lt;int&gt;sum(n+1,0);\n        vector&lt;int&gt;ans;\n        for(int i=0;i&lt;n;i++)\n        {\n            sum[i+1]+=nums[i]+sum[i];           \n        }\n        for(int i=k-1;i&lt;n;i++)\n        {\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            {\n                flag1[i]=flag1[i-1];\n            }\n            else\n            {\n                flag1[i]=i-k+1;\n            }\n        }\n        for(int i=2*k-1;i&lt;n;i++)\n        {\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            {\n                flag2[i]=flag2[i-1];\n            }\n            else\n            {\n                flag2[i]={flag1[i-k],i-k+1};\n            }\n        }\n        for(int i=3*k-1;i&lt;n;i++)\n        {\n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            {\n                flag3[i]=flag3[i-1];\n            }\n            else\n            {\n                flag3[i]={flag2[i-k].second,i-k+1};\n            }\n        }\n        return {flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second};\n    }\n};\n</code></pre>\n<p>xxxxxxxxxx&nbsp;class Solution {public: &nbsp; &nbsp;int maxResult(vector<int>&amp; nums, int k) { &nbsp; &nbsp; &nbsp; &nbsp;int n = nums.size(); &nbsp; &nbsp; &nbsp; &nbsp;vector<int> dp(n); &nbsp; &nbsp; &nbsp; &nbsp;dp[0] = nums[0]; &nbsp; &nbsp; &nbsp; &nbsp;priority_queue&lt;pair&lt;int, int&gt;&gt; q; &nbsp; &nbsp; &nbsp; &nbsp;q.emplace(nums[0], 0); &nbsp; &nbsp; &nbsp; &nbsp;for (int i = 1; i &lt; n; ++i) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (i - q.top().second &gt; k) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;q.pop(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;dp[i] = q.top().first + nums[i]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;q.emplace(dp[i], i); &nbsp; &nbsp; &nbsp;  } &nbsp; &nbsp; &nbsp; &nbsp;return dp[n - 1]; &nbsp;  }};cpp 优先级队列2</int></int></p>\n<p><img data-src=\"/../../../post_images/%E6%89%A7%E8%A1%8C%E9%94%99%E8%AF%AF.png\"></p>\n<p>观察报错信息，可知，在我的代码中，并未考虑<code>k==1</code>的情况，因为代码中我是通过<code>for(int i=k-1;i&lt;n;i++)</code>实现循环的，k-1 就会为 0，至于后面 i-1 造成错误</p>\n<p>改进代码:</p>\n<pre><code class=\"cpp\">if(k==1)                      // 考虑 k==1 的情况\n    {\n        vector&lt;int&gt;ans(3);\n        for(int i=0;i&lt;3;i++)\n        {\n            ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n        }\n        sort(ans.begin(),ans.end());\n        return ans;\n    }\n</code></pre>\n<p>再次提交，发现答案出错，如下:</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%89%E4%B8%AA%E6%97%A0%E9%87%8D%E5%8F%A0.png\"></p>\n<p>在这并不能看出什么，为此，我进行了多组数据的尝试，发现第一个大部分都不符合答案，但后两个一直都是正确的，说明<code>flag1</code>求解过程无误，而是输出出错</p>\n<p>对此，进行代码分析，最后输出时，我写的是</p>\n<p><code>return {flag2[flag3[n-1].first].first,flag3[n-1].first,flag3[n-1].second};</code></p>\n<p><code>[flag2[flag3[n-1].first].first</code>，因为我在<code>flag3.first</code>存入的是<code>flag2</code>的索引的第二个元素，以此来得到<code>flag1</code>明显是不可行的，因为对应<code>flag1</code>的下标与<code>flag2</code>的第二个元素并无关系，<code>flag1[i-k]</code>可能是前一个继承来的，与<code>flag2</code>的第二个元素无关，也有可能与其有关，总之该方法不一定正确</p>\n<p>那么我做以下修改</p>\n<ol>\n<li>重新定义<code>flag3</code>数组类型，为<code>&lt;pair&lt;pair&lt;int,int&gt;，int&gt;&gt;</code></li>\n<li>存入<code>flag3</code>时存入<code>{flag2 [i-k],i-k+1}</code></li>\n<li>读取第一个使用<code>flag3[n-1].first.first</code>，第二个使用<code>flag3[n-1].first.second</code></li>\n</ol>\n<p>以下为修改后的代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        if(k==1)                      // 考虑 k==1 的情况\n        {\n            vector&lt;int&gt;ans(3);\n            for(int i=0;i&lt;3;i++)\n            {\n                ans[i]=max_element(nums.begin(),nums.end())-nums.begin();\n                *max_element(nums.begin(),nums.end())=0;\n            }\n            sort(ans.begin(),ans.end());\n            return ans;\n        }\n        //dp [i] 表示 0 到该位置所能得到的 x 个无重叠数组和的最大值\n        vector&lt;int&gt;dp1(n),dp2(n),dp3(n);\n        \n        //flag1 记录某一位置 1 个最大无重叠数组的下标       \n        vector&lt;int&gt;flag1(n);\n        \n        //flag2 记录某一位置 2 个最大无重叠数组的下标    \n        vector&lt;pair&lt;int,int&gt;&gt;flag2(n);\n        \n        //flag3 记录某一位置 3 个最大无重叠数组的下标                  \n        vector&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt;flag3(n);              \n        \n        //sum [i] 表示前 i 个数之和\n        vector&lt;int&gt;sum(n+1,0); \n        \n        for(int i=0;i&lt;n;i++)                       // 计算前缀和\n        {\n            sum[i+1]+=nums[i]+sum[i];           \n        }\n        \n        // 计算从 k-1 开始 1 个无重叠子数组最大的值，用 flag1 记录下标值\n        for(int i=k-1;i&lt;n;i++)                      \n        {\n            dp1[i]=max(dp1[i-1],sum[i+1]-sum[i-k+1]);\n            if(dp1[i]==dp1[i-1])\n            {\n                flag1[i]=flag1[i-1];\n            }\n            else\n            {\n                flag1[i]=i-k+1;\n            }\n        }\n        \n        // 计算从 2*k-1 开始 2 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=2*k-1;i&lt;n;i++)                   \n        {\n            dp2[i]=max(dp2[i-1],dp1[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp2[i]==dp2[i-1])\n            {\n                flag2[i]=flag2[i-1];\n            }\n            else\n            {\n                flag2[i]={flag1[i-k],i-k+1};\n            }\n        }\n        \n        // 计算从 3*k-1 位置开始 3 个无重叠子数组最大的值，用 flag2 记录下标值\n        for(int i=3*k-1;i&lt;n;i++)                        \n        { \n            dp3[i]=max(dp3[i-1],dp2[i-k]+sum[i+1]-sum[i-k+1]);\n            if(dp3[i]==dp3[i-1])\n            {\n                flag3[i]=flag3[i-1];\n            }\n            else\n            {\n                flag3[i]={flag2[i-k],i-k+1};\n            }\n        }\n        \n        // 根据 flag3 找寻下标\n        return {flag3[n-1].first.first,flag3[n-1].first.second,flag3[n-1].second};   \n    }\n};\n</code></pre>\n<h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><p>维护<code>sum1</code>，<code>sum2</code>，<code>sum3</code>，分别表示<code>n</code>个子数组的最大值，若大于原来的更新下标(代码中为<code>sum1maxid,sum2maxid1,sum2maxid2</code>) 当数组个数大于等于k时，那么需删去首个元素，更新窗口</p>\n<p>以下为代码实现</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; maxSumOfThreeSubarrays(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        int sum1=0,sum2=0,sum3=0;\n        int sum1max=0,sum2max=0,sum3max=0;\n        int sum1maxid,sum2maxid1,sum2maxid2;\n        vector&lt;int&gt;ans;\n        for(int i=2*k;i&lt;n;i++)\n        {\n            sum1+=nums[i-2*k];\n            sum2+=nums[i-k];\n            sum3+=nums[i];\n            if(i&gt;=3*k-1)\n            {\n                if(sum1&gt;sum1max)\n                {\n                    sum1max=sum1;\n                    sum1maxid=i-3*k+1;          // 更新 1 个子数组最大值下标\n                }\n                if(sum1max+sum2&gt;sum2max)\n                {\n                    sum2max=sum1max+sum2;\n                    sum2maxid1=sum1maxid;       // 更新两个子数组中 1 个子数组最大值下标\n                    sum2maxid2=i-2*k+1;         // 更新 1 个子数组最大值下标\n                }\n                if(sum2max+sum3&gt;sum3max)\n                {\n                    sum3max=sum2max+sum3;\n                    ans={sum2maxid1,sum2maxid2,i-k+1};  // 更新答案\n                }\n                sum1-=nums[i-3*k+1];             // 删去首个\n                sum2-=nums[i-2*k+1];             // 删去首个\n                sum3-=nums[i-k+1];               // 删去首个\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "前缀和",
                "动态规划",
                "滑动窗口"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/65c00a51/",
            "url": "http://dpm12345.cn/posts/65c00a51/",
            "title": "边界着色 岛屿数量",
            "date_published": "2021-12-07T07:54:40.000Z",
            "content_html": "<h1 id=\"边界着色\"><a href=\"#边界着色\" class=\"headerlink\" title=\"边界着色\"></a>边界着色</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29sb3JpbmctYS1ib3JkZXIv\">边界着色</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2.jpg\"></p>\n<p>思路：与 200.岛屿数量题相类似，可以使用深度优先搜索或广度优先搜索进行解题。先找出满足连通分量的位置，再判断是否为边界</p>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><p><strong>以下为代码</strong></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n        vector&lt;pair&lt;int, int&gt;&gt; borders;\n        int originalColor = grid[row][col];\n        visited[row][col] = true;\n        dfs(grid, row, col, visited, borders, originalColor);\n        for (auto &amp; [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n\n    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, vector&lt;vector&lt;bool&gt;&gt; &amp; visited, vector&lt;pii&gt; &amp; borders, int originalColor) {\n        int m = grid.size(), n = grid[0].size();\n        bool isBorder = false;\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int i = 0; i &lt; 4; i++) {\n            int nx = direc[i][0] + x, ny = direc[i][1] + y;\n            if (!(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == originalColor)) {\n                isBorder = true;\n            } else if (!visited[nx][ny]) {\n                visited[nx][ny] = true;\n                dfs(grid, nx, ny, visited, borders, originalColor);\n            }                \n        }\n        if (isBorder) {\n            borders.emplace_back(x, y);\n        }\n    }\n};\n</code></pre>\n<h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h2><pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int row, int col, int color) {\n        int m = grid.size(), n = grid[0].size();\n        vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));\n        vector&lt;pair&lt;int, int&gt;&gt; borders;\n        int originalColor = grid[row][col];\n        int direc[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.emplace(row, col);\n        visited[row][col] = true;\n        while (!q.empty()) {\n            pair&lt;int, int&gt; &amp; node = q.front();\n            q.pop();\n            int x = node.first, y = node.second;\n\n            bool isBorder = false;\n            for (int i = 0; i &lt; 4; i++) {\n                int nx = direc[i][0] + x, ny = direc[i][1] + y;\n                if (!(nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == originalColor)) {\n                    isBorder = true;\n                } else if (!visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    q.emplace(nx, ny);\n                }         \n            }\n            if (isBorder) {\n                borders.emplace_back(x, y);\n            }\n        }\n        for (auto &amp; [x, y] : borders) {\n            grid[x][y] = color;\n        }\n        return grid;\n    }\n};\n</code></pre>\n<h1 id=\"岛屿数量\"><a href=\"#岛屿数量\" class=\"headerlink\" title=\"岛屿数量\"></a>岛屿数量</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLWlzbGFuZHMv\">岛屿数量</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.png\"></p>\n<h2 id=\"深度优先搜索-1\"><a href=\"#深度优先搜索-1\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><pre><code class=\"cpp\">class Solution {\npublic:\n    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int r,int c)\n        {\n            int m=grid.size(),n=grid[0].size();\n            grid[r][c]='0';\n            if(r-1&gt;=0&amp;&amp;grid[r-1][c]=='1')  dfs(grid,r-1,c);\n            if(r+1&lt;m&amp;&amp;grid[r+1][c]=='1')  dfs(grid,r+1,c);\n            if(c-1&gt;=0&amp;&amp;grid[r][c-1]=='1')  dfs(grid,r,c-1);\n            if(c+1&lt;n&amp;&amp;grid[r][c+1]=='1')  dfs(grid,r,c+1);\n        }\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        int m=grid.size(),n=grid[0].size();\n        if(m==0)return 0;\n        int ans=0;\n        for(int i=0;i&lt;m;i++)\n        {\n            for(int j=0;j&lt;n;j++)\n            {\n                if(grid[i][j]=='1')\n                {\n                    ans++;\n                    dfs(grid,i,j);\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h2 id=\"广度优先搜索-1\"><a href=\"#广度优先搜索-1\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h2><pre><code class=\"cpp\">class Solution {\npublic:\n    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {\n        int m=grid.size(),n=grid[0].size();\n        if(m==0)  \n            return 0;\n        int ans=0;\n        for(int i=0;i&lt;m;i++)\n        {\n            for(int j=0;j&lt;n;j++)\n            {\n                if(grid[i][j]=='1')\n                {\n                    ans++;\n                    grid[i][j]='0';\n                    queue&lt;pair&lt;int,int&gt;&gt;s;\n                    s.push({i,j});\n                    while(!s.empty())\n                    {\n                        auto [r,c]=s.front();\n                        s.pop();\n                        if(r-1&gt;=0&amp;&amp;grid[r-1][c]=='1')\n                        {\n                            grid[r-1][c]='0';\n                            s.push({r-1,c});\n                        }\n                        if(r+1&lt;m&amp;&amp;grid[r+1][c]=='1')\n                        {\n                            grid[r+1][c]='0';\n                            s.push({r+1,c});\n                        }\n                        if(c-1&gt;=0&amp;&amp;grid[r][c-1]=='1')\n                        {    \n                            grid[r][c-1]='0';\n                            s.push({r,c-1});\n                        }\n                        if(c+1&lt;n&amp;&amp;grid[r][c+1]=='1')\n                        {\n                            grid[r][c+1]='0';\n                            s.push({r,c+1});\n                        }\n\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "深度优先搜索",
                "广度优先搜索"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/5beb97b2/",
            "url": "http://dpm12345.cn/posts/5beb97b2/",
            "title": "无重叠区间",
            "date_published": "2021-12-06T11:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbm9uLW92ZXJsYXBwaW5nLWludGVydmFscy8=\">无重叠区间</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.png\"></p>\n<p>思路：在这道题中，我们可以把题目要求所解问题换一种说法，找删去最少区间使剩下成为无重叠区间，即包含区间最多数。</p>\n<p>我们注意到，当其为无重叠区间时，前一个区间的末端必然小于等于后一个区间首端，那么我们便可以将这一组的无重叠区间的端点看作为一组不严格单调递增的序列。这样便与求 “最长上升序列” 的序列的问题相同了。</p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>我们维护一个数组$dp[i]$，其中$dp[i]$以该位置为末尾区间的，所能得到的数量最多的无重叠区间的值。那么很容易得到，先分别枚举末尾区间位置，再从0开始遍历，寻找最长，转移方程即为： $dp[i]=max(dp[j]+1,dp[i])$（当$intervals[j][1]&lt;intervals[i][0]$时)</p>\n<p>以下为代码:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        sort(intervals.begin(),intervals.end());\n        int n=intervals.size();\n        vector&lt;int&gt;dp(n,1);\n        for(int i=0;i&lt;intervals.size();i++)\n        {\n            for(int j=0;j&lt;i;j++)\n            {\n                if(intervals[j][1]&lt;=intervals[i][0])\n                {\n                    dp[i]=max(dp[j]+1,dp[i]);\n                }\n            }\n        }\n        return n-*max_element(dp.begin(),dp.end());\n\n    }\n};\n</code></pre>\n<p>提交后很不幸，超时了，时间复杂度为$O(n^2)$, 为此我们需要将时间优化。</p>\n<h1 id=\"贪心方案\"><a href=\"#贪心方案\" class=\"headerlink\" title=\"贪心方案\"></a>贪心方案</h1><p>上面的动态规划方案中，枚举末尾，再从0开始遍历，寻找最长，这是无法避免的，为此难以优化，这样，我们可以使用贪心方案，将时间复杂度降低 </p>\n<p>实现思想: 我们要想得到最多数量的无重叠区间，那么我们需要尽可能地将区间长度较小地放入这一无重叠区间内，因此我们可以设想，如果我们将各个区间地右端点按升序排序，设一个变量<code>right</code>为目前无重叠区间的右端点，如果下一个区间的左端大于<code>right</code>，区间加一，<code>right</code>更新，这样以此类推， 最终可以得到答案 </p>\n<p>证明：由于我们是将右端点降序排序，那么当两段区间相同时，实际上无论选择哪段结果都是一样的，因为不管该区间的左端点为多少，后面的区间只要左区间不大于<code>right</code>，那么该区间必会被删。而当之后区间的左端点大于<code>right</code>时，那么此时所选取的区间的右端点必然是满足条件的最小值，也因此能够得到最多数量的无重叠区间 </p>\n<p>以下为实现代码:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        if (intervals.empty()) {\n            return 0;\n        }\n        \n        sort(intervals.begin(), intervals.end(), [](const auto&amp; u, const auto&amp; v) {\n            return u[1] &lt; v[1];\n        });\n\n        int n = intervals.size();\n        int right = intervals[0][1];\n        int ans = 1;\n        for (int i = 1; i &lt; n; ++i) {\n            if (intervals[i][0] &gt;= right) {\n                ++ans;\n                right = intervals[i][1];\n            }\n        }\n        return n - ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/6f1a75f/",
            "url": "http://dpm12345.cn/posts/6f1a75f/",
            "title": "跳跃游戏 VI",
            "date_published": "2021-12-05T06:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLXZpLw==\">跳跃游戏 VI</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/1696%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI.jpg\"></p>\n<h1 id=\"初期想法\"><a href=\"#初期想法\" class=\"headerlink\" title=\"初期想法\"></a>初期想法</h1><p>看到题目，很容易想到使用动态规划算法，$dp[i]$表示跳到位置$i$能取到的最大的值,其中$dp[i]=min{dp[i-1],dp[i-2]……,dp[i-k]}+nums[i]$, 那么很容易写出代码 如图</p>\n<p><img data-src=\"/../../../post_images/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FVI_%E5%88%9D%E5%A7%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png\"></p>\n<p>但是已提交便发现，超时了，也就是说纯纯动态规划不能完成题目要求。</p>\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>思考初期想法的代码，哪里造成了代码超时呢？</p>\n<p>不难发现，在确定$i$位置前的$[i-k,i-1]$范围内的最小值时，每一个都比较了一次，而当$i$加一时，除去上次的$i-k$，和新增的$i-1$，其他位置又比较了一次，如果最大值，即比较过后仍然比较，其原因是缺少记录最大值的渠道。那么是否可以在循环时加上一个变量MAX记录$[i-k,i-1]$的最大值，当$i+1$时，将MAX与$dp[i]$比较呢？</p>\n<p>其结果是只能解决一部分，因为假设$MAX=dp[i-k]$，当$i+1$时，MAX的值明显不在之后的$[i-k,i-1]$范围之内了，因此要将原来范围内的次大值与$dp[i]$比较，这样我们又多了个任务，求次大值，所以单纯增加一个变量并不能解决问题。</p>\n<p>下面为解决方案：</p>\n<h1 id=\"优化（单调队列）\"><a href=\"#优化（单调队列）\" class=\"headerlink\" title=\"优化（单调队列）\"></a>优化（单调队列）</h1><p>经过上面的分析，我们需要存储$[i-k,i-1]$内的最大值，同时要在最大值被删去时能快速得到之后的最大值那么，队列无非是我们的选择</p>\n<p>方法：为方便，我们将元素下标存入队列中队列内的元素按降序排序，即队首为最大元素的下标，队列第二个元素即为次大值循环时，首先先确保队首元素满足在下标$[i-k,i-1]$范围内，如不满足则删除队首，然后再进行$dp[i]$的计算$dp[i]=dp[q.front()]+nums[i]$，最后向队列中存入元素$dp[i]$（若$dp[i]&gt;dp[q.back()]$, 便可将队尾元素删除，直到$dp[i]&lt;=dp[q.back]$或队列为空），这样便为后面取最大值做准备。</p>\n<p>因此，代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) {\n        int n=nums.size();\n        vector&lt;int&gt;dp(n);\n        dp[0]=nums[0];\n        deque&lt;int&gt;q;\n        q.push_back(0);\n        for(int i=1;i&lt;n;i++)\n        {\n            while(q.size()&amp;&amp;i-q.front()&gt;k)\n            {\n                q.pop_front();\n            }\n            dp[i]=dp[q.front()]+nums[i];\n            while(q.size()&amp;&amp;dp[i]&gt;dp[q.back()])\n            {\n                q.pop_back();\n            }\n            q.push_back(i);\n        }\n        return dp[n-1];\n    }\n};\n</code></pre>\n<h1 id=\"优化（优先级队列）\"><a href=\"#优化（优先级队列）\" class=\"headerlink\" title=\"优化（优先级队列）\"></a>优化（优先级队列）</h1><p>与单调队列思想相同，只是优先级队列不用进行排序</p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxResult(vector&lt;int&gt;&amp; nums, int k) {\n        int n = nums.size();\n        vector&lt;int&gt; dp(n);\n        dp[0] = nums[0];\n        priority_queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.emplace(nums[0], 0);\n        for (int i = 1; i &lt; n; ++i) {\n            while (i - q.top().second &gt; k) {\n                q.pop();\n            }\n            dp[i] = q.top().first + nums[i];\n            q.emplace(dp[i], i);\n        }\n        return dp[n - 1];\n    }\n};\n</code></pre>\n",
            "tags": [
                "队列",
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/20c47d09/",
            "url": "http://dpm12345.cn/posts/20c47d09/",
            "title": "快速幂",
            "date_published": "2021-12-05T02:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcG93eC1uLw==\">快速幂</span></p>\n<p>题目详情：实现 Pow (x,n)</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>思路：要实现$Pow(x,n)$，显然不可能用for或while循环进行一个一个$x$相乘，这样时间相对较长，那么可以做以下简化，若要求$x^n$，当n为奇数时，那么$x^n$就等于$x^{\\frac{n}{2}}$次方的的平方再乘一个$x$；当n为偶数时，$x^n$等于$x^{\\frac{n}{2}}$的平方，以此类推，递归方程就可写出以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    double quickMul(double x, long long N) {\n        if (N == 0) {\n            return 1.0;\n        }\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    }\n\n    double myPow(double x, int n) {\n        long long N = n;\n        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n};\n</code></pre>\n<p>注意：代码中递归结束条件为<code>N==0</code>，而不是<code>N==1</code>；原因为考虑一开始<code>N==0</code>的情况</p>\n<h1 id=\"迭代优化\"><a href=\"#迭代优化\" class=\"headerlink\" title=\"迭代优化\"></a>迭代优化</h1><p>在递归方法中，我们是通过倒序来进行判断什么时候乘x，什么时候不乘x的，而要实现迭代优化，那么必然要正序遍历，所以现在的目的便是要找到怎样正序遍历的方法。</p>\n<p>我们再仔细想一下第一种确定乘x和不乘x的方法，是偶数不乘，是奇数则乘x，倒序遍历，或许这样说还不够明白，那么换一种说法，偶数乘x的零次方(和不乘结果相同), 而奇数乘x的1次方，倒序排列，换成这样的说法，我们很容易得到，这便是n的二进制形式，它的二进制的每一位表示着乘x的权，而每次计算时又会平方，那么也就是幂的二进制乘2，若偶数末尾即零，奇数末尾即1，如此继续下去，最后得到的值便为$x^n$的值，因此这样便可得到迭代优化后的程序</p>\n<p>代码如下:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    double myPow(double x, int n) {\n        double ans=1;\n        int flag=n;\n        double xc=x;         // 记录每一位如果为 1 应乘的 x 次方\n        while(n!=0)\n        {\n            if(n%2)\n                ans*=xc;\n            xc=xc*xc;               // 每进一位则平方一次 xc\n            n/=2;\n        }\n        return flag&gt;0?ans:1.0/ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "递归"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/47ade4a0/",
            "url": "http://dpm12345.cn/posts/47ade4a0/",
            "title": "爬楼梯与零钱兑换题目对比",
            "date_published": "2021-12-02T06:54:40.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==\">爬楼梯</span></p>\n<p><img data-src=\"/../../../post_images/%E7%88%AC%E6%A5%BC%E6%A2%AF.png\"></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2UtMi8=\">零钱兑换 II</span></p>\n<p><img data-src=\"/../../../post_images/%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.png\"></p>\n<p>建立在做过题目的基础上，我们重新审视这几道题</p>\n<ol>\n<li><p>对于爬楼梯，由于一次只能爬一阶或两阶，故$dp[i]=dp[i-1]+dp[i-2]$<br>对于零钱兑换II，其限制因素为零钱的面额，故当$i&gt;=coin[j]$时，$dp[i]+=dp[i-coin[j]]$</p>\n<p>而现在我们将爬楼梯的限制由由只有一阶或两阶，改为一个数组$step[]={1,2}$；那么在做时，便要遍历一次$step [j]$, 当$i&gt;=step[j]$时，$dp[i]=dp[i]+dp[i-step[j]]$, 而$step[j]$便与前面的减去 1、2 相同。这样不难发现，如果将每次能跨越的楼梯阶数改为一个数组里的元素，那么爬楼梯与零钱兑换II的解题代码就十分相似了</p>\n</li>\n<li><p>接下来进行更深一层的讨论</p>\n<p>在爬楼梯题目中，我们要计算的是到达顶端的总数，每次只能一阶或两阶，由此可知，其为 若干个1和2排列，其对顺序有要求，也就是说，最后得到是排列数的结果</p>\n<p>而在零钱兑换II题目中，因为只是记录兑换一个金额的总数，先取小面额还是先取大面额是没有区别的，那么也就是说，该题求的是组合数。</p>\n<p>那么，该用什么方法区别这两种呢？</p>\n<p>下面给出两段代码</p>\n</li>\n</ol>\n<pre><code class=\"cpp\">//  amount 表示金额，n 表示硬币面额数，coin [i] 表示某个硬币\n    \n    // 第一段\n    for(int i=1;i&lt;=amount;i++)\n    {\n       for(int j=0;j&lt;n;j++)\n          {\n              if(i&gt;=coin[j])\n              {\n                  dp[i]+=dp[i-coin[j]];\n              }\n          }\n    }\n    \n    \n    // 第二段\n    for(int i=0;i&lt;n;i++)\n    {\n       for(int j=1;j&lt;=amount;j++)\n          {\n              if(j&gt;=coin[i])\n              {\n                  dp[j]+=dp[j-coin[i]];\n              }\n          }\n    }\n</code></pre>\n<p>经过代码观察，不难看出，第一段代码先枚举金额，然后嵌套<code>coin</code>硬币的循环； 第二段代码先枚举<code>coin</code>硬币面额，然后再枚举金额</p>\n<ol>\n<li><p>先看第一段代码：先枚举金额，再枚举硬币面额，也就是说每一个金额的<code>dp</code>计算都会涉及到每一种硬币,当$i&gt;=coin[j]$,意味着$i-coin[j]$后可以添加一个硬币元素$coin[j]$等于$i$,所以$dp[i]=dp[i]+dp[i-coin[j]]$,那么不难得出比如计算金额$3$时，如果硬币面额存在$1$和$2$，那么$dp[1]$和$dp[2]$的值都会加到$dp[3]$上，也,就是说首先$dp[3]+=dp[2]$,即$2，1$情况，然后$dp[3]+=dp[1]$,即$1，2$情况。很明显，”1,2”、”2,1”都计算的为排列数。</p>\n</li>\n<li><p>再看第二段代码：先枚举硬币面额，再枚举金额，也就是说每一个硬币面额都会在一种金额内计算一次，再根据循环的方式，从下标零开始遍历，知道结束，那么不难得出，$coin[i]$的值在$dp[i]$的每一种情况中，出现的顺序都是固定的，那么与上面分析相比，”1,2”、”2,1”只会出现一种，所以第二段代码计算的结果为组合数</p>\n</li>\n</ol>\n<p>下面进行代码实现</p>\n<p>注：为确保爬楼梯代码无误，增加了数组b进行检验，若正确，则应先输出34</p>\n<pre><code class=\"cpp\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nclass Solution{\npublic:\n    int climb_stairs(int amount, vector&lt;int&gt;&amp;step)\n    {\n        vector&lt;int&gt;dp(amount + 1);\n        int n = step.size();\n        dp[0] = 1;\n        for (int i = 1; i &lt;= amount; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (i&gt;=step[j])\n                {\n                    dp[i] += dp[i - step[j]];\n                }\n            }\n        }\n        return dp[amount];\n    }\n    int change(int amount, vector&lt;int&gt;&amp;coin)\n    {\n        vector&lt;int&gt;dp(amount + 1);\n        int n = coin.size();\n        dp[0] = 1;   // 表示金额为零的情况，\n                     // 因为零钱面额也为零，故 dp [0]=1\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 1; j &lt;=amount; j++)\n            {\n                if (j&gt;=coin[i])\n                {\n                    dp[j] += dp[j - coin[i]];\n                }\n            }\n        }\n        return dp[amount];\n    }\n};\n\nint main()\n{\n    int amount = 8;\n    vector&lt;int&gt;a(3);\n    a[0] = 1; a[1] = 2; a[2] = 5;\n    vector&lt;int&gt;b(2);\n    b[0] = 1; b[1] = 2;\n    Solution A;\n    cout &lt;&lt; A.climb_stairs(amount, b) &lt;&lt; endl;      \n    cout &lt;&lt;A.climb_stairs(amount,a)  &lt;&lt; endl;\n    cout &lt;&lt; A.change(amount,a)&lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p><img data-src=\"/../../../post_images/%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C.png\"></p>\n<p>将8，数组[1,2,5]分别输入leetcode控制器内检验，发现无误</p>\n<p>【2021-12-3 更新】</p>\n<p>类似的题目还有</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLWl2Lw==\">组合总数</span></p>\n<p><img data-src=\"/../../../post_images/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0IV.png\"></p>\n<p>方法类似，但需要注意题目要求不能超过32位整数范围，需添加限制，如图</p>\n<p><img data-src=\"/../../../post_images/%E5%8C%BA%E5%88%AB.png\"></p>\n",
            "tags": [
                "排列组合"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/308e5841/",
            "url": "http://dpm12345.cn/posts/308e5841/",
            "title": "有效的括号",
            "date_published": "2021-11-29T12:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LTJkLWltbXV0YWJsZS8=\">二维区域和检索 - 矩阵不可变</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/304%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98.jpg\"></p>\n<p>思路：该题考查了矩形的相关知识，同时涉及到前缀和。那么必须知道矩形的前缀和如何求。这里给出两种解法：</p>\n<ol>\n<li><p>以$sum [i][j+1]$表示$matrix$第$i$行从下标$0$到下标为$j$元素的和,那么计算左上端点为$[row1,col1]$, 右下端点为$[row2,col2]$的矩形区域内元素总和，就可以将每一行每一行加起来代码形式为$sum [i][col2+1]-sum [i][col1+1]$</p>\n</li>\n<li><p>以$sum [i][j]$表示以$[0,0]$为左上端点，$[i,j]$为右上端点的矩形区域内元素总和,那么计算左上端点为$[row1,col1]$, 右下端点为$[row2,col2]$的矩形区域内元素总和时<br> 可试着画图</p>\n</li>\n</ol>\n  <img data-src=\"../../../post_images/二维数组前缀和第二种解法.jpg\" style=\"zoom:50%;\">\n\n\n\n<p>那么由此可以推得解法代码为：<br>$$<br>sum[row2][col2]-sum[row2][col1-1]-sum[row1-1][col2]+sum[row1-1][col-1]<br>$$<br>但为了防止$col1-1$,$row1-1$越界，在创建数组时可以顺便将其行列各增加一行，排除越界情况具体代码只需下标加一即可</p>\n<p>以下为代码</p>\n<h1 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h1><pre><code class=\"cpp\">class NumMatrix {\npublic:\n    vector&lt;vector&lt;int&gt;&gt;sum;\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m=matrix.size();\n        if(m&gt;0)\n        {\n            sum.resize(m,vector&lt;int&gt;(matrix[0].size()+1));\n            for(int i=0;i&lt;m;i++)\n            {\n                for(int j=0;j&lt;matrix[0].size();j++)\n                {\n                    sum[i][j+1]=sum[i][j]+matrix[i][j];\n                }\n            }\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        int ans=0;\n        for(int i=row1;i&lt;=row2;i++)\n        {\n            ans+=sum[i][col2+1]-sum[i][col1];\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h1><pre><code class=\"cpp\">class NumMatrix {\npublic:\n    vector&lt;vector&lt;int&gt;&gt;sum;\n    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m=matrix.size();\n        if(m&gt;0)\n        {\n            int n=matrix[0].size();\n            sum.resize(m+1,vector&lt;int&gt;(n+1));\n            for(int i=1;i&lt;m+1;i++)\n            {\n                for(int j=1;j&lt;n+1;j++)\n                {\n                    sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+matrix[i-1][j-1];\n                }\n            }\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return sum[row2+1][col2+1]-sum[row2+1][col1]-sum[row1][col2+1]+sum[row1][col1];\n\n    }\n};\n</code></pre>\n",
            "tags": [
                "矩阵"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/308e5841/",
            "url": "http://dpm12345.cn/posts/308e5841/",
            "title": "有效的括号",
            "date_published": "2021-11-28T13:54:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv\">有效的括号</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<p>思路：因为相同括号只能连续出现，那么我们可以利用栈的特性，当找到一个左括号时，压入栈；当找到一个右括号时，判断栈顶是不是与其相配对的括号，若不是，则返回<code>false</code>，是则去除栈顶元素，到最后，因为有一直压入栈顶的情况，故不能直接<code>return true</code>，而是可以返回<code>empty()</code></p>\n<p>代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool isValid(string s) {\n        if(s.length()&lt;2)return false;\n        unordered_map&lt;char,char&gt;dict={\n            {')', '('},\n            {']', '['},\n            {'}', '{'}\n        };\n        stack&lt;char&gt;a;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(dict.count(s[i]))\n            {\n                if(a.empty()||a.top()!=dict[s[i]])\n                return false;\n                a.pop();\n            }\n            else \n                a.push(s[i]);\n        }\n        return a.empty();\n    }\n};\n</code></pre>\n",
            "tags": [
                "栈"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/b115b06a/",
            "url": "http://dpm12345.cn/posts/b115b06a/",
            "title": "加油站",
            "date_published": "2021-11-27T06:20:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi8=\">加油站</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E5%8A%A0%E6%B2%B9%E7%AB%99_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<p>算法思路：贪心算法</p>\n<h1 id=\"pos-数组记录每个位置的剩余油量\"><a href=\"#pos-数组记录每个位置的剩余油量\" class=\"headerlink\" title=\"pos 数组记录每个位置的剩余油量\"></a>pos 数组记录每个位置的剩余油量</h1><ol>\n<li><p>使用另一个数组$pos$，其中$pos[i]=gas[i]-cost[i]$, 从下标$0$开始遍历，若$pos[i]&lt;0$, 则必不以此为起点；若 $pos[i]&gt;=0$, 则以其为起点，</p>\n<p> 用$res$存储当前剩余油量，之后以此为起点遍历之后位置$n$，若$pos[n]+res&lt;0$, 此起点不满足题意，若 $&gt;=0$, 则更新$res$，并使</p>\n<p> $n=(n+1)%pos.size()$，继续遍历若正常结束循环，则可以返回$i$的值</p>\n</li>\n</ol>\n<p>  以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        if(gas.size()==1)return (gas[0]&lt;cost[0])?-1:0;\n        vector&lt;int&gt;pos(gas.size());\n        for(int i=0;i&lt;pos.size();i++)\n        {\n            pos[i]=gas[i]-cost[i];\n        }\n        for(int i=0;i&lt;pos.size();i++)\n        {\n            if(pos[i]&gt;0)\n            {\n                int res=pos[i],n=(i+1)%pos.size();\n                while(n!=i)\n                {\n                    if(pos[n]+res&lt;0)\n                    break;\n                    res+=pos[n];\n                    n=(n+1)%pos.size();\n                }\n                if(n==i)return i;\n            }\n            \n        }\n        return -1;\n    }\n};\n</code></pre>\n<ol start=\"2\">\n<li><p>优化：由上代码，当不满足$pos[n]+res&gt;=0$时，$n$即为以$i$为起点不可能到达的位置，那么这两个位置之间的位置都不可能到达$n$因为以$i$为起点，当它到两者中间位置时，初始油量大于等于零，而从$i$位置到达不了，更别说两者其中位置了由此，可增加一个变量记录每次前进的长度$num$，当以某一起点得不到答案时，使$i=i+num+1$更新$i$，提高效率</p>\n<p>代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) {\n        int n=gas.size();\n        int i=0;\n        while(i&lt;n)\n        {\n            int num=0,total_gas=0,total_cost=0;\n            while(num&lt;n)\n            {\n                int j=(i+num)%n;\n                total_gas+=gas[j];\n                total_cost+=cost[j];\n                if(total_gas&lt;total_cost)\n                break;\n                num++;\n            }\n            if(num==n)return i;\n            else\n            {\n                i=i+num+1;\n            }\n        }\n        return -1;\n\n    }\n};\n</code></pre>\n</li>\n</ol>\n",
            "tags": [
                "贪心"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/ccc6bc8a/",
            "url": "http://dpm12345.cn/posts/ccc6bc8a/",
            "title": "下降路径最小和",
            "date_published": "2021-11-26T07:20:40.000Z",
            "content_html": "<p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1mYWxsaW5nLXBhdGgtc3VtLw==\">下降路径最小和</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E6%9C%80%E5%B0%8F%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\"></p>\n<p>思路：由题意知，到达某一位置只能有在上一行中与它纵坐标相差1内 的位置到达，那么显然这题使用动态规划 其转移方程在一般情况下，为<br>$$<br>dp[i][j] = {min(dp[i - 1][j], dp[i - 1][j - 1], dp[i - 1][j + 1]} + matrix[i][j];<br>$$<br>而当$i=0$，<br>$$<br>dp[i][j] = matrix[i][j];<br>$$<br>$j=0$<br>$$<br>dp[i][j] = {min(dp[i - 1][j], dp[i - 1][j + 1]} + matrix[i][j];<br>$$<br>$j = n - 1$<br>$$<br>dp[i][j] = {min(dp[i - 1][j], dp[i - 1][j - 1]} + matrix[i][j];<br>$$</p>\n<h1 id=\"原始\"><a href=\"#原始\" class=\"headerlink\" title=\"原始\"></a>原始</h1><pre><code class=\"cpp\">class Solution {\npublic:\n    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector&lt;vector&lt;int&gt;&gt;dp(m, vector&lt;int&gt;(n));\n        for (int i = 0; i&lt;m; i++)\n        {\n            for (int j = 0; j&lt;n; j++)\n            {\n                if (i == 0)\n                {\n                    dp[i][j] = matrix[i][j];\n                }\n                else if (j == 0)\n                {\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + matrix[i][j];\n                }\n                else if (j == n - 1)\n                {\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j];\n                }\n                else\n                {\n                    dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i - 1][j + 1])) + matrix[i][j];\n                }\n            }\n        }\n        return *min_element(dp[m - 1].begin(), dp[m - 1].end());\n\n    }\n};\n</code></pre>\n<h1 id=\"空间优化\"><a href=\"#空间优化\" class=\"headerlink\" title=\"空间优化\"></a>空间优化</h1><p>使用一个一维数组</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        vector&lt;int&gt;dp(n + 2);              // 确保每个位置都是 min {dp [i-1],dp [i],dp [i+1]};\n        int last;                        //last 记录上一个变换的 dp [i];\n        for (int i = 0; i&lt;m; i++)\n        {\n            dp[0] = dp[n + 1] = INT_MAX;\n            last = dp[0];\n            for (int j = 0; j&lt;n; j++)\n            {\n                int temp = dp[j + 1];\n                dp[j + 1] = min(last, min(dp[j + 1], dp[j + 2])) + matrix[i][j];             \n                // 由于把原来数组增加了两个位置，\n                // 所以记录 dp 时只需更新下标 1~n+1 的 dp 值\n                last = temp;\n            }\n        }\n        return *min_element(dp.begin(), dp.end());\n\n    }\n};\n</code></pre>\n",
            "tags": [
                "动态规划"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/723dcd0c/",
            "url": "http://dpm12345.cn/posts/723dcd0c/",
            "title": "摆动序列",
            "date_published": "2021-11-26T02:20:40.000Z",
            "content_html": "<p>[题目链接:]{.orange}<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2lnZ2xlLXN1YnNlcXVlbmNlLw==\">摆动序列</span></p>\n<p>[题目详情:]{.orange}</p>\n<p><img data-src=\"/../../../post_images/%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.jpg\" alt=\"摆动序列_题目详情\"></p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"原始\"><a href=\"#原始\" class=\"headerlink\" title=\"原始\"></a>原始</h2><p>思路：关键点在于，当增添一个数成为摆动序列中的一个元素时，那么这个数要么小于，要么大于其前面的一个数 其大于或小于取决于前面一个数与再前面一个数之间的大小关系 就此，可利用动态规划的思想，分别用$up[i]$,$down[i]$记录前$i+1$个数的最长摆动序列。(其中$up[i]$记录末尾为上升的，$down[i]$记录下降的)     </p>\n<p>将题目解决方法转换为三方面：   </p>\n<ol>\n<li><p>当$nums[i]&lt;nums[i-1]$时，该元素不可添加到$up[i]$中，而对于$down[i]$，取$down[i-1]$(不加上该数),$up[i-1]+1$(加上该数)中的最大值，即<br>$$<br>down[i] = max{up[i-1]+1, down[i-1]}<br>$$</p>\n</li>\n<li><p>当$nums[i]&gt;nums[i-1]$时，该元素不可添加到$down[i]$中,而对于$up[i]$,取$up[i-1]$(不加上该数),$down[i-1]+1$(加上该数)中的最大值，即<br>$$<br>up[i] = max{up[i-1], down[i-1]+1}<br>$$</p>\n</li>\n<li><p>当$nums[i]=nums[i-1]$时，都不能加上,故<br>$$<br>up[i]=up[i-1]<br>$$</p>\n<p>$$<br>dowm[i]=down[i-1]<br>$$</p>\n</li>\n</ol>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n == 1) return n;\n        vector&lt;int&gt;up(n), down(n);\n        up[0] = down[0] = 1;\n        for (int i = 1; i&lt;n; i++)\n        {\n            if (nums[i]&lt;nums[i - 1])\n            {\n                up[i] = up[i - 1];\n                down[i] = max(down[i - 1], up[i - 1] + 1);\n            }\n            else if (nums[i]&gt;nums[i - 1])\n            {\n                up[i] = max(up[i - 1], down[i - 1] + 1);\n                down[i] = down[i - 1];\n            }\n            else\n            {\n                up[i] = up[i - 1];\n                down[i] = down[i - 1];\n            }\n        }\n        return max(up[n - 1], down[n - 1]);\n    }\n};\n</code></pre>\n<h3 id=\"动态规划的空间优化\"><a href=\"#动态规划的空间优化\" class=\"headerlink\" title=\"动态规划的空间优化\"></a>动态规划的空间优化</h3><p>由于$up[i]$,$down[i]$只与下标为$i-1$的值有关，那么可以用两个变量代替数组，最后取这两个变量的最大值</p>\n<p>优化代码如下:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n == 1) return n;\n        int up = 1, down = 1;\n        for (int i = 1; i&lt;n; i++)\n        {\n            if (nums[i]&lt;nums[i - 1])\n            {\n                down = max(down, up + 1);\n            }\n            else if (nums[i]&gt;nums[i - 1])\n            {\n                up = max(up, down + 1);\n            }\n        }\n        return max(up, down);\n    }\n};\n</code></pre>\n<h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><p>代码如下:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        if (n &lt; 2) {\n            return n;\n        }\n        int prevdiff = nums[1] - nums[0];\n        int num = prevdiff != 0 ? 2 : 1;\n        for (int i = 2; i &lt; n; i++) {\n            int diff = nums[i] - nums[i - 1];\n            if ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) {\n                num++;\n                prevdiff = diff;\n            }\n        }\n        return num;\n    }\n};\n</code></pre>\n<p>一开始本身的疑点：其代码行只要有<code>(diff&gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)</code>情况出现，则<code>num++</code>,<br>不会导致因为所选数不是最佳方案而造成答案错误吗？<br>// 经过思考：正因为代码段</p>\n<pre><code class=\"cpp\">int diff = nums[i] - nums[i - 1];\nif ((diff &gt; 0 &amp;&amp; prevdiff &lt;= 0) || (diff &lt; 0 &amp;&amp; prevdiff &gt;= 0)) {\n    num++;\n    prevdiff = diff;\n}\n</code></pre>\n<p>每次都会更新diff的值，也就是说每次都会更新“峰”或“谷”的值，从而使得为最佳方案</p>\n",
            "tags": [
                "动态规划",
                "贪心"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/80d626cb/",
            "url": "http://dpm12345.cn/posts/80d626cb/",
            "title": "等差数列划分",
            "date_published": "2021-11-22T07:20:40.000Z",
            "content_html": "<p>[题目链接:]{.orange}<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYXJpdGhtZXRpYy1zbGljZXMv\">等差数列划分</span></p>\n<p>[题目详情]{.orange}</p>\n<p><img data-src=\"/../../../post_images/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\"></p>\n<p>[【思想】数学方法 ]{.blue}</p>\n<p>[主要在于明白，数列从长度3开始，每增加一个元素，其个数从2开始加，一次加2，3，4…]{.blue}</p>\n<p>[代码如下]{.orange}</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) {\n        if (nums.size()&lt;3)return 0;\n        int count = 1, ans = 0;\n        for (int i = 1; i&lt;nums.size() - 1; i++)\n        {\n            if (nums[i] * 2 == nums[i - 1] + nums[i + 1])\n                ans += count++;\n            else count = 1;\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": [
                "等差数列"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/6ba8ad80/",
            "url": "http://dpm12345.cn/posts/6ba8ad80/",
            "title": "整数拆分",
            "date_published": "2021-11-21T07:54:40.000Z",
            "content_html": "<p>[题目链接:]{.orange}<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW50ZWdlci1icmVhay8=\">整数拆分</span></p>\n<p>[题目详情]{.orange}</p>\n<p><img data-src=\"/../../../post_images/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"整数拆分_1\"></p>\n<p>[数学方法可以证明乘积最大时，因子最终都可以分解为若干个3和若干个2，且3的个数尽可能多]{.blue}</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int integerBreak(int n) {\n        if (n == 2)return 1;\n        if (n == 3)return 2;\n        int num_3 = n / 3, num_2 = (n % 3) / 2;\n        if (n % 3 == 1)\n        {\n            num_3--;\n            num_2 += 2;\n        }\n        return pow(3, num_3)*pow(2, num_2);\n    }\n};\n</code></pre>\n",
            "tags": [
                "滑动窗口",
                "哈希表",
                "字符串"
            ]
        }
    ]
}