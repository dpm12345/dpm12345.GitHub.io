{
    "version": "https://jsonfeed.org/version/1",
    "title": "dpm12345 • All posts by \"leetcode周赛\" category",
    "description": "学习记录",
    "home_page_url": "http://dpm12345.cn",
    "items": [
        {
            "id": "http://dpm12345.cn/posts/274338ea/",
            "url": "http://dpm12345.cn/posts/274338ea/",
            "title": "leetcode 第 68 场双周赛",
            "date_published": "2021-12-28T15:20:34.000Z",
            "content_html": "<p>【战绩】</p>\n<p><img data-src=\"/../../../post_images/leetcode%E7%AC%AC68%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B_%E6%88%98%E7%BB%A9.png\"></p>\n<p>总结:</p>\n<p>此次双周赛的成绩，看排名似乎还行，但事实上只在限定时间内做出了第一题，可以说是不太好。总的来说是，接触过的题目太少，知识储备不够造成的，因此之后的策略是涉及多方面的题目、知识与解法</p>\n<p>总结到此，下面是题目解析</p>\n<h1 id=\"句子中的最多单词数\"><a href=\"#句子中的最多单词数\" class=\"headerlink\" title=\"句子中的最多单词数\"></a>句子中的最多单词数</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1udW1iZXItb2Ytd29yZHMtZm91bmQtaW4tc2VudGVuY2VzLw==\">句子中的最多单词数</span></p>\n<p>这题非常简单，计算空格数即可</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int mostWordsFound(vector&lt;string&gt;&amp; sentences) {\n        int ans=0;\n        for(int i=0;i&lt;sentences.size();i++)\n        {\n            int cur=0;\n            for(int j=0;j&lt;sentences[i].size();j++)\n            {\n                if(sentences[i][j]==' ')\n                    cur++;\n            }\n            ans=max(ans,cur+1);\n        }\n        return ans;\n        \n    }\n};\n</code></pre>\n<h1 id=\"从给定原材料中找到所有可以做出的菜\"><a href=\"#从给定原材料中找到所有可以做出的菜\" class=\"headerlink\" title=\"从给定原材料中找到所有可以做出的菜\"></a>从给定原材料中找到所有可以做出的菜</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1hbGwtcG9zc2libGUtcmVjaXBlcy1mcm9tLWdpdmVuLXN1cHBsaWVzLw==\"> 从给定原材料中找到所有可以做出的菜</span></p>\n<h2 id=\"暴力法\"><a href=\"#暴力法\" class=\"headerlink\" title=\"暴力法\"></a>暴力法</h2><p>根据题目要求，做好的菜可以作为原材料去做其他的菜，那么想法可以是先遍历一遍，如果发现有菜可以做出来，那么将该菜放入存有材料的哈希表中，重新开始循环，并且避免对已经做出来的菜重复计算，那么循环结束后便得到一个完整原材料的哈希表。最后再遍历一次食谱，得到的结果便是答案。</p>\n<p>以下为我自己写的代码 (原以为在周赛时间限制内，但是实际已经过了)</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    void tj(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies,unordered_map&lt;string,int&gt;&amp;a)\n    {\n        int flag=1;       // 判断是否已经是否把所有情况遍历\n        while(flag)\n        {\n            flag=0;      // 假设可以结束了\n            for(int i=0;i&lt;recipes.size();i++)\n            {\n                int j;\n                for(j=0;j&lt;ingredients[i].size();j++)\n                {\n                    if(!a.count(recipes[i])&amp;&amp;!a.count(ingredients[i][j]))   // 发现此菜品不能做出来\n                        break;\n                }\n                \n                // 发现菜品没有统计过并且可以做出来，j==ingredients [i].size () 说明原材料都有\n                if(!a.count(recipes[i])&amp;&amp;j==ingredients[i].size())    \n                {\n                    a[recipes[i]]=1;\n                    flag=1;         // 说明有新材料加入，那么重新遍历菜谱\n                    break;\n                }\n            }\n        }\n    }\n    vector&lt;string&gt; findAllRecipes(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies) {\n        unordered_map&lt;string,int&gt;a;\n        vector&lt;string&gt;ans; \n        for(int i=0;i&lt;supplies.size();i++)\n        {\n            a[supplies[i]]=1;         // 原材料放入哈希表\n        }\n        tj(recipes,ingredients,supplies,a);         // 统计新的原材料哈希表\n        for(int i=0;i&lt;recipes.size();i++)\n        {\n            int j;\n            for(j=0;j&lt;ingredients[i].size();j++)\n            {\n                if(!a.count(ingredients[i][j]))\n                        break;\n            }\n            if(j==ingredients[i].size())\n            {\n                ans.push_back(recipes[i]);     // 将满足的菜品放入 ans 中\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;string&gt; findAllRecipes(vector&lt;string&gt;&amp; recipes, vector&lt;vector&lt;string&gt;&gt;&amp; ingredients, vector&lt;string&gt;&amp; supplies) {\n        int n = recipes.size();\n        // 图\n        unordered_map&lt;string, vector&lt;string&gt;&gt; depend;\n        // 入度统计\n        unordered_map&lt;string, int&gt; cnt;\n        for (int i = 0; i &lt; n; ++i) {\n            for (const string&amp; ing: ingredients[i]) {\n                depend[ing].push_back(recipes[i]);\n            }\n            cnt[recipes[i]] = ingredients[i].size();\n        }\n        \n        vector&lt;string&gt; ans;\n        queue&lt;string&gt; q;\n        // 把初始的原材料放入队列\n        for (const string&amp; sup: supplies) {\n            q.push(sup);\n        }\n        // 拓扑排序\n        while (!q.empty()) {\n            string cur = q.front();\n            q.pop();\n            if (depend.count(cur)) {\n                for (const string&amp; rec: depend[cur]) {\n                    --cnt[rec];\n                    // 如果入度变为 0，说明可以做出这道菜\n                    if (cnt[rec] == 0) {\n                        ans.push_back(rec);\n                        q.push(rec);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"判断一个括号字符串是否有效\"><a href=\"#判断一个括号字符串是否有效\" class=\"headerlink\" title=\"判断一个括号字符串是否有效\"></a>判断一个括号字符串是否有效</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY2hlY2staWYtYS1wYXJlbnRoZXNlcy1zdHJpbmctY2FuLWJlLXZhbGlkLw==\">判断一个括号字符串是否有效</span></p>\n<h2 id=\"两次遍历，正序遍历和逆序遍历。\"><a href=\"#两次遍历，正序遍历和逆序遍历。\" class=\"headerlink\" title=\"两次遍历，正序遍历和逆序遍历。\"></a>两次遍历，正序遍历和逆序遍历。</h2><p>首先排除奇数个数的情况，因为括号数为奇数时必不可能两两配对</p>\n<p>正序遍历时，用count记录此时不可修改的右括号数，在遍历时时候比对当前数目的右括号数与剩下的最多左括号数，如果后者小于前者，那么不可能经过改变得到有效的括号字符串</p>\n<p>逆序遍历时，同正序遍历时的方法，用count记录此时不可修改左括号数，在遍历时时候比对当前数目的右括号数与剩下的最多左括号数，如果后者小于前者，那么不可能经过改变得到有效的括号字符串</p>\n<p>两次遍历结束后若都不会返回false，那么说明肯定存在一种情况使得左括号与右括号恰好两两配对</p>\n<p>因为一个是$L&gt;=R$另一个是$L&lt;=R$，如果两种都满足则会有相等使其配对的情况，所以最后能得到正确结果</p>\n<p>以下为参考代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        if(s.size()%2==1) return false;\n        int l=0,r=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(locked[i]=='1'&amp;&amp;s[i]==')')\n                r++;\n            if(i+1-r&lt;r)                  // 最大左括号数小于右括号数\n                return false;\n        }\n        for(int i=s.size()-1;i&gt;=0;i--)\n        {\n            if(locked[i]=='1'&amp;&amp;s[i]=='(')\n                l++;\n            if(s.size()-i-l&lt;l)           // 最大右括号数小于左括号数\n                return false;\n        }\n        return true;\n    }\n};\n</code></pre>\n<h2 id=\"贪心算法：一次遍历，用-maxc-记录最大未匹配数，minc-记录最小未匹配数\"><a href=\"#贪心算法：一次遍历，用-maxc-记录最大未匹配数，minc-记录最小未匹配数\" class=\"headerlink\" title=\"贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数\"></a>贪心算法：一次遍历，用 maxc 记录最大未匹配数，minc 记录最小未匹配数</h2><p>首先排除奇数个数的情况，因为括号数为奇数时必不可能两两配对</p>\n<p>当遇到不可变的右(左)括号时，<code>maxc</code>和<code>minc</code>都加一(减一), 如果在此期间<code>maxc&lt;0</code>，那么证明有右括号不能被匹配那么这串字符串是无效的</p>\n<p>当遇到可变的位置时，由于既可以变也可以不变，那么<code>maxcpp</code>，<code>minc−−</code>，其中如果<code>minc</code>减之前如果是0，那么<code>minc</code>就变为1，因为会增加</p>\n<p>如果在遍历过程中，<code>minc&gt;maxc</code>，那么证明该串是无效的</p>\n<p>最后如果该串是有效，那么<code>minc</code>必为0，所以返回值为<code>minc==0</code></p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        if(s.size()%2==1)  return false;\n        int minc=0,maxc=0;\n        for(int i=0;i&lt;s.size();i++)\n        {\n            if(locked[i]=='1')\n            {\n                if(s[i]=='(')\n                {\n                    mincpp;\n                    maxcpp;\n                }\n                if(s[i]==')')\n                {\n                    maxc--;\n                    minc=minc==0?1:minc-1;\n                    if(maxc&lt;0)\n                        return false;\n                }\n            }\n            else\n            {\n                minc=minc==0?1:minc-1;\n                maxcpp;\n            }\n            if(minc&gt;maxc)\n                return false;\n        }\n        return minc==0;\n    }\n};\n</code></pre>\n<h1 id=\"一个区间内所有数乘积的缩写\"><a href=\"#一个区间内所有数乘积的缩写\" class=\"headerlink\" title=\"一个区间内所有数乘积的缩写\"></a>一个区间内所有数乘积的缩写</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWJicmV2aWF0aW5nLXRoZS1wcm9kdWN0LW9mLWEtcmFuZ2Uv\">一个区间内所有数乘积的缩写</span></p>\n<p>目前学习中……</p>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.cn/posts/80d31d12/",
            "url": "http://dpm12345.cn/posts/80d31d12/",
            "title": "leetcode 第 273 场周赛",
            "date_published": "2021-12-28T15:20:34.000Z",
            "content_html": "<p>【战绩】</p>\n<p><img data-src=\"/../../../post_images/leetcode%E7%AC%AC273%E5%9C%BA%E5%91%A8%E8%B5%9B_%E6%88%98%E7%BB%A9.png\" alt=\"leetcode第273场周赛_战绩\"></p>\n<p>总结:</p>\n<p>此次周赛，成绩差，只做出来了两题，并且第一题还提交错误一次。总的来说题目看得不够清楚，对题目的 推导还比较欠缺</p>\n<p>总结到此，下面是题目解析</p>\n<h1 id=\"反转两次的数字\"><a href=\"#反转两次的数字\" class=\"headerlink\" title=\"反转两次的数字\"></a>反转两次的数字</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYS1udW1iZXItYWZ0ZXItYS1kb3VibGUtcmV2ZXJzYWwv\">反转两次的数字</span></p>\n<p>这道题比较简单，可以直接暴力进行两次数字反转得到答案</p>\n<p>但仔细想想会发现，如果一个数字反转两次后是元素，那么原数字末尾必不为0(0除外) ，因为如果存在0时 在进行反转后0会被删去，数字总位数减少，从而再次进行反转得到的数字必然不会是原来的数字</p>\n<p>以下为代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool isSameAfterReversals(int num) {\n        return num==0||num%10!=0;\n    }\n};\n</code></pre>\n<h1 id=\"执行所有后缀指令\"><a href=\"#执行所有后缀指令\" class=\"headerlink\" title=\"执行所有后缀指令\"></a>执行所有后缀指令</h1><p>题目链接:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXhlY3V0aW9uLW9mLWFsbC1zdWZmaXgtaW5zdHJ1Y3Rpb25zLXN0YXlpbmctaW4tYS1ncmlkLw==\">执行所有后缀指令</span></p>\n<p>按照题目要求模拟即可，注意什么时候是行，什么时候是列即可</p>\n<p>代码如下</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    vector&lt;int&gt; executeInstructions(int n, vector&lt;int&gt;&amp; startPos, string s) {\n        vector&lt;int&gt;ans(s.size());\n        for(int i=0;i&lt;s.size();i++)\n        {\n            int j=0,num=0;\n            vector&lt;int&gt;cur=startPos;\n            for(j=i;j&lt;s.size();j++)\n            {\n                if(s[j]=='L'&amp;&amp;cur[1]&gt;0)\n                {\n                    cur[1]--;\n                    num++;\n                }\n                else if(s[j]=='R'&amp;&amp;cur[1]&lt;n-1)\n                {\n                    cur[1]++;\n                    num++;\n                }\n                else if(s[j]=='U'&amp;&amp;cur[0]&gt;0)\n                {\n                    cur[0]--;\n                    num++;\n                }   \n                else if(s[j]=='D'&amp;&amp;cur[0]&lt;n-1)\n                {\n                    cur[0]++;\n                    num++;\n                }\n                else\n                    break;\n            }\n            ans[i]=num;\n            \n        }\n        return ans;\n        \n    }\n};\n</code></pre>\n<h1 id=\"相同元素的间隔之和\"><a href=\"#相同元素的间隔之和\" class=\"headerlink\" title=\"相同元素的间隔之和\"></a>相同元素的间隔之和</h1>",
            "tags": []
        },
        {
            "id": "http://dpm12345.cn/posts/415dc2d2/",
            "url": "http://dpm12345.cn/posts/415dc2d2/",
            "title": "leetcode 第 272 场周赛",
            "date_published": "2021-12-19T15:20:34.000Z",
            "content_html": "<p>【战绩】</p>\n<p><img data-src=\"/../../../post_images/leetcode%E7%AC%AC272%E5%9C%BA%E5%91%A8%E8%B5%9B_%E6%88%98%E7%BB%A9.png\"></p>\n<p>总结:</p>\n<p>第一场按时参与的leetcode 周赛，总的来说，这次的题目并不是很难，思路会有，而自己却写不出来，最主要还是细节方面和一些算法的不熟悉，不能够做到完全吸收，就拿第四题说，我能想到解题方向为先将下</p>\n<p>标间隔为k的元素构成一个个数组，然后求这些数组各自内部的最长非严格上升子序列的长度，最后用数组原长度减去这一最长非严格上升子序列的长度即为这一数组的最少修改值，答案即为所有数组的最少修改值。</p>\n<p>但最后我并没有写出来，更加不好的是，我明白怎么去求最长非严格上升序列的动态规划求法，但脑中并未有其时间复杂度更小的贪心+二分查找解法，为此我还去搜求最长严格递增的贪心+二分查找解法，但自己并</p>\n<p>未理解该算法的核心，也并不知道怎么修改才能作为求最长非严格上升子序列的代码</p>\n<p>总结到此，下面进行题目解析</p>\n<h1 id=\"找出数组中的第一个回文字符串\"><a href=\"#找出数组中的第一个回文字符串\" class=\"headerlink\" title=\"找出数组中的第一个回文字符串\"></a>找出数组中的第一个回文字符串</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1maXJzdC1wYWxpbmRyb21pYy1zdHJpbmctaW4tdGhlLWFycmF5Lw==\">找出数组中的第一个回文字符串</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"找出数组中的第一个回文字符串_题目详情\"></p>\n<p>思路：</p>\n<p>这题比较简单，只需写一个函数用于判断是否为回文串，若是则直接输出，结束程序</p>\n<p>以下为代码：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    bool if_hw(string &amp;s)\n    {\n        for(int i=0;i&lt;s.length()/2;i++)\n        {\n            if(s[i]!=s[s.length()-i-1])\n                return false;\n        }\n        return true;\n    }\n    string firstPalindrome(vector&lt;string&gt;&amp; words) {\n        for(int i=0;i&lt;words.size();i++)\n        {\n            if(if_hw(words[i]))\n                return words[i];\n        }\n        return \"\";\n    }\n};\n</code></pre>\n<p>或者使用迭代器</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    string firstPalindrome(vector&lt;string&gt;&amp; a) {\n        for(string s : a) {\n            if(s == string(s.rbegin(), s.rend())) return s;\n        }\n        return \"\";\n    }\n};\n</code></pre>\n<h1 id=\"向字符串添加空格\"><a href=\"#向字符串添加空格\" class=\"headerlink\" title=\"向字符串添加空格\"></a>向字符串添加空格</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYWRkaW5nLXNwYWNlcy10by1hLXN0cmluZy8=\">向字符串添加空格</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"向字符串添加空格_题目详情\"></p>\n<p>思路:</p>\n<p>这题也比较简单，只需遍历时，在对应位置添上空格即可，可使用if解决</p>\n<p>以下为代码：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    string addSpaces(string s, vector&lt;int&gt;&amp; spaces) {\n        int index=0;\n        string ans;\n        for(int i=0;i&lt;s.length();i++)\n        {\n            if(index&lt;spaces.size()&amp;&amp;i==spaces[index])\n            {\n                ans.push_back(' ');\n                index++;\n            }\n            ans.push_back(s[i]);\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"股票平滑下跌阶段的数目\"><a href=\"#股票平滑下跌阶段的数目\" class=\"headerlink\" title=\"股票平滑下跌阶段的数目\"></a>股票平滑下跌阶段的数目</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLXNtb290aC1kZXNjZW50LXBlcmlvZHMtb2YtYS1zdG9jay8=\">股票平滑下跌阶段的数目</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E8%82%A1%E7%A5%A8%E5%B9%B3%E6%BB%91%E4%B8%8B%E8%B7%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%B0%E7%9B%AE_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"股票平滑下跌阶段的数目_题目详情\"></p>\n<p>思路: </p>\n<p>观察可知，平滑下跌阶段即为公差为<code>-1</code>的等差数列，而要具体求出结果就可以为先求数组中的各个最长等差数列的长度，然后存入，最后只需加上各个等差数列长度的$n+(n-1)+n-1+・・・+1$</p>\n<p>得到答案</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    long long cal(long long n)\n    {\n        long long ans=0;\n        while(n!=0)\n        {\n            ans+=n--;\n        }\n        return ans;\n    }\n    long long getDescentPeriods(vector&lt;int&gt;&amp; prices) {\n        vector&lt;long long&gt;record;\n        long long sum=0;\n        for(int i=0;i&lt;prices.size();i++)\n        {\n            if(sum==0)\n                sum++;\n            else\n            {\n                if(prices[i]==prices[i-1]-1)\n                {\n                    sum++;\n                }\n                else\n                {\n                    record.push_back(sum);\n                    sum=1;\n                }\n            }\n        }\n        if(sum!=0)\n            record.push_back(sum);\n        long long ans=0;\n        for(int i=0;i&lt;record.size();i++)\n        {\n            ans+=cal(record[i]);\n        }\n        return ans;\n    }\n};\n</code></pre>\n<p>大佬的代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    long long getDescentPeriods(vector&lt;int&gt;&amp; a) {\n        long long ans = 0;\n        for(int i = 0; i &lt; a.size(); ) {\n            int j = i;\n            while(j &lt; a.size() &amp;&amp; a[j] - a[i] == i - j) ++j;\n            ans += (long long)(j - i) * (j - i + 1) / 2;\n            i = j;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<p>思路相同，但用来了更为简便的写法<br>相对于我的代码，我的显得过于繁琐，其实无需将个数存入新的数组，而是可以边得到边计算，而计算时用$(j−i)∗(j−i+1)/2$<del>我怎么就忘了呢</del></p>\n<h1 id=\"使数组-K-递增的最少操作次数\"><a href=\"#使数组-K-递增的最少操作次数\" class=\"headerlink\" title=\"使数组 K 递增的最少操作次数\"></a>使数组 K 递增的最少操作次数</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1vcGVyYXRpb25zLXRvLW1ha2UtdGhlLWFycmF5LWstaW5jcmVhc2luZy8=\">使数组 K 递增的最少操作次数</span></p>\n<p>题目详情：</p>\n<p><img data-src=\"/../../../post_images/%E4%BD%BF%E6%95%B0%E7%BB%84K%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%85.png\" alt=\"使数组K递增的最少操作次数_题目详情\"></p>\n<p>思路: 在总结中我差不多讲过，这里简略讲一下</p>\n<p>题目要求求使数组K递增的最少操作次数，我们将相差k下标的元素排列在一起，若想要让其非严格递增，求最少修改数，不难得到此结论，若想在花最少次数得到非严格递增数列，那么该次数一定为该数列里的最长非严格递增子序列的长度与该序列长度的差值</p>\n<p>而求最长非严格递增子序列的长度的方法有两种，一种动态规划，另一种是贪心+二分。 </p>\n<p>在这道题里，因为动态规划时间复杂度较高，很容易超出时间限制，故这题采用贪心+二分</p>\n<p>【相关题目】:<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1pbmNyZWFzaW5nLXN1YnNlcXVlbmNlLw==\">【最长递增子序列】</span></p>\n<p>所以说接下来所要做的事为： </p>\n<ol>\n<li>将下标相差 k 的元素放在一起，构成新的数组 </li>\n<li>求出该数组的最长非严格递增子序列的长度与数组长度的差值</li>\n<li>将各差值相加</li>\n</ol>\n<p>该方法具体原理</p>\n<p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>\n<p>基于上面的贪心思路，我们维护一个数组<code>d[i]</code>，表示长度为<code>i</code>的最长上升子序列的末尾元素的最小值， 用<code>len</code>记录目前最长上升子序列的长度，起始时<code>len</code>为<code>1</code>，<code>d[1]=nums[0]</code>。</p>\n<p>同时我们可以注意到<code>d[i]</code>是关于<code>i</code>单调递增的。因为如果<code>d[j]≥d[i]</code>且<code>j &lt; i</code>，我们考虑从长度为<code>i</code>的最长上升子序列的末尾删除<code>i-j</code>个元素，那么这个序列长度变为<code>j</code>，且第<code>j</code>个元素<code>x</code>（末尾元素）必然小于<code>d[i]</code>，也就小于<code>d[j]</code>。那么我们就找到了一个长度为<code>j</code>的最长上升子序列，并且末尾元素比<code>d[j]</code>小， 从而产生了矛盾。因此数组<code>d</code>的单调性得证。</p>\n<p>我们依次遍历数组<code>nums</code>中的每个元素，并更新数组<code>d</code>和<code>len</code>的值。如果<code>nums [i]&gt;d [len]</code>则更新<code>len = len + 1</code>，否则在<code>d[1…len]</code>中找满足<code>d[i−1] &lt; nums[j] &lt; d[i]</code>的下标<code>i</code>，并更新<code>d[i] = nums[j]</code></p>\n<p>根据d数组的单调性，我们可以使用二分查找寻找下标<code>i</code>，优化时间复杂度。</p>\n<p>最后整个算法流程为：</p>\n<p>设当前已求出的最长上升子序列的长度为<code>len</code>初始时为1），从前往后遍历数组<code>nums</code>，在遍历到<code>nums[i]</code>时：</p>\n<p>如果<code>nums [i]&gt;d [len]</code>，则直接加入到d数组末尾，并更新<code>len = len + 1</code></p>\n<p>否则，在d数组中二分查找，找到第一个比<code>nums[i]</code>小的数<code>d[k]</code>，并更新<code>d[k+1]=nums[i]</code>。 </p>\n<p>以输入序列<code>[0, 8, 4, 12, 2]</code>为例： </p>\n<p>第一步插入0，d = [0];</p>\n<p>第二步插入8，d = [0, 8]; </p>\n<p>第三步插入4，d = [0, 4];</p>\n<p> 第四步插入12，d = [0, 4, 12]; </p>\n<p>第五步插入2，d = [0, 2, 12]; </p>\n<p>最终得到最大递增子序列长度为3。 </p>\n<p>– 摘自 leetcode 官方题解 (最长递增子序列) </p>\n<p>与本题区别： 上面的解析是针对严格递增的，不能有重复元素，而在本题中，是有重复元素，即不严格递增，所以在找寻 插入位置时会有所不同，当发现有数大于等于末位数时，直接接在后面，若小于，那么找出大于这个数的第一个数 </p>\n<p>以下为代码：</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int search(vector&lt;int&gt;&amp;nums)\n    {\n        int n=nums.size();\n        int index=1;\n        vector&lt;int&gt;dp(n+1);\n        dp[index]=nums[0];\n        for(int i=1;i&lt;n;i++)\n        {\n            if(nums[i]&gt;=dp[index])\n            {\n                dp[++index]=nums[i];\n            }\n            else\n            {\n                int left=1,right=index;\n                while(left&lt;=right)\n                {\n                    int mid=(left+right)/2;\n                    if(nums[i]&gt;=dp[mid])\n                    {\n                        left=mid+1;\n                    }\n                    else\n                    {\n                        right=mid-1;\n                    } \n                }\n                dp[left]=nums[i];\n            }\n        }\n        return index;\n    }\n    int kIncreasing(vector&lt;int&gt;&amp; arr, int k) {\n        vector&lt;int&gt;sum(arr.size());\n        for(int i=0;i&lt;k;i++)\n            sum[i]=i;\n        for(int i=k;i&lt;arr.size();i++)\n        {\n            sum[i]=sum[i-k];\n        }\n        vector&lt;vector&lt;int&gt;&gt;record(k,vector&lt;int&gt;(0));\n        for(int i=0;i&lt;arr.size();i++)\n        {\n            record[sum[i]].push_back(arr[i]);\n        }\n        int ans=0;\n        for(int i=0;i&lt;record.size();i++)\n        {\n            ans+=record[i].size()-search(record[i]);\n        }\n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "http://dpm12345.cn/posts/d8bfa4d3/",
            "url": "http://dpm12345.cn/posts/d8bfa4d3/",
            "title": "leetcode 第 271 场周赛",
            "date_published": "2021-12-12T15:20:34.000Z",
            "content_html": "<p>写在前面：这次是自己报名的第一场周赛，但最后忘记了有这一回事了，所以要记得给自己设个闹钟，提醒自己 </p>\n<p>弥补：虽然错过了，但题目不能不做</p>\n<p>以下是之后做的</p>\n<h1 id=\"环和杆\"><a href=\"#环和杆\" class=\"headerlink\" title=\"环和杆\"></a>环和杆</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmluZ3MtYW5kLXJvZHMv\">环和杆</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\"></p>\n<p><img data-src=\"/../../../post_images/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\"></p>\n<p><img data-src=\"/../../../post_images/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%853.png\"></p>\n<p><img data-src=\"/../../../post_images/%E7%90%83%E5%92%8C%E6%9D%86_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%854.png\"></p>\n<p>该题是明显的计数题，记录每一条杆上不同颜色的环的数量，当三种颜色数量都不为零时，总个数加一</p>\n<h2 id=\"解法一\"><a href=\"#解法一\" class=\"headerlink\" title=\"解法一\"></a>解法一</h2><p>利用数组</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int countPoints(string rings) {\n        vector&lt;vector&lt;int&gt;&gt;a(10,vector&lt;int&gt;(3));     // 总共最多有 10 个杆，a [i][0],a [i][1],a [i][2]\n                                                     // 分别记录 R、G、B 的个数\n        for(int i=0;i&lt;rings.length();i+=2)\n        {\n            if(rings[i]=='R')\n            {\n                a[rings[i+1]-48][0]++;\n            }\n            else if(rings[i]=='G')\n            {\n                a[rings[i+1]-48][1]++;\n            }\n            else if(rings[i]=='B')\n            {\n                a[rings[i+1]-48][2]++;\n            }\n        }\n        int ans=0;\n        for(int i=0;i&lt;=9;i++)\n        {\n            if(a[i][0]&amp;&amp;a[i][1]&amp;&amp;a[i][2])     // 当三种杆数量都不为 0 时，ans 加一\n            ans++;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h2 id=\"解法二\"><a href=\"#解法二\" class=\"headerlink\" title=\"解法二\"></a>解法二</h2><p>下面为周赛用时最少的Aoxiang Cui的代码</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int countPoints(string s) {\n        map&lt;char, int&gt; A;\n        A['R'] = 0;\n        A['G'] = 1;\n        A['B'] = 2;\n        vector&lt;int&gt; cnt(10);\n        for (int i = 0; i &lt; (int)s.size(); i += 2) {\n            int x = A[s[i]];\n            int y = s[i + 1] - '0';\n            cnt[y] |= 1 &lt;&lt; x;\n        }\n        int ret = 0;\n        for (int k = 0; k &lt; 10; ++k) {\n            if (cnt[k] == 7) ++ret;\n        }\n        return ret;\n        \n    }\n};\n</code></pre>\n<p>借鉴经验：</p>\n<p>在该题中我的方法中的若找到某个字母，则在对应的数组位置加一，最后需判断三个代表 环的元素是否大于零，需要用<code>if</code>来判断，缺点是单判断的个数变多是，代码则会显得冗长 而在其所用的是二进制的计数法，</p>\n<p>因为二进制的特点为<code>0，1</code>组合，那么这样可以把不同的位看作是一个一个的容器，当存储某个东西时，可将该容器值变为<code>1</code></p>\n<p>该方法中的核心代码便是：</p>\n<pre><code class=\"cpp\">int x = A[s[i]];\nint y = s[i + 1] - '0';\ncnt[y] |= 1 &lt;&lt; x;\n</code></pre>\n<p>这几行代码表示的意思分别为</p>\n<p>第一行：对读到的环进行判断，依据之前的map，找到对应容器</p>\n<p>第二行：对读到的杆编号转化为int类型</p>\n<p>第三行：将该环存入，1&lt;&lt;x 表示的为环所在位置</p>\n<p>那么当所有环都存完后，那么如果三个环都存入，那么<code>cnt[i]</code>的值必然是<code>7</code>，</p>\n<p>因为在该方法中，由map，R、G、B 对应的位置分别为$2^0,2^1,2^2$, 如果都存入，三个</p>\n<p>位置显示都为$1$，那么$cnt[i]=2^0+2^1+2^2=7$</p>\n<p>所以结尾处代码为</p>\n<pre><code class=\"cpp\">for (int k = 0; k &lt; 10; ++k) \n{\n     if (cnt[k] == 7) ++ret;\n}\n</code></pre>\n<h1 id=\"子数组范围和\"><a href=\"#子数组范围和\" class=\"headerlink\" title=\"子数组范围和\"></a>子数组范围和</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3VtLW9mLXN1YmFycmF5LXJhbmdlcy8=\">子数组范围和</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\"></p>\n<p><img data-src=\"/../../../post_images/%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\"></p>\n<p>方法: 滑动窗口 (暴力)</p>\n<p><code>i</code>遍历每一个数组开头，开始增加窗口长度之前，先更新<code>MAX</code>和<code>MIN</code>的值，之后<code>j</code>从<code>i+1</code>开始不断增加 增加的过程中不断更新<code>MAX</code>，<code>MIN</code>的值，更新完后加上最大值减去最小值的值，如此，循环结束后 自然能够得到答案</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    long long subArrayRanges(vector&lt;int&gt;&amp; nums) {\n        long long MAX,MIN,ans=0;\n        for(int i=0;i&lt;nums.size();i++)\n        {\n            MAX=MIN=nums[i];\n            for(int j=i+1;j&lt;nums.size();j++)\n            {\n                MAX=fmax(MAX,nums[j]);\n                MIN=fmin(MIN,nums[j]);\n                ans+=MAX-MIN;      \n            }\n        }\n        return ans;\n    }\n};\n</code></pre>\n<h1 id=\"给植物浇水-II\"><a href=\"#给植物浇水-II\" class=\"headerlink\" title=\"给植物浇水 II\"></a>给植物浇水 II</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvd2F0ZXJpbmctcGxhbnRzLWlpLw==\">给植物浇水 II</span></p>\n<p>题目详情:</p>\n<p><img data-src=\"/../../../post_images/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%851.png\"></p>\n<p><img data-src=\"/../../../post_images/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%852.png\"></p>\n<p><img data-src=\"/../../../post_images/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%853.png\"></p>\n<p><img data-src=\"/../../../post_images/%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4II_%E9%A2%98%E7%9B%AE%E8%AF%A6%E6%83%854.png\"></p>\n<h2 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h2><p>我的思路: 题目中要求求重新灌满水的次数，由题可知，两人浇水过程的位置是对称的， 所以说浇完后两人的次数要么相等要么相差<code>1</code> ，那么每一位置的浇水量必然不大于该人的水罐容量，也就不需要考虑某人浇不了水要等另一个人浇 (这样就明显变为另一个题目了)</p>\n<p>(或许可以有这样的题目: “如果两人分别从两边开始浇水，若可以浇水，则浇，若水量不够则重新灌水，若还是不够，则选择原地等待，等另一个人浇。请返回以下值，若可以全浇完，返回重新灌水次数，若不行，返回-1”)</p>\n<p>接上面思路：</p>\n<p>这样我们可以知道，每个人浇水次数至少是植物数整除2的结果，所以我们可以用循环循环这一次数，结束时，根据提示，<code>plants[i]&gt;0</code>，所以可在浇完水后将浇完水的植物<code>plant[i]</code>赋值<code>0</code>，最后只需判断最中间</p>\n<p>的<code>plants[i]</code>是否为<code>0</code>，若不为<code>0</code>，则还需再浇一次，因此判断两人剩余量的最大值是否可行，不可行则灌水次数加一</p>\n<p>据上面分析，我们所需要的变量为：<code>curA</code>记录Alice剩余水量，<code>curB</code>记录<code>Bob</code>剩余水量，<code>ans</code>记录总灌水次数，<code>time</code>记录最少浇水次数</p>\n<p>以下为代码:</p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int minimumRefill(vector&lt;int&gt;&amp; plants, int capacityA, int capacityB) {\n        int times=plants.size()/2;\n        int curA=capacityA,curB=capacityB;\n        int ans=0;\n        for(int i=0;i&lt;times;i++)\n        {\n            if(curA&gt;=plants[i])\n            {\n                curA-=plants[i];\n                plants[i]=0;\n            }\n            else\n            {\n                ans++;\n                curA=capacityA-plants[i];\n                plants[i]=0;\n            }\n            if(curB&gt;=plants[plants.size()-1-i])\n            {\n                curB-=plants[plants.size()-1-i];\n                plants[plants.size()-1-i]=0;\n            }\n            else\n            {\n                ans++;\n                curB=capacityB-plants[plants.size()-1-i];\n                plants[plants.size()-1-i]=0;\n            }\n        }\n        if(plants[times])\n        {\n            if(max(curA,curB)&lt;plants[times])\n            ans++;\n        }\n        return ans;\n    }\n};\n</code></pre>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int minimumRefill(vector&lt;int&gt;&amp; plants, int capacityA, int capacityB) {\n        int n = plants.size(), ans = 0, a = capacityA, b = capacityB;\n        for (int i = 0, j = n - 1; i &lt; j; ++i, --j) {\n            if (a &lt; plants[i]) a = capacityA, ++ans;\n            a -= plants[i];\n            if (b &lt; plants[j]) b = capacityB, ++ans;\n            b -= plants[j];\n        }\n        if (n &amp; 1 &amp;&amp; max(a, b) &lt; plants[n / 2]) ++ans;\n        return ans;\n    }\n};\n</code></pre>\n<h2 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h2><h1 id=\"摘水果\"><a href=\"#摘水果\" class=\"headerlink\" title=\"摘水果\"></a>摘水果</h1><p>题目链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW11bS1mcnVpdHMtaGFydmVzdGVkLWFmdGVyLWF0LW1vc3Qtay1zdGVwcy8=\">摘水果</span></p>\n<pre><code class=\"cpp\">class Solution {\npublic:\n    int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) {\n        int n = fruits.size();\n        \n        // 前缀和，用于求区间 [l, r] 共有多少水果\n        vector&lt;int&gt; sum;\n        sum.push_back(0);\n        for (int i = 1; i &lt;= n; ++ i)\n            sum.push_back(fruits[i - 1][1] + sum[i - 1]);\n\n        vector&lt;int&gt; pos;\n        for (int i = 0; i &lt; n; ++ i)\n            pos.push_back(fruits[i][0]);\n\n        // 枚举可能抵达的区间\n        int ans = 0;\n        for (int x = k; x &gt;= 0; -- x)\n        {\n            int y = (k - x) / 2;\n            int l, r;\n            // x + 2y = k\n            l = startPos - x, r = startPos + y;\n            auto pl = lower_bound(pos.begin(), pos.end(), l) - pos.begin(), pr = upper_bound(pos.begin(), pos.end(), r) - pos.begin();\n            ans = max(ans, sum[pr] - sum[pl]);\n            // 2y + x = k\n            l = startPos - y, r = startPos + x;\n            pl = lower_bound(pos.begin(), pos.end(), l) - pos.begin(), pr = upper_bound(pos.begin(), pos.end(), r) - pos.begin();\n            ans = max(ans, sum[pr] - sum[pl]);\n        }\n        \n        return ans;\n    }\n};\n</code></pre>\n",
            "tags": []
        }
    ]
}